<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
  xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
  <channel>
    <title>44bits.io</title>
    <link>https://www.44bits.io/ko</link>
    <description>44bits.io는 프로그래밍과 클라우드를 다루는 기술 블로그입니다.</description>
    <pubDate>Tue, 12 Nov 2019 17:08:07 +0900</pubDate>
    <item>
      <title>EC2, Fargate 약정 할인 AWS Savings Plans 발표: 예약 인스턴스(RI)를 대체할 약정 할인 방식</title>
      <link>https://www.44bits.io/ko/post/aws-introducing-savings-plans</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        EC2, Fargate 약정 할인 AWS Savings Plans 발표
                &lt;div class=&quot;subtitle&quot;&gt;예약 인스턴스(RI)를 대체할 약정 할인 방식&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;savings-plans-소개&quot;&gt;Savings Plans 소개&lt;/h2&gt;
&lt;p&gt;AWS에서는 컴퓨팅 자원의 사용량을 미리 약정하고 할인 받을 수 있는 새로운 요금 체계인 Savings Plans를 발표했습니다. 기존에도 아마존 EC2 예약 인스턴스&lt;sup&gt;RI, Reserved Instance&lt;/sup&gt;를 사용하면 사용량을 미리 약정할 수 있었습니다만, 리전, 사이즈, 인스턴스 세대 등을 명시적으로 선택해서 약정을 해야했습니다. AWS를 경험이 있으신 분들이 이 조합이 얼마나 다양한지 알고 있을 것입니다. 또한 이렇게 고정된 약정 사항에 대해서는 추후에 변경이 불가능하거나 제한적으로만 변경이 가능했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2019/11/introducing-savings-plans/&quot;&gt;20191106 Savings Plans 소개 - AWS 새소식&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ec2/pricing/reserved-instances/&quot;&gt;Amazon EC2 예약 인스턴스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 달리 Savings Plans은 예약 인스턴스보다 훨씬 할인이 포괄적으로 적용됩니다. Saving Planse은 시간당 사용 금액을 미리 약정하고, 이 약정한 금액에 대해서는 리전, 인스턴스 세대, 사이즈에 상관없이 요금 할인이 적용됩니다. 심지어는 EC2 뿐만 아니라 파게이트(Fargate) 사용 금액에 대해서도 할인이 적용됩니다.&lt;/p&gt;
&lt;h2 id=&quot;compute-savings-plans와-ec2-instance-savings-plans&quot;&gt;Compute Savings Plans와 EC2 Instance Savings Plans&lt;/h2&gt;
&lt;p&gt;이번에 출시된 Savings Plans는 크게 Compute Savings Plans와 EC2 Instance Savings Plans 두 가지 종류로 나뉩니다.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Copmute Savings Plans&lt;/dt&gt;
&lt;dd&gt;온디맨드 가격 대비 최대 66%할인이 적용되는 가장 유연한 플랜. 인스턴스 패밀리, 사이즈, AZ, 리전, OS, 테넌시에 상관없이 적용되는 플랜. EC2와 함께 파게이트에도 자동 적용됨.
&lt;/dd&gt;
&lt;dt&gt;EC2 Instance Savings Plans&lt;/dt&gt;
&lt;dd&gt;온대민드 가격 대비 최대 72% 할인이 적용되는 플랜. 리전과 인스턴스 패밀리를 정해서 적용하며, 사이즈, AZ, OS, 테넌시에 상관없이 적용되는 플랜. 파게이트는 적용되지 않음.
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Compute Savings Plans는 예약 인스턴스나 EC2 Instance Savings Plans보다 훨씬 더 포괄적으로 할인이 적용됩니다. 인스턴스 패밀리나 리전을 지정하지 않아도 EC2를 사용하는 거의 모든 경우에 할인이 적용됩니다. 이와 더불어 EC2뿐만 아니라 ECS에서 사용할 수 있는 파게이트에도 할인이 자동 적용됩니다. EC2 Instance Savings Plans의 경우 리전과 인스턴스 패밀리를 미리 지정해야합니다. 이 방식의 장점은 Compute Savings Plans보다 최대 할인 폭이 조금 더 크다는 점입니다.&lt;/p&gt;
&lt;h2 id=&quot;savisngs-plans의-구매-방식-이해하기&quot;&gt;Savisngs Plans의 구매 방식 이해하기&lt;/h2&gt;
&lt;p&gt;먼저 Savings Plans를 통해 할인되는 시간당 가격은 인스턴스 패밀리, 사이즈, 리전, OS, 테넌시에 따라 다르며, 이에 대해서는 가격 페이지에 확인할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/savingsplans/pricing/&quot;&gt;Savings Plans Pricing – Amazon Web Services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 Seoul 리전의 m5.large Linux(Shared 테넌시) 인스턴스의 경우 온디맨드 요금은 $0.118입니다. 1년 계약에 선결제가 없는 경우 Savings Plans이 적용된 가격은 $0.085입니다. RI에서 같은 조건의 인스턴스를 검색할 경우 선결제 없는 조건의 convertible 클래스의 가격과 거의 같은 것을 확인할 수 있습니다. 예약 인스턴스를 구매하는 경우 특정 조건의 인스턴스를 필요한 댓수만큼 주문하는 방식입니다. RI를 선결제 없이 구매하는 경우 인스턴스 사용 여부와 관계 없이 시간당 요금이 과금됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/abf/abfd9644090b030492b0c826664d8887bb6cffe72c5e763e142e24156116d14c.m.png&quot; alt=&quot;예약 인스턴스 가격표에서 확인한 서울 리전 m5.large Linux Shared 테넌시 가격&quot;&gt;&lt;figcaption&gt;예약 인스턴스 가격표에서 확인한 서울 리전 m5.large Linux Shared 테넌시 가격&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Savings Plans의 경우 이와 달리 댓수가 아닌 시간당 사용 금액을 미리 약정하는 방식입니다. RI와 달리 Savings Plans을 구매할 때 지정하는 조건들은 몇가지가 되지 않습니다. Compute Savings Plans을 구매하는 경우 오직 기간(1년 or 3년)과 선결제 방식(선결제 없음 or 부분 선결제 or 전액 선결제) 그리고 시간당 금액만을 지정합니다. 이 때 기간과 선결제 방식에 따라서 할인율이 달라집니다. 여기서 지정한 시간당 금액은 인스턴스의 사용 여부와 관계 없이 지불하는 약정 금액입니다. 예를 들어 $0.085를 시간당 요금으로 지정하면, 매 시간 $0.085가 과금됩니다. 인스턴스를 사용하지 않더라도 한 달을 대략 744시간으로 계산하면 $63.24의 비용이 발생합니다.&lt;/p&gt;
&lt;p&gt;이 조건 상에서 서울 리전의 m5.large Linux(Shared 테넌시) 인스턴스를 한 대 사용한다고 가정해보겠습니다. 비용은 시간당 $0.085이므로 Saving Plans에서 지정한 시간당 요금과 정확히 일치합니다. 이 경우 할인된 가격이 적용되므로 시간당 $0.085를 지불하고 이 인스턴스를 사용할 수 있습니다. 요금은 (월기준) 약정 금액과 같은 $63.24가 됩니다. 같은 인스턴스를 2대를 사용한다고 가정해보겠습니다. 1대를 사용하면서 이미 미리 지정한 시간당 요금은 모두 소진하므로, 나머지 한 대는 온디맨드 가격으로 과금이 이루어질 것입니다. 따라서 시간당 $0.203($0.085 + $0.118)이 과금되며, 한 달에 $151.032의 요금이 발생합니다. Saving Plans를 전혀 사용하지 않았을 경우에는 $175.584가 됩니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 이 계산은 예상되는 요금이며 실제 적용 방식에는 차이가 날 수 있습니다. 좀 더 자세한 내용은 Savings Plans의 가격, FAQ 등 공식 문서를 참고해서 판단하시기 바랍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;앞서 이야기한 대로 기간을 늘리거나 선결제를 하는 경우 할인율이 좀 더 높아집니다. 예약 인스턴스의 경우 기간을 늘리거나 선결제를 하는 경우 결제 금액이 낮아집니다. 하지만 Savings Plans를 사용하는 경우 시간당 요금을 직접 결정하기 때문에 전체 금액은 달라지지 않는다는 차이점이 있습니다. 기간을 늘리거나 선결제로 요금을 더 아끼고자 하는 경우에는 약정 금액도 적절하게 조정할 필요가 있어보입니다.&lt;/p&gt;
&lt;h2 id=&quot;savings-plans-구매하기&quot;&gt;Savings Plans 구매하기&lt;/h2&gt;
&lt;p&gt;Savings Plans는 AWS Cost Management 서비스에서 구매할 수 있습니다. 하지만 구매하기에 앞서 적절한 약정 금액을 계산할 필요가 있습니다.&lt;/p&gt;
&lt;p&gt;Savings Plans의 서브 메뉴에는 추천&lt;sup&gt;Recommendations&lt;/sup&gt; 메뉴가 있습니다. 이 메뉴에서는 현재 계정의 온디맨드 인스턴스의 사용량을 기반으로 옵션에 따라 약정 금액을 추천해줍니다. &lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 스크린샷을 찍은 계정에서는 온디맨드 사용량이 얼마 되지 않아 추천 금액이 나오지 않았습니다. 😅&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/9d7/9d783229b0a009fba61e09da443d14a64c1f5689e7f61fd10515157b9e0b7a9f.m.png&quot; alt=&quot;약정 금액 추천 메뉴&quot;&gt;&lt;figcaption&gt;약정 금액 추천 메뉴&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이는 과거 데이터를 기반으로 한 정보이므로, 이후에도 1년 이상 비슷한 정도나 그 이상 사용할 계획인 경우에는 이를 참고해서 약정을 진행하면 될 것으로 보입니다. 다른 변수들이 있는 경우에는 요금 페이지를 참고해서 직접 계산해보고 옵션과 약정 금액을 결정하는 것을 추천드립니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/savingsplans/pricing/&quot;&gt;Savings Plans Pricing – Amazon Web Services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;약정 옵션과 금액을 정했으면 &lt;em&gt;Savings Plans 구매하기&lt;/em&gt;&lt;sup&gt;Purchase Savings Plans&lt;/sup&gt; 메뉴에서 Savings Plans를 구매할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/a50/a50cf879a20a66ad25438be509977f85b9b0640cd9885ca520d355db8fc25899.m.png&quot; alt=&quot;Savings Plans 구매 화면&quot;&gt;&lt;figcaption&gt;Savings Plans 구매 화면&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Savings Plans 타입과 기간, 선결제 옵션을 선택하면 됩니다. 이는 할인 방식과 할인율을 결정하는 옵션들입니다. 앞서 설명했듯이 총 결제 금액은 오직 약정 금액에 의해서만 결정됩니다. 따라서 추천 메뉴나 직접 계산을 통해서 미리 적절한 약정 금액을 정해야합니다. Savings Plans을 카트에 넣고 결제를 진행할 수 있습니다. Savings Plans 구매 이후 에는 Utilization Report, Coverage Report 메뉴에서 현재 할인이 얼마나 적용되고 있는지를 확인할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;예약-인스턴스와-savings-plans&quot;&gt;예약 인스턴스와 Savings Plans&lt;/h2&gt;
&lt;p&gt;예약 인스턴스 종료에 대한 별도 공지는 없는 것으로 보입니다. Savings Plans의 FAQ에도 예약 인스턴스는 이후에도 계속 구매할 수 있다고 이야기하고 있습니다. 단, Savings Plans이 비슷한 수준의 할인을 제공하면서 훨씬 유연한 정책을 가지고 있기 때문에 현재 사용중인 예약 인스턴스 만료 이후에는 Savings Plans을 사용할 것을 권장한다고 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/savingsplans/faq/&quot;&gt;Savings Plans FAQ | Amazon Web Services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>nacyot</author>
      <pubDate>Mon, 11 Nov 2019 23:35:45 +0000</pubDate>
      <dc:date>2019-11-11T23:35:45+00:00</dc:date>
    </item>
    <item>
      <title>AWS 솔루션 아키텍트 어소시에이트 자격증 취득 후기 - AWS 공인 자격증 준비와 합격자 혜택</title>
      <link>https://www.44bits.io/ko/post/aws-certification-solutions-architect-associate</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        AWS 솔루션 아키텍트 어소시에이트 자격증 취득 후기
                &lt;div class=&quot;subtitle&quot;&gt;AWS 공인 자격증 준비와 합격자 혜택&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;현재 재직 중인 &lt;a href=&quot;http://team.daangn.com/&quot;&gt;당근마켓&lt;/a&gt;에서는 주로 아마존 웹 서비스&lt;sup&gt;Amazon Web Service&lt;/sup&gt;를 사용해 서비스를 운영하고 있습니다. 아마존 웹 서비스에는 다양한 공식 자격증이 존재합니다. 이 자격증을 가지고 있을 경우 당장 활용할 수 있는 혜택이 하나 있습니다. AWS에서 공식적으로 주최하는 행사에서 라운지에 출입할 수 있는 권한입니다. 라운지에 출입할 수 있는 혜택이 대단한 건 아닙니다만, 조금 더 여유롭게 행사를 즐길 수 있지 않을까, 이런 생각에 몇 년 째 자격증을 하나 따야겠다고 생각만 하고 있었습니다. 올 해 12월에 라스베이거스에서 열리는 &lt;a href=&quot;https://reinvent.awsevents.com/&quot;&gt;AWS 리인벤트&lt;/a&gt;&lt;sup&gt;AWS re:Invet&lt;/sup&gt; 행사 참여가 확정되었고, 자격증 모각공에 참여하면서 2019년 10월 드디어 시험에 합격했습니다. 생각부터 정작 실천에 옮기기 까지는 몇 년이 걸려버렸네요.&lt;/p&gt;
&lt;p&gt;이번에 참여한 모각공은 7월 말에 시작되어 지금까지 이어져오고 있습니다. 6명이서 참여하고 있는데 AWS 솔루션 아키텍트 어소시에이트&lt;sup&gt;Solutions Architect Associate&lt;/sup&gt; 두 명, 한 명의 클라우드 전문가&lt;sup&gt;Cloud Practitioner&lt;/sup&gt;를 배출했습니다&lt;sup&gt;?&lt;/sup&gt;. 나머지 분들도 10월 중에는 첫 시험을 보는 것으로 알고 있습니다. 다들 AWS 사용 경험이 있기 때문에 어렵지 않게 합격하리라 생각합니다. 개인적으로 다음 시험으로 솔루션 아키텍트 프로페셔널을 보려고 준비중입니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 자격증 시험을 준비하는 과정과 합격자 혜택에 대해서 소개해보고자 합니다.&lt;/p&gt;
&lt;h2 id=&quot;아마존-공인-자격증의-종류와-선택하기&quot;&gt;아마존 공인 자격증의 종류와 선택하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/certification/?nav=tc&amp;amp;loc=3&quot;&gt;AWS Certification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS 자격증을 취득하기로 결정했다면, 시험에 앞서 먼저 취득하고자 하는 자격증을 선택할 필요가 있습니다. AWS에서는 다양한 공인 자격증을 제공하고 있습니다. 크게 다음 다섯 가지 카테고리로 나눠집니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기초&lt;/li&gt;
&lt;li&gt;아키텍트&lt;/li&gt;
&lt;li&gt;운영&lt;/li&gt;
&lt;li&gt;개발자&lt;/li&gt;
&lt;li&gt;전문분야&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기초 카테고리에는 최근에 추가된 클로우드 전문가 시험&lt;sup&gt;Cloud Practitioner&lt;/sup&gt;이 포함됩니다. 그 다음으로 아키텍트, 운영, 개발자 카테고리가 있습니다. 각 영역의 전문성을 인증하는 시험으로 세부적으로는 어소시에이츠 등급과 프로페셔널 등급으로 나눠져있습니다. 단, 운영과 개발자 분야의 프로페셔널 자격증은 ’데브옵스 엔지니어 프로페셔널&lt;sup&gt;DevOps Engineer Professional&lt;/sup&gt;’로 공통입니다. 마지막으로 전문 분야 등급은 특정 분야의 도메인 지식에 대한 전문성을 인증하는 자격증입니다. 취득가능한 전체 자격증 목록은 2019년 10월 현재 다음과 같이 총 12개 입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/db3/db33f4d4554f5c5c9fcc0234d2e07eac3337bd4606741514ca3e8550358aa3ec.m.png&quot; alt=&quot;AWS 공인 자격증의 종류. 공식 홈페이지에서 발췌&quot;&gt;&lt;figcaption&gt;AWS 공인 자격증의 종류. 공식 홈페이지에서 발췌&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;기초
&lt;ul&gt;
&lt;li&gt;클라우드 전문가&lt;sup&gt;Cloud Practitioner&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;아키텍트
&lt;ul&gt;
&lt;li&gt;솔루션 아키텍트 어소시에이트&lt;sup&gt;Solutions Architect Associate&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;솔루션 아케텍트 프로페셔널&lt;sup&gt;Solutions Architect Professional&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;운영
&lt;ul&gt;
&lt;li&gt;시스옵스 관리자 어소시에이트&lt;sup&gt;SysOps Administrator Associate&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;데브옵스 엔지니어 프로페셔널&lt;sup&gt;DevOps Engineer Associate&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;개발자
&lt;ul&gt;
&lt;li&gt;개발자 어소시에이트&lt;sup&gt;Developer Associate&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;데브옵스 엔지니어 프로페셔널&lt;sup&gt;DevOps Engineer Associate&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;전문 분야
&lt;ul&gt;
&lt;li&gt;고급 네트워크&lt;sup&gt;Advanced Networking&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;보안&lt;sup&gt;Security&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;머신 러닝&lt;sup&gt;Machine Learning&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;빅데이터&lt;sup&gt;Big Data&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;알렉사 스킬 빌더&lt;sup&gt;Alexa Skill Builder&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자격증이 세분화되어있는 것을 알 수 있습니다. 자격증을 취득하는 경우 최종적으로 솔루션 아키텍트 프로페셔널이나 데브옵스 엔지니어 프로페셔널 취득을 목표로 잡는 것이 일반적으로 보입니다. 두 자격증이 가장 유명한 자격증이기도 합니다. 2018년까지는 프로페셔널 시험을 보기 위해 먼저 해당 카테고리의 어소시에이트에 합격을 했어야합니다. 하지만 현재는 이러한 조건이 폐지 되었기 때문에 모든 시험을 곧바로 볼 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2018/10/announcing-more-flexibility-for-aws-certification-exams/&quot;&gt;AWS Certification 시험에 대한 유연성 확대 발표&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 본인이 프로페셔널에 합격할 자신이 있다면 관심 분야의 프로페셔널 시험을 보는 것이 가장 이상적인 선택입니다. 바로 프로페셔널 시험을 보는 경우 솔루션 아키텍트 프로페셔널이 좀 더 어렵다고 알려져있는데, 데브옵스 엔지니어 프로페셔널은 시험 준비에 대한 정보가 상대적으로 적다는 점도 고려해야합니다.&lt;/p&gt;
&lt;p&gt;바로 프로페셔널 시험을 보는 게 효율적이더라도 가장 안전한 전략은 아닙니다. 같이 공부하는 분들 중에서 프로페셔널을 바로 선택한 경우는 없었습니다. 일단 프로페셔널 시험은 비용이 $300로 가장 비싸기 때문에 불합격했을 때 타격이 큽니다. 혹시 삼수라도 하게 되면 100만원 정도가 소요되므로 충분한 시험 준비가 되어있지 않다면, 적절한 선택이라고 보기 어렵습니다.&lt;/p&gt;
&lt;p&gt;그런데 AWS 공인 자격증의 경우 합격시 다른 시험의 비용을 50% 할인해주는 코드를 제공합니다. 시험 비용은 클라우드 전문가는 약 $100, 어소시에이트는 약 $150, 프로페셔널은 $300입니다. 따라서 순서대로 시험을 보더라도 합격만 한다면 시험 비용은 아주 크게 늘어나지 않습니다. 한 번 계산해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로페셔널 시험($300) = 총 $300&lt;/li&gt;
&lt;li&gt;어소시에이트($150) + 프로페셔널($150, 50%) = 총 $300&lt;/li&gt;
&lt;li&gt;클라우드 전문가($100) + 어소시에이트($75, 50%) + 프로페셔널($150, 50%) = $325&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 시험 합격시마다 50% 할인 쿠폰이 제공되는지까지는 확인하지 못 했습니다. 실제로 이렇게 2번 할인 혜택이 적용 가능한지는 확인이 필요합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;프로페셔널을 목표로 하는 경우 어떤 경로로 시험을 보더라도 총 비용은 크게 달라지지 않습니다. 비용과 안전성을 둘 다 고려한다면 클라우드 전문가나 어소시에이트부터 시작하는 것이 훨씬 낫습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 전문 분야 시험 비용은 $300이며 각 분야에 대한 전문성을 인증하는 시험이기 때문에 프로페셔널 급의 시험으로 보입니다. 시험 후기나 정보가 많지 않기 때문에 무작정 전문 분야 시험을 선택하기보다는 충분한 정보를 탐색해보시는 것을 추천드립니다.&lt;/p&gt;
&lt;h2 id=&quot;솔루션-아키텍트-어소시에이트-시험의-이해&quot;&gt;솔루션 아키텍트 어소시에이트 시험의 이해&lt;/h2&gt;
&lt;p&gt;저는 첫 시험으로 가장 무난한 솔루션 아키텍트 어소시에이트를 선택했습니다. 가장 후기도 많고, 강의나 시험 정보도 상대적으로 많기 때문입니다. 시험은 65문제, 150분, 객관식과 다중응답형 문제로 이루어집니다.&lt;/p&gt;
&lt;p&gt;먼저 공식 사이트 &lt;a href=&quot;https://aws.amazon.com/ko/certification/certified-solutions-architect-associate/&quot;&gt;AWS 공인 솔루션스 아키텍트 – 어소시에이트&lt;/a&gt; 페이지의 내용을 살펴봅니다. 공식 페이지에서는 ’지식 및 경험 권장 사항’으로 다음 항목이 나열되어 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨팅, 네트워킹, 스토리지 및 데이터베이스 AWS 서비스에 대한 실무 경험&lt;/li&gt;
&lt;li&gt;AWS 배포 및 관리 서비스에 대한 실무 경험&lt;/li&gt;
&lt;li&gt;AWS 기반 애플리케이션에 대한 기술 요구 사항을 식별 및 정의 가능&lt;/li&gt;
&lt;li&gt;주어진 기술 요구 사항에 부합하는 AWS 서비스를 식별 가능&lt;/li&gt;
&lt;li&gt;AWS 플랫폼에서 안전하고 안정적인 애플리케이션을 구축하는 권장 모범 사례에 대한 지식&lt;/li&gt;
&lt;li&gt;AWS 클라우드에서 구축할 때의 기본적인 아키텍처 원칙에 대한 이해&lt;/li&gt;
&lt;li&gt;AWS 글로벌 인프라에 대한 이해&lt;/li&gt;
&lt;li&gt;AWS와 관련된 네트워크 기술에 대한 이해&lt;/li&gt;
&lt;li&gt;AWS에서 제공하는 보안 기능 및 도구에 대한 이해와 이러한 기능 및 도구가 기존 서비스와 어떻게 관련되는지에 대한 이해&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://d1.awsstatic.com/training-and-certification/docs-sa-assoc/AWS_Certified_Solutions_Architect_Associate-Exam_Guide_EN_1.8.pdf&quot;&gt;솔루션 아키텍트 어소시에이트 시험 안내서&lt;/a&gt;에는 각 도메인에 대한 문제 비율이 나와있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도메인 1: 복원력을 갖춘 아키텍처 설계(Design Resilient Architectures), 34%&lt;/li&gt;
&lt;li&gt;도메인 2: 성능이 뛰어난 아키텍처 정의(Define Performant Architectures), 24%&lt;/li&gt;
&lt;li&gt;도메인 3: 안전한 애플리케이션 및 아키텍처 설명(Specify Secure Applications and Architectures), 26%&lt;/li&gt;
&lt;li&gt;도메인 4: 비용에 최적화된 아키텍처 설계(Design Cost-Optimized Architectures), 10%&lt;/li&gt;
&lt;li&gt;도메인 5: 운영 면에서 탁월한 아키텍처 정의(Define Operationally Excellent Architectures), 6%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 정보에서 확인할 수 있듯이 솔루션 아키텍트 어소시에이트는 AWS에서 제공하는 주요 서비스들에 대한 이해와 아키텍처 구성에 대한 시험입니다. 페이지에서는 시험 대상에 대해서 ’1년 이상 실제로 설계한 경험이 있으며 솔루션 아키텍트 역할을 수행하는 사람들’이라고 설명하고 있습니다. 시험 준비에 대해서도 ’실무 경험보다 더 좋은 준비는 없습니다’라고 이야기하고 있습니다. 실제로 따로 준비하지 않은 상황에서 시험의 체감 난이도는 AWS의 전반적인 서비스들을 1~2년 이상 직접 사용해봤다면 아슬아슬하게 합격할 정도라고 느꼈습니다. VPC나 네트워크 쪽은 기초 지식과 실무 경험 없이 시험 문제만 공부해서 보기는 조금 어렵지 않을까 싶었습니다.&lt;/p&gt;
&lt;p&gt;다음으로 &lt;a href=&quot;https://d1.awsstatic.com/training-and-certification/docs/AWS_Certified_Solutions_Architect_Associate_Sample_Questions.pdf&quot;&gt;시험 문제 예시&lt;/a&gt;를 꼭 살펴보시기 바랍니다. 개인적인 경험상 공식 시험 문제 예시는 양이 적지만 아주 중요합니다. 공식 시험 문제 예시의 지문 길이나 난이도가 실제 시험과 가장 유사합니다.&lt;/p&gt;
&lt;p&gt;또한 시험 안내서에서는 다음 백서들을 볼 것을 권장하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf&quot;&gt;Architecting for the Cloud: AWS Best Practices whitepaper, October 2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/architecture/well-architected/&quot;&gt;AWS Well-Architected webpage(various whitepapers linked)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;저는 시간 관계상 백서를 읽어보진 않았습니다만, 시간이 충분하다면 백서도 읽어보기를 추천합니다.&lt;/p&gt;
&lt;h2 id=&quot;솔루션-아키텍트-어소시에이트-시험-준비&quot;&gt;솔루션 아키텍트 어소시에이트 시험 준비&lt;/h2&gt;
&lt;p&gt;저와 함께 솔루션 아키텍트 어소시에이이트를 준비하는 분들은 주로 유데미&lt;sup&gt;Udemy&lt;/sup&gt;에서 &lt;a href=&quot;https://www.udemy.com/course/aws-certified-solutions-architect-associate/&quot;&gt;AWS Certified Solutions Architect - Associate 2019&lt;/a&gt; 강의를 구매해서 수강했습니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 자격증도 자격증이지만 AWS 기초를 다져보다는 생각도 있었기에 적절한 강의였다고 생각합니다. 강의는 IAM, S3 , EC2, 데이터베이스, 라우트53, VPC, HA 아케틱처, AWS 애플리케이션, 서버리스 등을 다루고 있으며 각 챕터 별로 1~2시간 정도의 강의를 제공하며, 챕터 별로 연습문제도 제공하고 있습니다. 그리고 마지막에는 연습 시험이 두 개 준비되어 있습니다. 이 강의를 이해할 수 있다면 어렵지 않게 합격할 수 있을 것으로 보입니다. 이 외에 따로 공부한 건 없었고, 마지막에 주요 서비스들의 FAQ 문서만 인쇄해서 쭉 읽어보았습니다. 백서는 따로 읽지 않았습니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 유데미로 강의를 듣을 때 어려움이 좀 있었습니다. 일단 가격 정책 자체가 불투명해서 강의가 11,000원으로 나왔다가도 로그인하면 22,000원으로 나오고, 다시 검색하면 더 비싸게 나오기도 하고, 하여간 여러모로 짜증납니다. 그리고 한국에서 유데미를 이용하는 경우 네트워크 문제가 있습니다. 이 부분은 통신사 문제인지 유데미 문제인지 불분명합니다만, 유데미로 검색해보면 VPN을 이용한다는 글들이 다수 검색됩니다. 같이 공부하는 분이 추천해주셔서 크롬 브라우저에서 &lt;a href=&quot;https://chrome.google.com/webstore/detail/touch-vpn/bihmplhobchoageeokmgbdihknkjbknd?hl=ko&quot;&gt;터치VPN&lt;/a&gt;&lt;sup&gt;TouchVPN&lt;/sup&gt;(무료)을 이용해 강의를 들었는데, 이것도 장소나 시간에 따라서 간혹 잘 되지 않아서 애를 먹었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;마지막에 포함된 연습문제는 실제 시험과는 많이 다른 느낌이었습니다. 훨씬 지문이 길거나 까다로운 문제가 많이 포함되어 있었고 지나치게 세부적인 내용을 묻는 문제들도 있었는데 실제 시험에는 이런 문제가 거의 나오지 않았습니다. 앞서 이야기한대로 공식 시험 문제 예시가 지문 길이나 난이도 면에서 실제 시험 문제와 가장 비슷합니다. 또한 중요한 부분에서 문제가 많이 나오기 때문에 세부 내용이나 자주 사용되지 않는 서비스들을 지나치게 깊이 공부할 필요는 없어 보입니다.&lt;/p&gt;
&lt;h3 id=&quot;aws-경험이-적은-분들을-위한-시험-준비-팁&quot;&gt;AWS 경험이 적은 분들을 위한 시험 준비 팁&lt;/h3&gt;
&lt;p&gt;프로그래머의 경우 AWS에서 사용해본 서비스가 EC2, RDS, 라우트53 정도로 제한되는 경우가 많습니다. 최근에는 서버리스가 유행하면서 람다만 사용해보신 분들도 있습니다. AWS 경험이 많지 않은 분들에게 팁을 드려보자면, 주요 서비스들을 한 번씩이라도 직접 사용해보는 게 도움이 많이 됩니다. 제가 들은 강의에서도 주요 서비스들에 대한 핸즈온을 포함하고 있습니다. 제대로 사용해본적이 없다면 반드시 핸즈온을 따라해보고 실제로 어떻게 사용하는지 경험해보는 것이 좋습니다. 어소시에이트의 경우 핸즈온과 시험 문제 풀어보는 정도로도 충분히 공부할 수 있습니다.&lt;/p&gt;
&lt;p&gt;VPC나 네트워크 쪽은 직접 설계해 본 적이 없으면 조금 어려울 수 있습니다. 강의에 추가적으로 AWS 공식 문서의 시나리오1, 시나리오2는 반드시 숙지하시기를 추천합니다. CIDR, 퍼블릭 서브넷과 프라이빗 서브넷의 차이, NAT가 왜 필요한지, NAT 인스턴스와 NAT 게이트웨이의 차이 등은 반드시 알고 있어야 합니다. 44bits에서도 AWS VPC 기초에 대해서 소개한 적이 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Scenario1.html&quot;&gt;시나리오 1: 단일 퍼블릭 서브넷을 가진 VPC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Scenario2.html&quot;&gt;시나리오 2: 퍼블릭 서브넷과 프라이빗 서브넷이 있는 VPC(NAT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.44bits.io/ko/post/understanding_aws_vpc&quot;&gt;만들면서 배우는 아마존 VPC(Amazon VPC) 입문: AWS 네트워크의 기초 | 44bits.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시간이 충분하다면 백서를 읽어보시는 것도 좋습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf&quot;&gt;Architecting for the Cloud: AWS Best Practices whitepaper, October 2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/architecture/well-architected/&quot;&gt;AWS Well-Architected webpage(various whitepapers linked)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 클라우드(AWS)의 아키텍처 설계에 대해서는 아래 책을 추천합니다. 조금 오래된 감이 있습니다만, 클라우드 기반 설계의 철학을 이해하는 데 있어 아주 훌륭한 책입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=27561469&quot;&gt;알라딘: 아마존 웹 서비스 클라우드 디자인 패턴 설계 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;더 많은 자료가 필요하다면 정도현 님이 작성하신 &lt;a href=&quot;https://gist.github.com/serithemage/df61aaf396046eff7244b6eaa8d58d4a&quot;&gt;비공식 AWS 공인 개발자 - 어소시에이트 수험 가이드&lt;/a&gt;를 참고해주세요. 단, 유데미 강의에서 다루는 주요 서비스들을 위주로 공부하는 것이 훨씬 효율적입니다. 이 범위 밖에서는 문제 출제 비중이 아주 낮습니다.&lt;/p&gt;
&lt;h2 id=&quot;시험-신청과-시험&quot;&gt;시험 신청과 시험&lt;/h2&gt;
&lt;p&gt;시험은 &lt;a href=&quot;https://www.aws.training/certification&quot;&gt;AWS Certification&lt;/a&gt; 페이지에서 신청합니다. 로그인을 하면 CertMetrics 페이지로 넘어갑니다. 시험을 신청하기 전에 &lt;em&gt;내 프로필&lt;/em&gt;&lt;sup&gt;My Profile&lt;/sup&gt; 탭에서 본인의 영어 이름과 주소가 제대로 입력되어 있는지 미리 확인합니다.&lt;/p&gt;
&lt;p&gt;홈에서 오른쪽에 있는 &lt;em&gt;새로운 시험 예약하기&lt;/em&gt;&lt;sup&gt;Schedule New Exam&lt;/sup&gt;를 클릭하면 응시할 수 있는 시험 목록을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/5de/5de1f47feac82c8c5de47e82c3847790905e1a8e5691f1f3de7c3e9789f6bcb5.m.png&quot; alt=&quot;CertMetrics의 홈. 여기서 시험 예약을 할 수 있습니다.&quot;&gt;&lt;figcaption&gt;CertMetrics의 홈. 여기서 시험 예약을 할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 중에서 원하는 시험을 선택해서 일정을 정하면 됩니다. 시험 센터는 크게 PSI와 피어슨 VUE가 있습니다. 한국에서도 두 시험 센터에서 모두 시험을 볼 수 있기 때문에 일정/장소를 확인할 때는 PSI와 피어슨 VUE 모두 확인하고 결정하기를 추천드립니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/340/34049594abeee1ebe70933c2ad7f2c41397ccdcaa4c546a71ad48949f9d90b01.m.png&quot; alt=&quot;응시 가능한 시험 목록을 확인할 수 있습니다.&quot;&gt;&lt;figcaption&gt;응시 가능한 시험 목록을 확인할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;피어슨 VUE가 시험칠 수 있는 곳이 많은 느낌이었습니다. 시험장 별로 시험 환경이 조금씩 차이가 날 수 있는데 미리 확인하기는 어렵습니다. 저는 처음에 피어슨 VUE에서 9월 5일에 강남역 바로 옆에 시험장을 예약했는데, 시험 장소 사정으로 취소가 되었고 다시 10월에 10일 역삼역 근처의 글로벌널리지로 일정을 잡았습니다. 신청할 때는 영어 이름, 시간, 장소, 시험 언어 등을 반드시 한 번 더 확인해주세요.&lt;/p&gt;
&lt;p&gt;시험 언어의 경우 현재 AWS 자격증 대부분의 시험에서 공식 언어로 한글을 지원하고 있습니다. 한글로 시험을 응시하더라도 별도의 불이익은 없으며 시험 중 영어 문제를 확인할 수 있으니 특별한 이유가 없다면 한글로 시험 보는 것을 추천드립니다. 영어로 시험을 보는 경우 외국인은 추가 시간 30분을 미리 신청할 수 있다고 하니 확인해보시기 바랍니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 한글 시험 지원 여부는 시험 별로 미리 확인이 필요합니다. 시험이 변경되는 경우 일시적으로 한글 시험을 지원하지 않는 경우가 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;시험 일정이 결정된 이후에는 신청한 계정의 이메일로 안내 메일이 수시로 올 수 있으니 꼭 확인을 해야합니다. 시험 당일에는 &lt;strong&gt;반드시&lt;/strong&gt; 신분증과 영어 이름을 확인할 수 있는 신분증 이렇게 두 가지를 준비해야 합니다. 시험장으로 가면 간단한 안내 이후 바로 시험을 진행합니다. 시험은 개인 별로 진행하기 때문에 시험장의 공석 여부에 따라서 예약 시간에서 조금 조정될 수 있습니다.&lt;/p&gt;
&lt;p&gt;솔루션 아키텍트 어소시에이트 시험은 130분간 65문항을 풀게 됩니다. 대부분의 문제는 문제 예시의 길이와 크게 다르지 않습니다. 문제는 앞뒤로만 이동 가능한데, 한 바퀴를 다 돌고 나면 앞의 문제들을 다시 검토할 수 있습니다. 문제에 플래그를 해둔 경우 플래그를 해둔 문제만 재검토할 수 있으니 확신이 가는 문제부터 풀어가는 것도 좋습니다. 제 경우 전체 문제 재검토까지 70~80분 정도 시간이 걸렸던 것 같습니다. 시험이 끝나서 제출을 하면 곧바로 합격 여부가 출력되고 시험이 종료됩니다.&lt;/p&gt;
&lt;h2 id=&quot;합격자-혜택-및-자격증-확인&quot;&gt;합격자 혜택 및 자격증 확인&lt;/h2&gt;
&lt;p&gt;자세한 시험 결과는 하루 이틀 내에 메일로 알려줍니다. 메일이 오면 자격증 페이지의 &lt;em&gt;이전 시험&lt;/em&gt;&lt;sup&gt;Pervious Exams&lt;/sup&gt;에서 상세 결과를 PDF 파일로 다운로드할 수 있습니다. 이 PDF 파일에는 합격 여부, 합격 점수, 도메인 별 시험 성적(시험 합격과는 무관합니다)이 들어 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/21b/21b16304497c2805f1dfb93b28a79b400d3724fe16179b75c2dc5241e0916b57.m.png&quot; alt=&quot;지난 시험 결과 확인하기&quot;&gt;&lt;figcaption&gt;지난 시험 결과 확인하기&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;합격 이후에는 혜택&lt;sup&gt;Benefits&lt;/sup&gt; 페이지에서 합격에 대한 혜택 내용을 확인할 수 있습니다. 무료 연습 시험, 다른 시험 50% 할인 쿠폰, 합격자 전용 상품 구매, SME 프로그램 참여 등의 혜택이 주어집니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/6ba/6ba338bdcd488b3d99f44a30be1029dd311247b69a859260d7e03e66f1755031.m.png&quot; alt=&quot;AWS 자격증 합격 혜택들&quot;&gt;&lt;figcaption&gt;AWS 자격증 합격 혜택들&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;합격자 전용 스토어에도 들어가봤는데 살만한 물건이 있는지는 잘 모르겠습니다 😅.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/29a/29a25bc73c0eabe1f985ee9bb2a431520398011edc9cb4e80d70245b77171b0d.m.png&quot; alt=&quot;AWS 자격증 취득자용 스토어에서 살 수 있는 굿즈&quot;&gt;&lt;figcaption&gt;AWS 자격증 취득자용 스토어에서 살 수 있는 굿즈&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;자격증&lt;/em&gt;&lt;sup&gt;Archived Certifications&lt;/sup&gt; 페이지에서 취득한 자격증 목록을 확인할 수 있습니다. 또한 목록의 오른쪽 링크를 통해 자격증 공인 로고와 합격증을 PDF로 다운로드할 수 있습니다. 합격자는 로고와 뱃지를 사용할 수 있는 자격이 생깁니다. 그렇다고 마음대로 사용하면 되는 건 아니고 가이드라인을 준수해야 합니다. 필요한 경우 로고 파일에 첨부된 가이드 문서를 참고해서 사용하세요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/682/682a23f9ee0acc9dc0f8d82140666a02ac48b73a3a37848124bf813a34c926b5.m.png&quot; alt=&quot;합격증과 공인 로고를 다운로드 받을 수 있습니다&quot;&gt;&lt;figcaption&gt;합격증과 공인 로고를 다운로드 받을 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;혜택에 대한 자세한 내용은 공식 안내 페이지 &lt;a href=&quot;https://aws.amazon.com/ko/certification/benefits/&quot;&gt;AWS Certification 혜택&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;마지막으로, 합격증입니다! 자격증에서 확인할 수 있듯이 시험 결과는 3년간 유효하며 이후에는 재시험을 치러야 합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/615/615ccc7e3d1b1538b9463950369895073b9bc470d52ed8197f0c09663e4d0c1d.m.png&quot; alt=&quot;AWS 솔루션 아키텍트 어소시에이트 합격증&quot;&gt;&lt;figcaption&gt;AWS 솔루션 아키텍트 어소시에이트 합격증&lt;/figcaption&gt;
&lt;/figure&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>nacyot</author>
      <pubDate>Mon, 21 Oct 2019 08:11:14 +0000</pubDate>
      <dc:date>2019-10-21T08:11:14+00:00</dc:date>
    </item>
    <item>
      <title>파이썬(Python) 3.8 릴리스와 주요 변경 사항 - 할당표현식, 위치 한정 파라미터, f-문자열 평가식 지원</title>
      <link>https://www.44bits.io/ko/post/python-3-8-release-note-summary</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        파이썬(Python) 3.8 릴리스와 주요 변경 사항
                &lt;div class=&quot;subtitle&quot;&gt;할당표현식, 위치 한정 파라미터, f-문자열 평가식 지원&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;p&gt;이 글에서는 파이썬 3.8에 추가된 기능과 바뀐 점을 알아보려 합니다. &lt;a href=&quot;https://docs.python.org/ko/3.8/whatsnew/3.8.html&quot;&gt;What’s New In Python 3.8 — Python 3.8.0 문서&lt;/a&gt;를 참고하였습니다. &lt;strong&gt;주의! 개인적으로 판단하기에 사소한 사항들은 번역하지 않았고, 릴리스 노트만으로 이해하기가 어려운 기능엔 설명을 조금 보태었습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;사용자 입장에서 주목할 만한 부분은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;할당 표현식&lt;sup&gt;assignment expressions&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;위치 한정 파라미터&lt;sup&gt;positional-only parameter&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;f-문자열에서 평가식&lt;sup&gt;self-documenting expressions&lt;/sup&gt; 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;할당-표현식assignment-expressions&quot;&gt;할당 표현식&lt;sup&gt;assignment expressions&lt;/sup&gt;
&lt;/h2&gt;
&lt;p&gt;한때 &lt;a href=&quot;https://stdout.fm/9/&quot;&gt;논란의 중심&lt;/a&gt;에 있던 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;PEP 572 - 할당 표현식&lt;/a&gt;이 드디어 추가되었습니다. 개념을 이해하기 위해 예시를 살펴보죠.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;while 문 예시&lt;/strong&gt; 다음은 while 반복문에서는 흔히 나타나는 코드입니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;    line &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fp.readline()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;    ...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;할당 표현식을 사용하면 다음과 같이 간단해 집니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; (line :&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fp.readline()):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;    ...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;if 문 예시&lt;/strong&gt; if 문 역시 간단해 집니다. 다음 코드의 2~3행을,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; data:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;    title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; item.get(&lt;span class=&quot;st&quot;&gt;'title'&lt;/span&gt;)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; title:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(title)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;할당 표현식을 사용하여 한 줄로 줄일 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; data:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; title :&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; item.get(&lt;span class=&quot;st&quot;&gt;'title'&lt;/span&gt;)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-3&quot; data-line-number=&quot;3&quot;&gt;        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(title)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;리스트 캄프리헨션 예시&lt;/strong&gt; 다음과 같은 리스트 캄프리헨션 코드에도,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-1&quot; data-line-number=&quot;1&quot;&gt;stuff &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; y: [y,x&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;y])(f(x)) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;할당 표현식을 적용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;stuff &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [[y :&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f(x), x&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;y] &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PEP 572의 제목은 할당 표현식이지만, 이전에는 바다코끼리 연산자&lt;sup&gt;the walrus operator&lt;/sup&gt;로 널리 알려졌고, CPython 내부적으로는 이름 붙은 표현식&lt;sup&gt;named expressions&lt;/sup&gt;이라는 용어를 사용합니다.&lt;/p&gt;
&lt;h2 id=&quot;위치-고정-파라미터positional-only-parameter&quot;&gt;위치 고정 파라미터&lt;sup&gt;positional-only parameter&lt;/sup&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0570&quot;&gt;PEP 570 - 위치 고정 파라미터&lt;/a&gt;는 메서드나 함수의 특정 위치에서 정해진 파라미터만 받는 기능입니다. 함수 정의 부분에 위치 고정 파라미터를 선언하고 &lt;code&gt;/&lt;/code&gt; 기호를 넣는 방식입니다.&lt;/p&gt;
&lt;p&gt;다음 함수의 정의 부분에 &lt;code&gt;/&lt;/code&gt; 기호를 추가했는데요. 여기서 &lt;code&gt;a&lt;/code&gt;와 &lt;code&gt;b&lt;/code&gt;는 위치 지고 파라미터, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;는 위치 혹은 키워드 파라미터, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;는 키워드 파라미터가 됩니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; f(a, b, &lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;, c, d, &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;, e, f):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(a, b, c, d, e, f)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서, &lt;code&gt;f&lt;/code&gt; 함수를 이런 식으로는 호출할 수 있지만,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-1&quot; data-line-number=&quot;1&quot;&gt;f(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, c&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;, d&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;, e&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, f&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 식으로는 호출할 수 없습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-1&quot; data-line-number=&quot;1&quot;&gt;f(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, b&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, c&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;, d&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;, e&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, f&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;# b는 키워드 전달인자가 될 수 없습니다.&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-2&quot; data-line-number=&quot;2&quot;&gt;f(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, f&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;)           &lt;span class=&quot;co&quot;&gt;# e는 키워드 전달인자여야 합니다.&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 통해 라이브러리 제작자들이 라이브러리를 좀더 견고하게 만들 수 있고 언어의 일관성도 향상될 것으로 기대한다고 하네요.&lt;/p&gt;
&lt;h2 id=&quot;f-문자열에서-평가식self-documenting-expressions을-위한-기호-추가&quot;&gt;f-문자열에서 평가식&lt;sup&gt;self-documenting expressions&lt;/sup&gt;을 위한 &lt;code&gt;=&lt;/code&gt; 기호 추가&lt;/h2&gt;
&lt;p&gt;다양한 문자열을 조합할 때 f-string이 굉장히 유용한데요. f-string 안에 변수 이름과 변수 출력 부분을 넣으려면 다음과 같이 중복이 발생하곤 했습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-1&quot; data-line-number=&quot;1&quot;&gt;name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'raccoony'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;ss&quot;&gt;f'name = &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# name = raccoony&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;파이썬 3.8에서는 이러한 중복을 줄일 수 있습니다. f-string의 표현식 내부에 &lt;code&gt;=&lt;/code&gt; 기호를 사용하면 앞의 코드를 이렇게 바꿀 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb11&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-1&quot; data-line-number=&quot;1&quot;&gt;name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'raccoony'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;ss&quot;&gt;f'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{&lt;/span&gt;name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# name = raccoony&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;숫자 포맷 등도 지정할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb12&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-1&quot; data-line-number=&quot;1&quot;&gt;pi &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;3.141592&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;ss&quot;&gt;f'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{pi&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;:.3f}&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# pi = 3.141&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-3&quot; data-line-number=&quot;3&quot;&gt;love_as &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;ss&quot;&gt;f'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{&lt;/span&gt;love_as &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;:,d}&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# love_as = 3,000&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 외에 다른 변경 사항은 &lt;a href=&quot;https://docs.python.org/ko/3.8/whatsnew/3.8.html&quot;&gt;What’s New In Python 3.8 — Python 3.8.0 문서&lt;/a&gt;를 참고하시면 됩니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Tue, 15 Oct 2019 02:59:30 +0000</pubDate>
      <dc:date>2019-10-15T02:59:30+00:00</dc:date>
    </item>
    <item>
      <title>깔끔한 파이썬 테스트 코드를 위한 페이커(Faker)와 팩토리 보이(Factory Boy)</title>
      <link>https://www.44bits.io/ko/post/faker-and-factory-boy-for-clean-code-on-python-test</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        깔끔한 파이썬 테스트 코드를 위한 Faker와 Factory Boy
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;임의의-값만-테스트하게-되는-문제&quot;&gt;임의의 값만 테스트하게 되는 문제&lt;/h2&gt;
&lt;p&gt;테스트 코드를 읽기 힘들게 만드는 이유 중 하나는 테스트용 임시 데이터를 생성하는 코드에서 임의의 값이 남발되기 때문입니다. 이런 식으로요.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;email &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test@test.net'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;username &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'testuser'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;age &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 임의의 값을 사용하면, 해당 값에 대해서만 테스트 코드가 통과하는지도 모른다는 불안감이 생기기 마련인데요. &lt;a href=&quot;https://faker.readthedocs.io/en/master/&quot;&gt;Faker 라이브러리&lt;/a&gt;를 사용하여 이를 해결할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;무작위-값을-생성해주는-faker-라이브러리&quot;&gt;무작위 값을 생성해주는 Faker 라이브러리&lt;/h2&gt;
&lt;p&gt;Faker 라이브러리는 실행 시점에 무작위 값을 생성합니다. 다음과 같이요.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; faker &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Faker&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;fake &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Faker()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-4&quot; data-line-number=&quot;4&quot;&gt;email &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fake.email()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-5&quot; data-line-number=&quot;5&quot;&gt;username &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fake.user_name()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-6&quot; data-line-number=&quot;6&quot;&gt;age &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fake.pyint(min_value&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, max_value&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 활용하여 Django에서 임시 인스턴스를 만든다면 다음과 같은 식이 될 겁니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_post(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;    post &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post.objects.create(&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;        blog&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;        title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;faker.sentence(),&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-5&quot; data-line-number=&quot;5&quot;&gt;        tags&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[faker.word()]&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-6&quot; data-line-number=&quot;6&quot;&gt;    )&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;특정 값이 사라짐으로써 의도를 더 드러낼 수 있고, 매번 다른 값으로 테스트를 실행할 수 있어서 코드도 좀더 안정적일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;반복되는-테스트-코드-문제&quot;&gt;반복되는 테스트 코드 문제&lt;/h2&gt;
&lt;p&gt;만약 테스트 코드에서 블로그 글을 열 개 만들어야 한다면 어떤 일이 발생할까요? 다음과 같이 굉장히 반복되는 테스트 코드가 만들어집니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; setUp(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Blog.objects.create(title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'test blog'&lt;/span&gt;)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-3&quot; data-line-number=&quot;3&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_10_posts(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-5&quot; data-line-number=&quot;5&quot;&gt;    post1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post.objects.create(&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-6&quot; data-line-number=&quot;6&quot;&gt;        blog&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-7&quot; data-line-number=&quot;7&quot;&gt;        title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;faker.sentence()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-8&quot; data-line-number=&quot;8&quot;&gt;    )&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-9&quot; data-line-number=&quot;9&quot;&gt;    post2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post.objects.create(&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-10&quot; data-line-number=&quot;10&quot;&gt;        blog&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-11&quot; data-line-number=&quot;11&quot;&gt;        title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;faker.sentence()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-12&quot; data-line-number=&quot;12&quot;&gt;    )&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-13&quot; data-line-number=&quot;13&quot;&gt;    post3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post.objects.create(&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-14&quot; data-line-number=&quot;14&quot;&gt;        blog&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-15&quot; data-line-number=&quot;15&quot;&gt;        title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;faker.sentence()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-16&quot; data-line-number=&quot;16&quot;&gt;    )&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-17&quot; data-line-number=&quot;17&quot;&gt;    ...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;임시 데이터 생성용 라이브러리를 사용하면 이를 간결하게 줄일 수 있는데, 개인적으로는 &lt;a href=&quot;https://factoryboy.readthedocs.io/en/latest/&quot;&gt;Factory Boy&lt;/a&gt;가 여러 모로 마음에 들어 사용하고 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;factory-boy로-django-테스트-코드-간략화하기&quot;&gt;Factory Boy로 Django 테스트 코드 간략화하기&lt;/h2&gt;
&lt;p&gt;먼저 임시 데이터 생성용 Factory를 선언합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; factory&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BlogFactory(factory.django.DjangoModelFactory):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-4&quot; data-line-number=&quot;4&quot;&gt;    title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; factory.Faker(&lt;span class=&quot;st&quot;&gt;'sentence'&lt;/span&gt;)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PostFactory(factory.django.DjangoModelFactory):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-7&quot; data-line-number=&quot;7&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-8&quot; data-line-number=&quot;8&quot;&gt;        model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-9&quot; data-line-number=&quot;9&quot;&gt;    title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; factory.Faker(&lt;span class=&quot;st&quot;&gt;'sentence'&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 중복되는 테스트 코드를 Factory Boy로 다시 작성하면 다음과 같이 줄일 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; setUp(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BlogFactory()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-3&quot; data-line-number=&quot;3&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_10_posts(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-5&quot; data-line-number=&quot;5&quot;&gt;    PostFactory.create_batch(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, blog&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.blog)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;연관-모델-함께-생성하기-subfactory&quot;&gt;연관 모델 함께 생성하기 SubFactory&lt;/h3&gt;
&lt;p&gt;새 Blog를 열 개 만들고, 각 Blog에 Post를 하나씩 만들고 싶다면 SubFactory를 지정하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PostFactory(factory.django.DjangoModelFactory):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-3&quot; data-line-number=&quot;3&quot;&gt;        model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Post&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-4&quot; data-line-number=&quot;4&quot;&gt;    blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; SubFactory(BlogFactory)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-5&quot; data-line-number=&quot;5&quot;&gt;    ...&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-6&quot; data-line-number=&quot;6&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_10_blogs_and_posts(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-8&quot; data-line-number=&quot;8&quot;&gt;    PostFactory.create_batch(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 Post를 생성하기 전 알아서 Blog를 생성해줍니다.&lt;/p&gt;
&lt;h3 id=&quot;choicefield에-대응하는-fuzzychoice&quot;&gt;ChoiceField에 대응하는 FuzzyChoice&lt;/h3&gt;
&lt;p&gt;Post에 카테고리를 지정한다고 가정해보죠. general과 it, book 카테고리 중 하나를 선택할 수 있도록 ChoiceField로 지정해 두었을 겁니다. 이때 테스트용 Post는 세 카테고리 중 하나를 무작위로 골라서 넣어주면 좋겠죠.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PostFactory(factory.django.DjangoModelFactory):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-2&quot; data-line-number=&quot;2&quot;&gt;    ...&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb8-3&quot; data-line-number=&quot;3&quot;&gt;    category &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; factory.fuzzy.FuzzyChoice(choices&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'general'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'it'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'book'&lt;/span&gt;])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;순차적인-값-sequence&quot;&gt;순차적인 값 Sequence&lt;/h3&gt;
&lt;p&gt;어떤 이유로 Post에 일련 번호를 지정해야 한다면 Sequence를 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PostFactory(factory.django.DjangoModelFactory):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-2&quot; data-line-number=&quot;2&quot;&gt;    ...&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-3&quot; data-line-number=&quot;3&quot;&gt;    slug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; factory.Sequence(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; n: &lt;span class=&quot;ss&quot;&gt;f'slug-&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{n}&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 외에도 특정 메서드를 실행한 값을 넣어줄 수 있는 LazyFunction이나 인스턴스 스스로의 값을 참조하여 또다른 값을 생성해야 할 때 사용하는 LazyAttribute 등 다양한 기능이 존재합니다. 더 자세한 내용은 &lt;a href=&quot;https://factoryboy.readthedocs.io/en/latest/&quot;&gt;Factory Boy 문서&lt;/a&gt;를 참고하시기 바랍니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Tue, 01 Oct 2019 23:40:16 +0000</pubDate>
      <dc:date>2019-10-01T23:40:16+00:00</dc:date>
    </item>
    <item>
      <title>tfenv로 테라폼(Terraform) 버전 관리하기</title>
      <link>https://www.44bits.io/ko/post/managing-teraform-versions-with-tfenv</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        tfenv로 테라폼 버전 관리하기
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;들어가며-버전관리가-필요한-이유&quot;&gt;들어가며 : 버전관리가 필요한 이유&lt;/h2&gt;
&lt;p&gt;테라폼&lt;sup&gt;Terraform&lt;/sup&gt;을 사용하다 보면 여러 버전을 동시에 사용하는 경우가 발생합니다. 최근에 만든 프로젝트는 최신 버전이지만 이전에 만든 리소스를 굳이 건드리고 싶지 않다거나 아직 기능을 지원하지 않는 등 이유는 다양합니다. 하지만 테라폼은 자체적으로 버전 관리 기능이 없어 여러 개의 버전을 동시에 사용하기 위해 direnv를 이용해 프로젝트별 테라폼의 경로를 다르게 잡거나 brew로 여러 개를 설치해두고 전환(Switch)하며 사용하기도 합니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 &lt;a href=&quot;https://github.com/tfutils/tfenv&quot;&gt;tfenv&lt;/a&gt;를 사용해 쉽게 테라폼 여러 버전을 사용하는 방법을 소개합니다. tfenv는 루비&lt;sup&gt;Ruby&lt;/sup&gt; 언어의 버전관리 시스템인 &lt;a href=&quot;https://github.com/rbenv/rbenv&quot;&gt;rbenv&lt;/a&gt;에서 영감을 얻어서 만들었습니다.&lt;/p&gt;
&lt;h2 id=&quot;tfenv-설치&quot;&gt;tfenv 설치&lt;/h2&gt;
&lt;p&gt;macOS인 경우 brew 사용해 tfenv를 설치합니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ brew install tfenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;리눅스&lt;sup&gt;Linux&lt;/sup&gt; 계열에서는 Git 소스를 클론(Clone)후 PATH에 추가합니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ git clone https://github.com/tfutils/tfenv.git ~/.tfenv
$ echo 'export PATH=&quot;$HOME/.tfenv/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bash_profile&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;tfenv-사용&quot;&gt;tfenv 사용&lt;/h2&gt;
&lt;p&gt;tfenv 사용을 위해 먼저 테라폼 버전을 설치해야 합니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;# 설치가능한 테라폼 버전 목록 보기
$ tfenv list-remote
0.12.9
0.12.8
0.12.7
0.12.6
...

# 특정 버전 설치
$ tfenv install 0.12.9

# 최신 버전 설치
$ tfenv install latest

# 테라폼 파일 분석후 최소 요구 버전 설치
$ tfenv install min-required

# .terraform-version에 지정된 버전 설치
$ terraform install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치된 테라폼 버전 목록을 보기위해서는 list 명령어를 사용합니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ tfenv list
* 0.12.9 (set by /usr/local/Cellar/tfenv/1.0.1/version)
  0.11.14
  0.11.13&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치가 완료 되었다면 버전 전환을 할때는 다음 명령어를 사용합니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;# 특정 버전 사용
$ tfenv use 0.12.9

# 최신 버전 사용
$ tfenv use latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매번 테라폼 버전을 변경하는것이 번거로운 경우 &lt;code&gt;.terraform-version&lt;/code&gt;을 사용합니다. &lt;code&gt;.terraform-version&lt;/code&gt; 파일에 버전을 명시하면 해당 폴더는 물론 하위폴더에서 해당 버전으로 사용됩니다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ echo 0.11.14 &amp;gt; .terraform-version
Terraform v0.11.14

$ echo latest &amp;gt; .terraform-version
$ terraform --version
Terraform v0.12.9&lt;/code&gt;&lt;/pre&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>seapy</author>
      <pubDate>Mon, 30 Sep 2019 23:38:07 +0000</pubDate>
      <dc:date>2019-09-30T23:38:07+00:00</dc:date>
    </item>
    <item>
      <title>싱크띵(Syncthing), 여러 기기간 파일 동기화 애플리케이션: 드롭박스 대신 무료로 가능한 오픈소스 프로젝트</title>
      <link>https://www.44bits.io/ko/post/syncthink-syncing-file-between-multiple-devices</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        싱크띵(Syncthing), 여러 기기간 파일 동기화 애플리케이션
                &lt;div class=&quot;subtitle&quot;&gt;드롭박스 대신 무료로 사용 가능한 오픈소스 프로젝트&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;두-줄-요약&quot;&gt;두 줄 요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;.gitignore&lt;/code&gt;처럼 동기화하지 않을 파일/패턴 지정 가능&lt;/li&gt;
&lt;li&gt;무료&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;요구사항&quot;&gt;요구사항&lt;/h2&gt;
&lt;p&gt;얼마 전 개인용 랩톱을 구입했더니, 회사에서 작업하던 내용을 집에 가서도 확인해보고 싶어졌습니다. 이를 위해 어떤 도구를 사용할까 고민했는데요. 요구 사항은 크게 두 가지였습니다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;내가 신경 쓰지 않아도 동기화되면 좋겠다. (이왕이면 동기화 속도도 빨랐으면)&lt;/li&gt;
&lt;li&gt;동기화하지 않을 파일 패턴을 지정할 수 있으면 좋겠다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;드롭박스 등 여러 유료 도구를 찾아보았지만 딱히 마음에 들지 않았는데, &lt;a href=&quot;https://syncthing.net/&quot;&gt;싱크띵&lt;sup&gt;Syncthing&lt;/sup&gt;&lt;/a&gt;을 발견하여 정착했습니다. 여기서는 싱크띵&lt;sup&gt;Syncthing&lt;/sup&gt;의 사용법을 간단히 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;싱크띵syncthing&quot;&gt;싱크띵(Syncthing)&lt;/h2&gt;
&lt;p&gt;싱크띵은 오픈소스 동기화 프로그램입니다. 두 대 이상의 컴퓨터를 별도 서버 없이 동기화할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/da1/da10f8b3319254de607653858bfd37060796e6248e0bcc270ecfffc3c69e79f6.m.png&quot; alt=&quot;오픈소스 동기화 도구 싱크띵(Syncthing)&quot;&gt;&lt;figcaption&gt;오픈소스 동기화 도구 싱크띵(Syncthing)&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;장점으로 내세우는 부분은 개인 전용(중앙 서버 없음), 보안, 클라이언트별 인증이지만 제게는 별로 중요하진 않았고, 리눅스 명령어에 익숙하지 않은터라 GUI를 제공한다는 점은 꽤 매력적이었습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/d65/d654102581c0d1e107e24c7709c5aeadc1ae5b1c5b3619392b36231c060971d8.m.png&quot; alt=&quot;싱크띵 GUI&quot;&gt;&lt;figcaption&gt;싱크띵 GUI&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;설치하기&quot;&gt;설치하기&lt;/h2&gt;
&lt;p&gt;맥OS에서는 &lt;code&gt;brew&lt;/code&gt;로 설치하기를 권합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install syncthing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;재부팅 후에도 계속 작동하게 하고 싶다면 다음 명령을 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew services start syncthing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;내장 GUI에 접근하려면 웹 브라우저에서 &lt;code&gt;http://127.0.0.01:8384&lt;/code&gt;에 접근하면 됩니다.&lt;/p&gt;
&lt;p&gt;맥OS에서 웹 GUI 대신 메뉴바로 관리할 수 있는 &lt;code&gt;syncthing&lt;/code&gt; 앱도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew cask install syncthing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(저는 딱히 필요하지 않아서 설치하지 않았습니다.)&lt;/p&gt;
&lt;h2 id=&quot;동기화할-클라이언트-추가하기&quot;&gt;동기화할 클라이언트 추가하기&lt;/h2&gt;
&lt;p&gt;여기서는 &lt;em&gt;랩톱 office&lt;/em&gt;와 &lt;em&gt;랩톱 private&lt;/em&gt;이 있다고 가정하겠습니다. &lt;em&gt;랩톱 office&lt;/em&gt;에서 메뉴의 &lt;em&gt;Actions -&amp;gt; Show ID&lt;/em&gt;를 선택합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/c05/c05ecec36a341604cb5ce128fe9faf090f9e9799947a9f0aade6a77a03cb1bd7.m.png&quot; alt=&quot;Actions -&amp;gt; Show ID를 선택합니다&quot;&gt;&lt;figcaption&gt;Actions -&amp;gt; Show ID를 선택합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;다음과 같은 화면에서 ID를 복사해둡니다. (모바일 기기에서 &lt;em&gt;랩톱 office&lt;/em&gt;를 추가한다면 ID 아래의 QR 코드를 찍어도 됩니다.)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/530/5303ce7c05d1f314b54424e1c5f044abc483e1cfc52c598dffbbed373784557a.m.png&quot; alt=&quot;ID를 복사합니다.&quot;&gt;&lt;figcaption&gt;ID를 복사합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이제 &lt;em&gt;랩톱 private&lt;/em&gt;에서 오른쪽 아래의 &lt;em&gt;Add Remote Device&lt;/em&gt;를 선택합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/81b/81bd0624ff3a890aa5e58528ba93ccca9a04a4a2537819b36352b76043861419.m.png&quot; alt=&quot;Add Remote Device를 선택합니다&quot;&gt;&lt;figcaption&gt;Add Remote Device를 선택합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;랩톱 office&lt;/em&gt;에서 복사한 ID를 &lt;em&gt;Device ID&lt;/em&gt;란에 입력하고, &lt;em&gt;Device Nane&lt;/em&gt;에는 &lt;em&gt;랩톱 office&lt;/em&gt;를 가리킬 이름을 넣습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/1d8/1d811563ee8e6f0d564338f2bf652ce52764ad548b901ef0b3b623d378fe8b66.m.png&quot; alt=&quot;디바이스 추가(Add Device)&quot;&gt;&lt;figcaption&gt;디바이스 추가(Add Device)&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;동기화할-디렉터리-추가하기&quot;&gt;동기화할 디렉터리 추가하기&lt;/h2&gt;
&lt;p&gt;이제 동기화할 디렉터리를 추가할 차례입니다. &lt;em&gt;Add Folder&lt;/em&gt; 버튼을 누릅니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/88a/88a3ed9a6f9f28c46345ed40ec3cbc29dda2847d5dfd5bbf7d27824df0b5764c.m.png&quot; alt=&quot;Add Folder 버튼을 누릅니다&quot;&gt;&lt;figcaption&gt;Add Folder 버튼을 누릅니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Folder Path&lt;/em&gt;에 동기화할 디렉터리의 절대 경로를 넣습니다. &lt;em&gt;Folder Label&lt;/em&gt;에는 설명 문구를 넣습니다. &lt;em&gt;Folder ID&lt;/em&gt;는 자동으로 생성됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/236/2364a44f9a14888095197530ab5a89dff9417367ed2edea1d8a663c064daf750.m.png&quot; alt=&quot;Add Folder 설정하기&quot;&gt;&lt;figcaption&gt;Add Folder 설정하기&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;디렉터리-동기화하기&quot;&gt;디렉터리 동기화하기&lt;/h3&gt;
&lt;p&gt;같은 창에서 &lt;em&gt;Sharing&lt;/em&gt; 탭을 열면 어떤 기기와 동기화할지를 선택할 수 있습니다. 동기화할 기기가 많다면 여러 대를 추가할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b27/b27b14936a748bc6d8ee7a68262da5b181f2f30bc4c676d5b762f63fb998ce9e.m.png&quot; alt=&quot;Share 탭의 설정&quot;&gt;&lt;figcaption&gt;Share 탭의 설정&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;동기화시-파일-버저닝하기&quot;&gt;동기화시 파일 버저닝하기&lt;/h3&gt;
&lt;p&gt;제겐 필요 없다고 생각해서 아직 사용하지 않는 기능이지만 소개해봅니다.&lt;/p&gt;
&lt;p&gt;파일의 바뀐 내용을 모두 추적하는 버저닝 기능을 사용할 수도 있습니다. &lt;em&gt;Simple File Versioning&lt;/em&gt;에서는 몇 단계 이전 버전까지 저장할지를 설정할 수 있고, &lt;em&gt;Staggered File Versioning&lt;/em&gt;에서는 파일을 저장할 최장 기간을 선택할 수 있습니다. &lt;em&gt;External File Versioning&lt;/em&gt;에서는 다른 도구를 사용해 버저닝을 할 수 있습니다. 자세한 설정법은 &lt;a href=&quot;https://docs.syncthing.net/users/versioning.html&quot;&gt;File Versioning&lt;/a&gt; 문서를 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;이전 버전 파일들은 기본으로 동기화할 디렉터리 루트의 &lt;code&gt;.stversions&lt;/code&gt; 디렉터리로 이동됩니다. (별도 지정할 수도 있습니다.)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/3cf/3cf3fbf7a878eec65b95cb278747e970776e74594a077c21a3d78014bb6af003.m.png&quot; alt=&quot;파일 버저닝 설정&quot;&gt;&lt;figcaption&gt;파일 버저닝 설정&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;동기화하지-않을-파일들을-걸러내기&quot;&gt;동기화하지 않을 파일들을 걸러내기&lt;/h3&gt;
&lt;p&gt;공유하려는 디렉터리 루트 위치에 &lt;code&gt;.stignore&lt;/code&gt; 파일을 만들면, 동기화하지 않을 파일을 패턴으로 지정할 수 있습니다. 다음을 보면 아시겠지만 &lt;code&gt;.stignore&lt;/code&gt; 파일의 패턴 규칙은 &lt;code&gt;.gitignore&lt;/code&gt;와 흡사합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(?d).DS_Store  # 맥OS에 생성되는 .DS_Store를 걸러냅니다
foo            # foo 디렉터리를 걸러냅니다
*2             # 2로 끝나는 이름의 디렉터리/파일을 걸러냅니다
qu*            # qu로 시작하는 이름의 디렉터리/파일을 걸러냅니다
(?i)my pictures   # 대소문자를 구별하지 않고 my pictures와 일치하는
                  # 디렉터리/파일을 걸러냅니다&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.stignore&lt;/code&gt; 파일을 수동으로 만들어도 되지만, GUI에서 만들 수도 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b13/b13358de2ec04b912fd10483afd24cb472e310763ac57508d9d55eebdbf7ae48.m.png&quot; alt=&quot;동기화 대상 디렉터리의 Edit -&amp;gt; Ignore Patterns에서도 .stignore 파일을 편집할 수 있습니다&quot;&gt;&lt;figcaption&gt;동기화 대상 디렉터리의 Edit -&amp;gt; Ignore Patterns에서도 .stignore 파일을 편집할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 외에 &lt;em&gt;Advanced&lt;/em&gt; 탭에서 동기화 방향(주고받기, 받기 전용, 보내기 전용) 등의 옵션도 설정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;설정이 끝나면 디렉터리가 동기화되기 시작합니다. 기본 속도는 네트워크가 제공하는 대역폭 만큼이며 &lt;em&gt;Settings -&amp;gt; Connections&lt;/em&gt;에서 속도를 제한할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;직장과 집의 네트워크 대역폭을 그대로 활용할 수 있고, 제외할 파일 패턴도 지정할 수 있어서 제 요구사항엔 아주 잘 맞는 도구였습니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Sun, 08 Sep 2019 23:34:56 +0000</pubDate>
      <dc:date>2019-09-08T23:34:56+00:00</dc:date>
    </item>
    <item>
      <title>아마존 오로라(Amazon Aurora), 글로벌 데이터베이스를 서울 리전에 출시</title>
      <link>https://www.44bits.io/ko/post/aws-aurora-launches-global-database-to-seoul-region</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        아마존 오로라, 글로벌 데이터베이스를 서울 리전에 출시
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;아마존-오로라-글로벌-데이터베이스-기능-서울-출시&quot;&gt;아마존 오로라 글로벌 데이터베이스 기능 서울 출시&lt;/h2&gt;
&lt;p&gt;아마존 오로라&lt;sup&gt;Amazon Aurora&lt;/sup&gt; 서비스의 글로벌 데이터베이스 기능이 서울 리전에도 출시되었습니다.&lt;/p&gt;
&lt;p&gt;아마존 오로라 서비스는 아마존 웹 서비스&lt;sup&gt;Amazon Web Service&lt;/sup&gt;에서 제공하는 데이터베이스 서비스 중 하나로 고성능과 가용성에 초점을 맞춘 MySQL, PostgreSQL 호환 데이터베이스입니다. 한 리전 내의 가용 영역&lt;sup&gt;Available Zone&lt;/sup&gt;마다 복제 서버를 두는 방식으로 가용성을 보장합니다. 2018년 AWS 리인벤트&lt;sup&gt;re:Invent&lt;/sup&gt;에서는 한 리전을 넘어 다른 리전에도 복제 서버를 만들 수 있는 ‘글로벌 데이터베이스’라는 기능을 선보였습니다. 2019년 5월 기준으로 ’글로벌 데이터베이스’ 기능은 MySQL 버전만 지원합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/66d/66dae7407e2ce31acc2e51d70ba03803b46f820e2c42ac401e3e173c7d5b0c64.m.png&quot; alt=&quot;글로벌 데이터베이스 기능의 도식*&quot;&gt;&lt;figcaption&gt;글로벌 데이터베이스 기능의 도식&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 도식 출처 &lt;a href=&quot;file:///Users/nacyot/Dropbox/hubtee/writings/sources/aws-aurora-launches-global-database-to-seoul-region.markdown.textbundle/builds/latest/assets/https://www.slideshare.net/AmazonWebServices/amazon-aurora-storage-demystified-how-it-all-works-dat363-aws-reinvent-2018&quot;&gt;Amazon Aurora Storage Demystified: How It All Works&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;아쉽게도 출시 당시에는 미국 버지니아, 미국 오하이오, 미국 오레곤, 아일랜드 리전만 지원했습니다. 지난 5월 9일 드디어 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/amazon-aurora-global-datagase-seoul-region/&quot;&gt;서울 리전에서도 ‘글로벌 데이터베이스’ 기능을 지원한다고 발표&lt;/a&gt;하였습니다.&lt;/p&gt;
&lt;p&gt;현재 ‘글로벌 데이터베이스’ 기능을 지원하는 리전은 모두 14개입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아메리카 - 버지니아, 오하이오, 캘리포니아 북부, 오레곤, 캐나다 중부&lt;/li&gt;
&lt;li&gt;아시아 - 뭄바이, 서울, 싱가포르, 시드니, 도쿄&lt;/li&gt;
&lt;li&gt;EU - 프랑크푸르트, 아일랜드, 런던, 파리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;‘글로벌 데이터베이스’ 기능의 가격은 리전마다 다르며, 리전간 I/O 백만 회당 $0.20 ~ $0.24입니다. 서울과 도쿄 리전이 $0.24로 가장 비싼 편입니다.&lt;/p&gt;
&lt;h2 id=&quot;함께-읽으면-좋은-글&quot;&gt;함께 읽으면 좋은 글&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://woowabros.github.io/study/2019/01/19/aws-global-database.html&quot;&gt;우아한형제들 기술블로그의 재해복구를 위한 오로라 데이터베이스 구성&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/amazon-aurora-global-datagase-seoul-region/&quot;&gt;Amazon Aurora - 글로벌 데이터베이스 서울 리전 출시&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Tue, 21 May 2019 00:09:56 +0000</pubDate>
      <dc:date>2019-05-21T00:09:56+00:00</dc:date>
    </item>
    <item>
      <title>만들면서 배우는 아마존 VPC(Amazon VPC) 입문: AWS 네트워크의 기초</title>
      <link>https://www.44bits.io/ko/post/understanding_aws_vpc</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        만들면서 배우는 아마존 버추얼 프라이빗 클라우드(Amazon VPC)
                &lt;div class=&quot;subtitle&quot;&gt;아마존 웹 서비스 네트워크의 기초&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;들어가며-아마존-vpc를-꼭-이해해야하나요&quot;&gt;들어가며: 아마존 VPC를 꼭 이해해야하나요?&lt;/h2&gt;
&lt;p&gt;아마존 웹서비스를 사용하다 보면 VPC나 서브넷과 같은 개념을 자주 접하게 됩니다. 하물며 AWS의 가장 기본이 되는 서비스인 EC2 인스턴스를 만들 때도 VPC와 서브넷을 지정해야합니다. 이러한 개념을 정확히 모르더라도 AWS를 사용하는 게 불가능한 것은 아닙니다. 그렇다면 VPC를 꼭 이해해야할까요? AWS를 충분히 활용하기 위해서는 그렇습니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 이 글은 아마존 웹 서비스를 사용해본 적이 있고, AWS 네트워크에 대해 좀 더 깊게 이해하고자 하는 분들을 위해 작성되었습니다. AWS를 사용해 프로덕션 배포 환경을 직접 구축하는 경우 아마존 VPC에 대한 이해는 필수적이지만, 아직 아마존 웹 서비스를 사용해본 적이 없거나 테스트를 위해 EC2, RDS 등 기본적인 서비스만 제한적으로 사용하는 경우 VPC는 나중에 살펴봐도 괜찮습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;아마존 웹 서비스&lt;sup&gt;Amazon Web Service&lt;/sup&gt;는 서버 호스팅 서비스가 아닌 클라우드 서비스로 분류됩니다. 클라우드 서비스에는 기존 서버 호스팅과 차별화된 중요한 특징들이 있습니다. 중요한 차이 중 하나가 바로 네트워크 환경을 직접 설계할 수 있다는 점입니다. 처음부터 이러한 차이가 부각 되었던 것은 아닙니다. 독립된 네트워크 환경을 구성할 수 있는 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/aws/amazon-vpc-far-more-than-everywhere/&quot;&gt;버추얼 프라이빗 클라우드&lt;sup&gt;VPC, Virtual Private Cloud&lt;/sup&gt;&lt;/a&gt;는 2011년 8월에 처음 릴리스 되었습니다. 현재는 AWS에서 제공되는 대부분의 서비스가 VPC에 의존적입니다. VPC를 의식하지 않고도 AWS를 사용할 수 있습니다만, 그 뒤에는 아마존 웹서비스에서 계정 생성 시 함께 생성되는 기본 VPC(Default VPC)가 있습니다.&lt;/p&gt;
&lt;p&gt;따라서 AWS의 서비스들을 제대로 이해하고 사용하기 위해서는 VPC에 대한 기본적인 이해는 필수적입니다. 이 글에서는 기본 VPC의 구성 요소들을 살펴보고 직접 만들어가면서 VPC를 배워보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;아마존-버추얼-프라이빗-클라우드amazon-vpc의-이해&quot;&gt;아마존 버추얼 프라이빗 클라우드(Amazon VPC)의 이해&lt;/h2&gt;
&lt;p&gt;VPC를 만들어 보기에 앞서 VPC가 무엇인지 이해해야 합니다. 아마존 VPC의 공식 웹페이지에서는 VPC를 다음과 같이 소개합니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;Amazon Virtual Private Cloud(VPC)를 사용하면 AWS 클라우드에서 논리적으로 격리된 공간을 프로비저닝하여 고객이 정의하는 가상 네트워크에서 AWS 리소스를 시작할 수 있습니다. IP 주소 범위 선택, 서브넷 생성, 라우팅 테이블 및 네트워크 게이트웨이 구성 등 가상 네트워킹 환경을 완벽하게 제어할 수 있습니다. VPC에서 IPv4와 IPv6를 모두 사용하여 리소스와 애플리케이션에 안전하고 쉽게 액세스할 수 있습니다. – &lt;a href=&quot;https://aws.amazon.com/ko/vpc/&quot;&gt;아마존 버추얼 프라이빗 클라우드(Amazon Virtual Private Cloud)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;이 소개에서 &lt;strong&gt;논리적으로 격리된 공간을 프로비저닝&lt;/strong&gt;한다는 내용에 주목해주세요. 아마존 웹 서비스는 기본적으로 다양한 고객들이 사용하는 공용 환경입니다. 사용자들은 이 환경 위에서 EC2 인스턴스와 RDS 데이터베이스를 비롯한 다양한 리소스들을 생성해서 사용합니다. 클라우드 위에서 생성한 리소스들은 기본적으로 네트워크를 통해서 접근합니다. 이 때 하나의 계정에서 생성하는 리소스들만의 격리된 네트워크를 만들어주는 기능이 바로 VPC입니다. VPC를 사용하면 특정 사용자의 리소스들이 논리적으로 격리된 네트워크에서 생성되기 때문에 다른 사람들은 접근하는 것은 물론 보는 것도 불가능합니다.&lt;/p&gt;
&lt;p&gt;2019년 현재 VPC는 모든 사용자에게 강제적으로 적용되어있습니다. 따라서 VPC 없이는 대부분의 서비스를 사용하는 것이 불가능합니다. 앞서 이야기했습니다만 아마존 VPC가 처음부터 강제적으로 적용되어있던 것은 아닙니다. 아마존 VPC가 정식 서비스로 릴리스 된 것은 2011년 8월입니다. 이 이전에는 EC2-클래식&lt;sup&gt;EC2 Classic&lt;/sup&gt; 네트워크 환경이 사용되었습니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;EC2-Classic 사용을 통해 다른 고객과 공유하는 단일 일반 네트워크에서 인스턴스가 실행됩니다. Amazon VPC 사용을 통해 AWS 계정에 속하도록 논리적으로 독립된 Virtual Private Cloud(VPC)에서 인스턴스가 실행됩니다. Amazon EC2의 최초 출시 당시 EC2-Classic 플랫폼이 도입되었습니다. 2013년 12월 4일 이후에 AWS 계정을 생성한 경우 EC2-Classic을 지원하지 않으니 VPC에서 Amazon EC2 인스턴스를 시작해야 합니다. 계정이 EC2-Classic을 지원하지 않는 경우 기본 VPC가 생성됩니다. 기본적으로 인스턴스를 시작할 때 이를 기본 VPC에 시작합니다. 또는 기본 VPC가 아닌 VPC를 생성하고 인스턴스를 시작할 때 이를 지정할 수 있습니다. – &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ec2-classic-platform.html&quot;&gt;Amazon EC2 네트워크 및 보안 EC2-Classic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;위의 내용에서 알 수 있듯이 EC2-클래식 네트워크 환경은 다른 사용자들과 함께 사용하는 공용 공간입니다. 과거에는 EC2-클래식과 EC2-VPC 네트워크 환경을 선택해서 사용할 수 있었습니다. 물론 아마존 VPC 출시 이전에는 EC2-클래식 네트워크 환경만 제공되었습니다.&lt;/p&gt;
&lt;p&gt;아마존 VPC가 릴리스 되고 2년이 지난 2013년 12월 4일 이후 생성된 AWS 계정에서는 EC2-Classic 네트워크 환경을 더 이상 사용할 수 없습니다. 따라서 더 이상 아마존 VPC는 선택사항이 아닙니다. 하지만 EC2 인스턴스 하나를 만들기 위해서 사용자가 직접 네트워크 환경을 직접 구축해야한다면 불편하고 복잡할 것입니다. 사용자가 직접 네트워크 환경을 설계할 수 있다는 것은 아주 큰 장점이지만, 바로 사용할 수 있는 기본 환경을 제공하는 것도 중요합니다. 따라서 AWS에서는 AWS 계정을 생성할 때 리전 별로 기본 VPC를 함께 생성해줍니다. 이 기본 VPC를 사용하면 아마존 VPC를 크게 의식하지 않더라도 EC2-클래식 네트워크를 사용하듯이 쉽게 AWS에서 제공하는 서비스들을 이용할 수 있습니다. 또한 기본 VPC를 사용하더라도 EC2-클래식과 달리 격리된 네트워크 환경의 장점을 누릴 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/53d/53dd4711502702c742f8aeb8380714ac11ef2a34f769d8da450f8b1b00cea0cc.m.png&quot; alt=&quot;ec2-classic과 VPC 네트워크의 차이&quot;&gt;&lt;figcaption&gt;ec2-classic과 VPC 네트워크의 차이&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;하지만 AWS 위에서 프로덕션 환경을 구축하기 위해서는 아마존 VPC에 대한 좀 더 깊은 이해를 필요로 합니다. 직접 VPC를 디자인하고 구축하진 않더라도 최소한 기본 VPC가 어떻게 구성되어있는 지만 이해하고 있더라도 큰 도움이 될 것입니다. 이 글의 최종 목표는 기본 VPC를 구성 요소들을 살펴보고, 마법사를 사용하지 않고 기본 VPC를 직접 만들어보는 일입니다.&lt;/p&gt;
&lt;h2 id=&quot;아마존-vpc는-언제-사용할까요&quot;&gt;아마존 VPC는 언제 사용할까요?&lt;/h2&gt;
&lt;p&gt;아마존 VPC는 언제 사용하는 걸까요? 아마존 웹 서비스를 사용하는 동안 거의 항상 사용하고 있습니다. 의식해본 적이 없을 수도 있습니다만 EC2 생성 과정의 한 장면을 같이 살펴보겠습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/5f9/5f9393cf1b0117480f3a0d827f29e564861abdbc5e6307ae059903007780d9c4.m.png&quot; alt=&quot;EC2 생성 과정. VPC와 서브넷을 지정해야합니다.&quot;&gt;&lt;figcaption&gt;EC2 생성 과정. VPC와 서브넷을 지정해야합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 화면의 중간 쯤에 &lt;em&gt;네트워크&lt;/em&gt;&lt;sup&gt;Network&lt;/sup&gt;라는 항목이 보입니다. 바로 이 네트워크 속성이 EC2 인스턴스를 실행할 VPC를 선택하는 항목입니다. VPC를 지정하지 않는 방법은 없습니다. 반드시 인스턴스가 속할 하나의 VPC를 지정해야만 합니다. 그 바로 아래의 서브넷도 VPC 리소스 중 하나입니다. 서브넷은 VPC에 속해있는 리소스이며, 하나의 인스턴스는 반드시 하나의 서브넷에 속해야합니다. 단, 기본값을 사용한다면 기본 VPC에서 인스턴스가 생성될 것입니다.&lt;/p&gt;
&lt;p&gt;EC2를 만들 때 VPC가 필요한 걸 확인했으니, 이번에는 RDS도 한 번 만들어보겠습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/83b/83bb448f38fb3dd7f7e6bc1cad80c69024e026e6435d3dedb0151ad3e5511c6f.m.png&quot; alt=&quot;RDS 생성 과정. 서브넷 그룹을 지정해야합니다.&quot;&gt;&lt;figcaption&gt;RDS 생성 과정. 서브넷 그룹을 지정해야합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;RDS를 만드는 과정 중 세 번째 단계에서 네트워크 설정을 하게 됩니다. 자세히 보시면 EC2의 네트워크 설정과 아주 비슷한 것을 알 수 있습니다. VPC와 서브넷을 선택해야합니다. 여기서 서브넷 그룹은 EC2의 설정 방식과는 조금 다릅니다만, 하나의 RDS 인스턴스가 하나의 서브넷에 속해야 한다는 것은 다르지 않습니다.&lt;/p&gt;
&lt;p&gt;서버리스 환경에서 함수를 실행해주는 AWS 람다&lt;sup&gt;AWS Lambda&lt;/sup&gt;는 어떨까요? 람다는 생성시에는 별도로 VPC 지정하는 항목이 없습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/522/522c40a20c286bb27ea807cde29750384bedfe3f1f31f22030d3c8f977904092.m.png&quot; alt=&quot;AWS 람다 생성 과정에서도 VPC를 지정할 수 있습니다.&quot;&gt;&lt;figcaption&gt;AWS 람다 생성 과정에서도 VPC를 지정할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;하지만 웹 콘솔에서 함수 생성 후 상세 화면을 확인해보면 네트워크를 선택할 수 있는 설정을 찾을 수 있습니다. 람다 함수는 VPC를 지정하지 않고도 실행할 수 있지만, 이 경우 VPC 내부에서만 접근 가능한 리소스를 사용할 수 없습니다. 네트워크 항목에서 특정 VPC를 지정하면, 해당 VPC에서 람다 함수가 실행되므로 같은 네트워크 환경에 있는 리소스를 사용할 수 있습니다. 어떤가요? VPC를 거의 항상 사용하고 있다는 의미가 조금 와닿으시나요.&lt;/p&gt;
&lt;p&gt;그럼 이제 본격적으로 VPC가 어디에 있는지 찾아보겠습니다. VPC는 중의적인 이름입니다. VPC 그 자체가 리소스의 이름입니다. 하지만 동시에 버추얼 프라이빗 클라우드(VPC)를 구축하기 위한 일체의 리소스를 제공하는 서비스의 이름이기도 합니다. 웹 콘솔 메뉴에서 VPC를 찾아보면 VPC 대시보드에 접속할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/abe/abecc3da82bcb28a9b0e868ddfe0f6cf1301317d51ad68d7c913857a0b259646.m.png&quot; alt=&quot;VPC 대시보드에서 관련 리소스들을 확인할 수 있습니다.&quot;&gt;&lt;figcaption&gt;VPC 대시보드에서 관련 리소스들을 확인할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;대시보드에 접속해보면 VPC와 관련된 리소스 목록이 무더기로 출력됩니다. 대시보드 메인에서 확인할 수 있는 리소스의 종류만 무려 17가지나 됩니다. 이 리소스들을 지금 당장 전부 이해해야하는 건 아닙니다. 그 중에서도 기초가 되는 기본 VPC를 구축하기 위한 리소스에 대해서 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;기본-vpc의-구성-요소들&quot;&gt;기본 VPC의 구성 요소들&lt;/h2&gt;
&lt;p&gt;계정을 처음 만들었을 때 하나의 리전에서 만들어지는 리소스들은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 VPC&lt;/li&gt;
&lt;li&gt;n 서브넷&lt;sup&gt;Subnet&lt;/sup&gt;(n은 사용할 수 있는 가용존의 개수)&lt;/li&gt;
&lt;li&gt;1 라우트 테이블&lt;sup&gt;Route Table&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 네트워크 ACL&lt;sup&gt;Network ACL&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 시큐리티 그룹&lt;sup&gt;Security Group&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 인터넷 게이트웨이&lt;sup&gt;Internet Gateway&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 DHCP 옵션셋&lt;sup&gt;DHCP options set&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 7개 리소스가 이게 전부입니다. VPC를 처음 시작할 때는 이 정도면 충분합니다. 공부해야할 리소스가 17개에서 7개로 줄어들었습니다. 그럼 하나씩 알아보도록 하겠습니다..&lt;/p&gt;
&lt;h3 id=&quot;vpc&quot;&gt;VPC&lt;/h3&gt;
&lt;p&gt;VPC는 프라이빗 클라우드를 만드는 데 가장 기본이 되는 리소스입니다. VPC는 논리적인 독립 네트워크를 구성하는 리소스입니다로 이름과 IPv4 CIDR 블록을 필수적으로 가집니다.&lt;/p&gt;
&lt;p&gt;CIDR 블록은 IP의 범위를 지정하는 방식입니다. CIDR 블록은 IP 주소와 슬래시(&lt;code&gt;/&lt;/code&gt;) 뒤에 따라오는 넷마스크 숫자로 구성되어있습니다. 이 숫자는 IP 범위를 나타냅니다. 이 숫자가 32이면 앞에 기술된 IP 정확히 하나를 가리킵니다. 예를 들어 &lt;code&gt;192.168.0.0/32&lt;/code&gt;는 &lt;code&gt;192.168.0.0&lt;/code&gt;을 가리킵니다. 범위는 지정된 IP부터 &lt;code&gt;2^(32-n)&lt;/code&gt;개가 됩니다. 예를 들어 뒤의 숫자가 24라면, &lt;code&gt;2^(32-24)=256&lt;/code&gt;개의 IP 주소를 의미합니다. 예를 들어 &lt;code&gt;192.168.0.0/24&lt;/code&gt;는 &lt;code&gt;192.168.0.0&lt;/code&gt;에서 &lt;code&gt;192.168.1.255&lt;/code&gt;까지의 IP를 의미합니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; CIDR를 정확하게 이해하기 위해서는 IP 주소의 2진수 표기와 서브넷 마스크와 같은 개념을 알아야합니다. 여기서는 이 정도만 알아둬도 큰 어려움은 없습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;클라우드에서 생성하는 자원들은 기본적으로 특정 네트워크 위에서 생성되며 이에 접근하기 위한 프라이빗 IP를 가집니다. 이 리소스들은 특정한 VPC 위에서 만들어집니다. 따라서 VPC의 CIDR 범위 안에서 적절한 IP를 할당 받게 됩니다. 예를 들어서 &lt;code&gt;192.168.0.0/24&lt;/code&gt; CIDR 블록을 가진 VPC에서 생성한 EC2 인스턴스는 &lt;code&gt;192.168.0.127&lt;/code&gt;이라는 IP를 할당 받을 수 있습니다. VPC의 범위 내에서 할당 가능한 IP가 모두 할당되면 더 이상 리소스를 만들 수 없습니다. 따라서 적절한 크기의 VPC를 만들어야합니다. 하나의 VPC의 최대 크기는 16입니다. 이 경우 &lt;code&gt;2^(32-16)=65536&lt;/code&gt;개의 IP를 사용할 수 있습니다. 이보다 큰 VPC는 생성할 수 없습니다.&lt;/p&gt;
&lt;p&gt;VPC를 만들 때 또 하나 고려해야할 점이 있습니다. CIDR의 범위를 지정하는데 특별한 제약은 없습니다만, 인터넷과 연결되어 있는 경우 문제가 발생할 수 있습니다. 예를 들어 &lt;code&gt;52.12.0.0/16&lt;/code&gt;을 CIDR 블록으로 지정한 경우를 생각해보겠습니다. 이 VPC에서 &lt;code&gt;52.12.0.0/16&lt;/code&gt;로 접속하는 트래픽은 VPC 내부로 라우트 됩니다. 그런데 이 범위의 IP는 인터넷에서 사용할 수 있는 IP입니다. 따라서 이 VPC에서는 &lt;code&gt;52.12.0.0/16&lt;/code&gt;에 속한 인터넷 IP에 접근하는 것이 원천적으로 불가능합니다. 인터넷 연결이 필요한 경우 반드시 사설망 대역을 사용해야 하며, 인터넷 연결이 필요하지 않더라도 가능하면 사설망 대역을 사용하는 것을 권장합니다. 사설망 대역은 &lt;code&gt;10.0.0.0/8&lt;/code&gt;, &lt;code&gt;172.16.0.0/12&lt;/code&gt;, &lt;code&gt;192.168.0.0/16&lt;/code&gt;가 있습니다.&lt;/p&gt;
&lt;p&gt;VPC는 독립된 네트워크 환경으로 구성되기 때문에 CIDR이 같거나 겹치더라도 생성하는 것이 가능합니다. 하지만 추후에 다수의 VPC를 함께 사용하는 경우 IP 대역이 겹치면 문제가 발생할 수 있습니다. VPC를 만드는 것은 쉽습니다만 한 번 만들고 나면 기존 CIDR을 변경하는 것은 불가능합니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 문제가 생겨서 VPC 내부의 모든 자원을 이동하는 건 매우 힘든 일입니다. 따라서 프로덕션 환경을 구축할 때는 VPC 제약사항들을 충분히 이해하고 CIDR을 정하는 것이 좋습니다. 기본 VPC의 CIDR 블록은 &lt;code&gt;172.31.0.0/16&lt;/code&gt;입니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 기존 CIDR을 변경하는 것은 불가능하지만, 2017년 8월부터는 이미 만들어져있는 VPC에 새로운 CIDR을 추가할 수 있습니다. 자세한 내용은 &lt;a href=&quot;&quot;&gt;관련 공지&lt;/a&gt;를 확인해주세요.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;서브넷subnet&quot;&gt;서브넷(Subnet)&lt;/h3&gt;
&lt;p&gt;VPC만 가지고는 아직 아무것도 할 수 없습니다. VPC는 다시 한 번 CIDR 블록을 가지는 단위로 나눠집니다. 서브넷은 실제로 리소스가 생성되는 물리적인 공간인 가용존&lt;sup&gt;Available Zone&lt;/sup&gt;과 연결됩니다. VPC가 논리적인 범위를 의미한다면, 서브넷은 VPC 안에서 실제로 리소스가 생성될 수 있는 네트워크라고 생각할 수 있습니다. 다른 서비스의 리소스를 생성할 때 VPC만 지정하는 경우는 없습니다. VPC와 서브넷을 모두 지정하거나 서브넷을 지정하면 VPC는 자동적으로 유추되기도 합니다.&lt;/p&gt;
&lt;p&gt;하나의 VPC는 N개의 서브넷을 가질 수 있습니다. 서브넷의 최대 크기는 VPC의 크기와 같습니다. VPC와 동일한 크기의 서브넷을 하나만 만드는 것도 가능합니다. 서브넷을 만들지 않을 수도 있지만, 이 경우 VPC로 아무것도 할 수 없습니다. 일반적으로 사용할 수 있는 가용존을 고려해서 적절한 크기의 서브넷들을 가용존 수만큼 생성해서 사용합니다. N가용존만큼 서브넷을 만들어 리소스를 분산하면 재해 대응 측면에서도 유리합니다.&lt;/p&gt;
&lt;p&gt;서브넷의 넷마스크 범위는 16(65535개)에서 28(16개)을 사용할 수 있으며, VPC CIDR 블럭 범위에 속하는 CIDR 블럭을 지정할 수 있습니다. 하나의 서브넷은 하나의 가용존과 연결 됩니다. 리전에 따라서 사용가능한 가용존의 갯수는 다릅니다. 따라서 재해 대응을 위해 가용존만큼 서브넷을 나누는 경우 특정 리전에서 사용가능한 가용존의 갯수를 미리 확인할 필요가 있습니다. 모든 가용존을 사용하지 않더라도 2개 이상의 가용존을 사용하는 게 일반적입니다. 기본 VPC에서는 가용존 갯수만큼 넷마스크 20의 서브넷들을 자동적으로 생성합니다.&lt;/p&gt;
&lt;h3 id=&quot;라우트-테이블route-table&quot;&gt;라우트 테이블(Route Table)&lt;/h3&gt;
&lt;p&gt;라우트 테이블은 서브넷과 연결되어있는 리소스입니다. 서브넷에서 네트워크를 이용할 때는 이 라우트 테이블을 사용해서 목적지를 찾게 됩니다. 라우트 테이블은 서브넷과 연결되어있지만 VPC를 생성할 때 만들어지고 VPC에도 연결되어 있습니다. 이 라우트 테이블은 VPC에 속한 서브넷을 만들 때 기본 라우트 테이블로 사용됩니다.&lt;/p&gt;
&lt;p&gt;하나의 라우트 테이블은 VPC에 속한 다수의 서브넷에서 사용할 수 있습니다. 자동 생성되는 라우트 테이블에는 한 가지 룰만이 정의되어있습니다. VPC의 CIDR 블럭을 목적지로 하는 경우 타깃이 local인 규칙입니다. 예를 들어 VPC의 CIDR 블럭이 &lt;code&gt;172.31.0.0/16&lt;/code&gt;일 때 이 네트워크 안에서 목적지가 &lt;code&gt;172.31.0.0/16&lt;/code&gt; 범위에 있는 리소스를 찾는다면 VPC 내부에서 찾습니다. 이 규칙은 삭제할 수 없습니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 인터넷을 연결하거나 다른 VPC와 통신하기 위해서는 라우트 테이블에 라우트 규칙을 추가적으로 정의해야만 합니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 앞서 VPC 절에서는 VPC를 디자인할 때 주의해야할 내용들에 대해서 소개했습니다. 예를 들어 사설망의 CIDR 블럭을 사용해야하는 이유는, 라우트 테이블의 기본 규칙이 VPC의 CIDR 블럭에 의해 점유되기 때문입니다. 따라서 사설망이 아닌 CIDR을 사용하면 인터넷과 연결하는 라우트 규칙을 정의하더라도 통신할 수 없게됩니다. 또한 비슷한 이유로 사설망에 해당하는 CIDR 블럭을 사용하더라도, 다른 VPC와 통신할 때 CIDR이 겹치는 부분과는 통신할 수 없습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;인터넷-게이트웨이internet-gateway&quot;&gt;인터넷 게이트웨이(Internet Gateway)&lt;/h3&gt;
&lt;p&gt;VPC는 기본적으로 격리되 네트워크 환경입니다. 따라서 VPC에서 생성된 리소스들은 기본적으로 인터넷을 사용할 수가 없습니다. 인터넷에 연결하기 위해서는 인터넷 게이트웨이가 필요합니다. 라우팅 테이블에 인터넷 게이트웨이를 향하는 적절한 규칙을 추가해주면 특정 서브넷이 인터넷과 연결됩니다. 하지만 서브넷과 인터넷 게이트웨이를 연결하는 것만으로는 인터넷을 사용할 수 없습니다. 인터넷을 사용하고자 하는 리소스는 퍼블릭 IP를 가지고 있어야합니다.&lt;/p&gt;
&lt;h3 id=&quot;dhcp-옵션셋dhcp-options-set&quot;&gt;DHCP 옵션셋(DHCP options set)&lt;/h3&gt;
&lt;p&gt;DHCP 옵션셋은 TCP/IP 네트워크 상의 호스트로 설정 정보를 전달하는 DHCP 표준입니다. 이 기능을 사용하면 도메인 네임 서버, 도메인 네임, NTP 서버, NetBIOS 서버 등의 정보를 설정할 수 있습니다. 일반적으로 VPC 생성 시 만들어지는 DHCP 옵션셋을 그대로 사용합니다.&lt;/p&gt;
&lt;h3 id=&quot;네트워크-aclnetwork-acl-시큐리티-그룹security-group&quot;&gt;네트워크 ACL(Network ACL) / 시큐리티 그룹(Security Group)&lt;/h3&gt;
&lt;p&gt;네트워크 ACL은 주고(outbound) 받는(inbound) 트래픽을 제어하는 가상 방화벽입니다. 하나의 네트워크 ACL은 다수의 서브넷에서 재사용할 수 있습니다. EC2 인스턴스를 사용해보았다면 ACL보다는 시큐리티 그룹에 익숙할 것입니다. 시큐리티 그룹은 인스턴스의 앞단에서 트래픽을 제어하는 가상 방화벽인 반면, 네트워크 ACL은 서브넷 앞단에서 트래픽을 제어하는 역할을 합니다. 따라서 네트워크 ACL의 규칙을 통과하더라도 시큐리티 그룹의 규칙을 통과하지 못 하면 인스턴스와는 통신하지 못 할 수 있습니다. 이 두 가지 리소스를 통해서 안전한 네트워크 환경을 구축할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;첫-번째-스텝-vpc-생성하기&quot;&gt;첫 번째 스텝: VPC 생성하기&lt;/h2&gt;
&lt;p&gt;여기까지 VPC의 개념에 대해서 알아보았으니 이제 실제로 VPC를 만들어보도록하겠습니다.&lt;/p&gt;
&lt;p&gt;이 예제에서는 버지니아(us-east-1) 리전에서 VPC를 생성해보겠습니다. VPC 대시보드에서 VPC 목록&lt;sup&gt;Your VPCs&lt;/sup&gt;으로 들어갑니다. VPC 목록에는 버지니아 리전에 생성되어있는 기본 VPC가 나타납니다만, 여기서는 기본 VPC를 삭제해둔 상태입니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 기본 VPC가 필요한 상황에서 실수로 삭제해버렸다면 문제가 될 수 있습니다. 이럴 경우 아마존 지원 센터&lt;sup&gt;Support Center&lt;/sup&gt;에 문의하면 기본 VPC를 복구해줍니다. 기본 VPC는 기본 VPC라는 특별한 표식이 딸려있기는 합니다만, 사실 직접 VPC를 구성한다고 해서 다른 점이 있는 것은 아닙니다. 따라서 VPC의 구성 원리를 이해한다면 VPC가 지워진다고 걱정할 필요는 없습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/356/356e680fb5c0250b469f6e56351b1e863548bdfc5e0556cfcb08651ed0e64735.m.png&quot; alt=&quot;VPC 목록&quot;&gt;&lt;figcaption&gt;VPC 목록&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;오른쪽 위에서 VPC 만들기&lt;sup&gt;Create VPC&lt;/sup&gt; 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/f28/f28d1b1913db3aaa652f12669faacc05da1df16bc5bd9a8e887d54c45004ba83.m.png&quot; alt=&quot;VPC 생성 과정&quot;&gt;&lt;figcaption&gt;VPC 생성 과정&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC를 생성할 때 지정해야할 값은 4가지가 있습니다. 이름 태그&lt;sup&gt;Name tag&lt;/sup&gt;는 중요하지만 선택사항입니다. 필수적으로 입력해야하는 값은 IPv4 CIDR 블록 하나 뿐입니다. 이 값을 지정할 때는 특별한 이유가 없다면 반드시 사설망 대역 범위 내에서 지정하시기 바랍니다. 사설망 대역으로는 &lt;code&gt;10.0.0.0/8&lt;/code&gt;, &lt;code&gt;172.16.0.0/12&lt;/code&gt;, &lt;code&gt;192.168.0.0/16&lt;/code&gt;가 있습니다. 여기서는 이름 태그를 &lt;code&gt;New Default&lt;/code&gt;, IPv4 CIDR 블록을 &lt;code&gt;10.0.10.0/16&lt;/code&gt;으로 지정하겠습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/002/0024030b547d6e0c068f54fb221c336f85f7b32ebd3860e3e66c677e95edd262.m.png&quot; alt=&quot;New Default VPC가 생성된 것을 확인할 수 있습니다.&quot;&gt;&lt;figcaption&gt;New Default VPC가 생성된 것을 확인할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC가 정상적으로 생성된 것을 확인할 수 있습니다. VPC를 만드는 건 이걸로 끝입니다. 한 가지 확인해야하는 점은 DNS 관련 설정값입니다. 기본 VPC는 DNS 해석&lt;sup&gt;DNS Resolution&lt;/sup&gt; 기능과 DNS 호스트네임&lt;sup&gt;DNS hostnames&lt;/sup&gt;이 모두 활성화 되어있습니다. DNS 해석 기능은 DNS 호스트네임을 IP로 해석할 때 AWS에서 제공하는 DNS 서버를 사용하는 기능입니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;&lt;em&gt;&lt;/em&gt;&lt;/span&gt; 이 기능은 새로 만든 VPC에서도 기본적으로 활성화되어있습니다. DNS 호스트네임은 VPC 내부에서 생성되는 인스턴스에 퍼블릭 DNS 호스트네임을 할당해주는 기능입니다. 이 기능인 DNS 해석과 달리 기본적으로 비활성화되어있습니다. VPC를 선택하고 오른쪽 위의 액션&lt;em&gt;&lt;sup&gt;Actions&lt;/sup&gt;, &lt;/em&gt;DNS 호스트네임 수정*&lt;sup&gt;Edit DNS Hostnames&lt;/sup&gt; 메뉴를 선택해 이 기능을 활성화해줍니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 작년 11월에는 AWS 서울 리전에서 대규모 장애가 발생했던 적이 있습니다. 이 장애의 원인이 바로 AWS 내부 DNS 서버였다고 합니다. 자세한 내용은 당시 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/follow-up-to-the-november-22-event-in-aws-seoul-region/&quot;&gt;AWS의 장애 공지&lt;/a&gt;를 확인해보시기 바랍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/292/292e2ddb8009c57e8b5ddbe247c9a2c02d8fc7b1f91a7cef4948b2d0ccee045c.m.png&quot; alt=&quot;DNS 호스트네임 옵션을 활성화합니다.&quot;&gt;&lt;figcaption&gt;DNS 호스트네임 옵션을 활성화합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC를 시작하는 것은 생각만큼 만만치 않습니다만, VPC를 직접 만드는 건 허무할만큼 쉽습니다. 하지만 앞서 이야기했듯이 VPC만으로는 아무것도 할 수가 없습니다. 이제 서브넷을 만들어야합니다. 그 전에 VPC와 함께 만들어진 자원들을 하나씩 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;VPC와 함께 이 VPC에서 기본으로 사용될 라우트 테이블이 함께 만들어집니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/4c5/4c5260076d9074b01304a09ddca5686df8aedb131705496adedb7fb460ba3953.m.png&quot; alt=&quot;VPC와 함께 생성된 라우팅 테이블&quot;&gt;&lt;figcaption&gt;VPC와 함께 생성된 라우팅 테이블&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 라우트 테이블은 실제로는 서브넷과 연결됩니다. 하지만 VPC에도 연결이 되어있는데, 여기에 연결된 라우트 테이블이 VPC에 속한 서브넷을 생성할 때 서브넷과 자동으로 연결됩니다. 앞서 설명했듯이 라우트 테이블은 기본적으로 하나의 룰을 가지고 있습니다. 이 룰은 VPC 내부에서 VPC 내부의 다른 자원을 찾을 때 사용하는 규칙입니다.&lt;/p&gt;
&lt;p&gt;VPC와 함께 만들어지는 리소스는 하나가 더 있습니다. 바로 &lt;em&gt;DHCP 옵션 셋&lt;/em&gt;&lt;sup&gt;DHCP Options Sets&lt;/sup&gt;입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/f71/f71b32ce3f6b16c99b786befbd0b4555777db24b1869bcebe1875e7844145cd0.m.png&quot; alt=&quot;VPC와 함께 생성된 DHCP 옵션 셋&quot;&gt;&lt;figcaption&gt;VPC와 함께 생성된 DHCP 옵션 셋&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;DHCP 옵션 셋은 도메인 네임 서버, 도메인 네임, NTP 서버, NetBIOS 서버 등의 정보를 가지고 있습니다. 일반적으로는 기본값을 그대로 사용합니다.&lt;/p&gt;
&lt;p&gt;VPC의 보안을 담당하는 ACL과 시큐리티 그룹&lt;sup&gt;Security Group&lt;/sup&gt; 리소스도 생성됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/4c6/4c67e73a2dc44debe53cb2654e0c637ce35ef7670b1dca2911274bccabddf7f1.m.png&quot; alt=&quot;VPC와 함께 ACL&quot;&gt;&lt;figcaption&gt;VPC와 함께 ACL&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;ACL은 서브넷의 앞단에서 방화벽 역할을 하는 리소스입니다. ACL에는 인바운드와 아운바운드 규칙이 따로 있습니다. VPC와 함께 생성되는 ACL에는 인바운드와 아웃바운드 규칙 각각 2개의 규칙을 가지고 있습니다. 규칙의 번호는 우선 순위를 나타냅니다. 번호가 &lt;code&gt;*&lt;/code&gt;인 규칙은 다른 어떤 룰에도 매치하지 않을 경우 사용하는 기본 규칙입니다. 이미지에서 확인할 수 있듯이 기본 규칙은 모든 트래픽을 차단&lt;sup&gt;Deny&lt;/sup&gt;합니다. 하지만 이 ACL에서는 기본 규칙이 사용되지 않습니다. 왜냐하면 100번 규칙에서 모든 트래픽을 허용&lt;sup&gt;Allow&lt;/sup&gt;하고 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;마지막 하나는 인스턴스 앞단에서 방화벽 역할을 하는 시큐리티 그룹입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/843/843c21c514303b44c944d46ebd5eba166a7c7b3a816f9a7faaef7f8562ffe344.m.png&quot; alt=&quot;VPC와 함께 생성된 시큐리티 그룹&quot;&gt;&lt;figcaption&gt;VPC와 함께 생성된 시큐리티 그룹&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;ACL이 서브넷의 트래픽을 제어한다면 시큐리티 그룹은 인스턴스의 트래픽을 제어합니다. VPC를 만들 때 생성되는 시큐리티 그룹은 VPC 내부의 통신을 허용하기 위한 특별한 규칙을 가지고 있습니다. 먼저 이 시큐리티 그룹의 아웃바운드 규칙은 모든 트래픽에 대해서 허용되어있습니다. 반면에 인바운트 규칙이 흥미롭습니다. 트래픽을 제어하는 규칙의 소스&lt;sup&gt;Source&lt;/sup&gt;에는 일반적으로 CIDR을 지정합니다. 흥미로운 건 CIDR 대신 시큐리티 그룹의 ID를 지정하면, 해당하는 시큐리티 그룹을 가진 리소스에 대해서만 트래픽을 하용하는 것이 가능합니다. 더 흥미로운 점은 기본 시큐리티 그룹에 유일한 인바운드 규칙의 소스가 바로 시큐리티 그룹 자기 자신의 ID라는 점입니다. 얼핏 이상해보입니다만, 이 규칙들을 가진 인스턴스들 간에 트래픽을 허용하기 위한 용도로 사용됩니다. 따라서 VPC 내부의 리소스들 간에 통신을 허용하기 위해서는 각각의 리소스들이 모두 이 시큐리티 그룹을 사용해야합니다.&lt;/p&gt;
&lt;p&gt;여기까지 VPC를 만들고, VPC와 함께 만들어지는 리소스들에 대해서 살펴보았습니다. 앞서 이야기했듯이 기본 VPC에는 7개의 리소스가 있습니다. 그런데 VPC 하나를 만들었을 뿐인데 VPC, 라우트 테이블, DHCP 옵션셋, 네트워크 ACL, 시큐리티 그룹 이렇게 5개의 리소스가 만들어졌습니다. 이제 남은 것은 서브넷과 인터넷 게이트웨이입니다.&lt;/p&gt;
&lt;h2 id=&quot;두-번째-스텝-서브넷-만들기&quot;&gt;두 번째 스텝: 서브넷 만들기&lt;/h2&gt;
&lt;p&gt;VPC는 논리적인 구획을 나눠줄 뿐이기 때문에 이것만으로는 아무것도 할 수 없습니다. 구체적인 예를 들어본다면 VPC 위에 직접 EC2 인스턴스를 만들 수는 없습니다. 이러한 리소스들은 VPC가 아닌 VPC 안에서 가용존과 연결된 서브넷 위에 만들어집니다. 따라서 앞서 만든 VPC에 속한 서브넷을 만들어야합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/29b/29b9469d5bbaf91f9a7d03c9cc3d7d9fabdc892d093ef1d6faef6ac292255423.m.png&quot; alt=&quot;서브넷 목록&quot;&gt;&lt;figcaption&gt;서브넷 목록&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC 대시보드에서 &lt;em&gt;서브넷 목록&lt;/em&gt;&lt;sup&gt;Subnets&lt;/sup&gt; 메뉴에 들어갑니다. 아직은 아무런 서브넷이 없습니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;&lt;em&gt;&lt;/em&gt;&lt;/span&gt; 서브넷 생성*&lt;sup&gt;Create subnet&lt;/sup&gt; 버튼을 클릭합니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 기본 VPC가 있다면 기본 VPC에 속한 서브넷이 존재할 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/6c3/6c37e9140d9f1c1442fa01eef158601d7336dad991feb841bd196dad6346a310.m.png&quot; alt=&quot;서브넷 생성 과정&quot;&gt;&lt;figcaption&gt;서브넷 생성 과정&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;CIDR과 서브넷 개념을 이해한다면, VPC를 만드는 것만큼이나 서브넷을 만드는 것도 간단합니다. &lt;em&gt;이름 태그&lt;/em&gt;&lt;sup&gt;Name tag&lt;/sup&gt;는 VPC와 마찬가지로 옵션입니다. VPC는 앞서 생성한 VPC ID를 찾아서 선택합니다. 다음은 &lt;em&gt;가용존&lt;/em&gt;&lt;sup&gt;Available Zone&lt;/sup&gt;을 지정합니다. 버지니아 리전의 가용존은 a부터 f까지 총 6개가 있습니다. &lt;em&gt;선호 없음&lt;/em&gt;&lt;sup&gt;No preference&lt;/sup&gt;을 지정하면 이 중에 하나가 자동적으로 선택됩니다. 여기서는 &lt;code&gt;us-east-1a&lt;/code&gt;를 선택합니다. VPC의 CIDR이 나오고 이 범위에서 이보다 작은 CIDR 블럭을 지정해주어야합니다. CIDR 블럭은 위에 출력되는 VPC의 CIDR 블럭 범위 내에서 이보다 작은 범위를 지정해야합니다. 현재 VPC의 IP 범위는 10.10.0.0부터 10.10.255.255까지입니다. 이 서브넷의 IP 범위는 10.10.0.0부터 10.10.0.255까지 사용하겠습니다. CIDR 블럭 표현법으로는 10.10.0.0/24입니다. &lt;em&gt;생성&lt;/em&gt;&lt;sup&gt;Create&lt;/sup&gt;을 클릭하면 서브넷이 만들어집니다.&lt;/p&gt;
&lt;p&gt;같은 방법으로 가용존 us-east-1b, CIDR 블럭 10.10.1.0/24을 가진 서브넷을 하나 더 만듭니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/597/5972337852a8036d8048f46afc7e61c9acb78da0418676cfdaf6742d656ecac4.m.png&quot; alt=&quot;새롭게 생성한 서브넷들을 목록에서 확인할 수 있습니다.&quot;&gt;&lt;figcaption&gt;새롭게 생성한 서브넷들을 목록에서 확인할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;서브넷 목록에서 2개의 서브넷이 만들어진 것을 확인할 수 있습니다. 서브넷의 상세 내용을 확인해보면 앞서 VPC와 함께 만들어진 네트워크 ACL과 라우트 테이블이 함께 지정되어있는 것을 확인할 수 있습니다. 이 리소스들에 대해서는 첫 번재 이터레이션에서 간략히 살펴보았습니다.&lt;/p&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;div class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;
노트
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;
왜 서브넷을 2개 만드나요?
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 예제에서는 서브넷을 2개 만들었습니다. 서브넷을 2개 만드는 게 의아하게 느껴질 수도 있습니다. 가용존 하나와 연결된 하나의 서브넷만 있더라도 EC2 인스턴스를 생성하는 것은 가능합니다. 하지만 EC2를 비롯한 많은 AWS의 서비스에서는 멀티AZ라는 개념을 지원하고 있습니다. 이는 하나 이상의 가용존에 유사한 리소스를 동시에 배치하는 기능입니다.&lt;/p&gt;
&lt;p&gt;이렇게 하는 이유는 장애 대응과 관련이 있습니다. 하나의 리전에는 다수의 가용존들이 있습니다. 이 가용존은 단순히 가상적으로 분리되어있는 것이 아니고, 물리적인 공간도 분리되어있습니다. 따라서 다수의 가용존에 유사한 리소스를 배치함으로써 하나의 가용존에 문제가 생기더라도 서비스에 장애가 발생하지 않도록 설계하는 것이 가능합니다. AWS에서는 리전 당 2개 이상의 가용존을 제공하며, 2개 이상의 가용존(서브넷)을 전제로 네트워크를 설계하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;서브넷을 만든다고 추가 비용이 발생하는 것은 아니므로, 여기서도 2개를 만들었습니다. 기존 VPC에 속한 서브넷 역시 리전에서 제공하는 가용존 수만큼 생성되어있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;이제 이 서브넷 위에 EC2 인스턴스를 생성할 수 있습니다. EC2 대시보드로 이동해서 EC2 인스턴스를 직접 만들어보겠습니다. 인스턴스 목록&lt;sup&gt;Instances&lt;/sup&gt;에서 인스턴스 생성&lt;sup&gt;Launch Instance&lt;/sup&gt; 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/0fc/0fcaf7a6370a9dc1472f1cfcf1299698292c4d2e152bae37221c750c3c6dae4c.m.png&quot; alt=&quot;EC2 인스턴스 목록&quot;&gt;&lt;figcaption&gt;EC2 인스턴스 목록&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;인스턴스 생성 과정은 간략히 설명하도록 하겠습니다. 인스턴스 생성 과정은 총 7단계에 걸쳐서 이루어집니다. 첫 번째 단계에서는 Amazon Linux AMI를 선택합니다. 두 번째 단계에서는 인스턴스 타입을 선택합니다. t2.nano나 프리티어가 적용되는 t2.micro를 선택합니다. 세 번째 단계에서는 인스턴스의 세부 사항들을 선택합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/922/922e06b010aea8d7ee71cd1a9cdfe2ec41b7491f0e7be26babc94813ed468e89.m.png&quot; alt=&quot;새롭게 만든 VPC와 서브넷을 지정합니다.&quot;&gt;&lt;figcaption&gt;새롭게 만든 VPC와 서브넷을 지정합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC는 바로 이 단계에서 설정합니다. 네트워크&lt;sup&gt;Network&lt;/sup&gt;에서 앞서 만든 VPC를 지정하고, 서브넷은 아무거나 하나를 선택합니다. 이 인스턴스에 외부에서 접속을 하려면 퍼블릭 아이피를 할당할 필요가 있습니다. 따라서 퍼블릭 IP 자동할당&lt;sup&gt;Auto-assign Public IP&lt;/sup&gt;을 활성&lt;sup&gt;Enable&lt;/sup&gt;로 지정합니다. 4, 5 기본값을 사용합니다. 6단계 역시 기본값을 사용합니다. 이 단계에서 기본값을 사용하면 22번 포트를 허용하는 시큐리티 그룹을 임시로 생성합니다. 7단계에서는 리뷰를 하고 인스턴스를 생성합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/bb2/bb291928331343b0ad17262185736131906e331558a296d1bcd404a09d2f20c7.m.png&quot; alt=&quot;EC2 인스턴스 생성: 키 페어 설정 화면&quot;&gt;&lt;figcaption&gt;EC2 인스턴스 생성: 키 페어 설정 화면&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;생성&lt;sup&gt;Launch&lt;/sup&gt; 버튼을 클릭하면 마지막으로 SSH 키를 설정하는 단계가 진행됩니다. 이미 AWS에 등록된 키가 있는 경우 이를 사용합니다. 없는 경우 새로운 키 페어 생성&lt;sup&gt;Create a new key pair&lt;/sup&gt;을 선택하고 키 페어를 다운로드 받아둡니다. 인스턴스 생성&lt;sup&gt;Launch Instances&lt;/sup&gt; 버튼을 클릭하면 인스턴스가 생성됩니다.&lt;/p&gt;
&lt;p&gt;지금 생성한 인스턴스의 상세 정보 화면에서 할당된 퍼블릭 IP를 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/25c/25c8ffa843db75bb847c0d8e87ea7ccce1cdf928b53e6c239bdb6050ea61aaed.m.png&quot; alt=&quot;인스턴스가 생성된 것을 확인할 수 있습니다.&quot;&gt;&lt;figcaption&gt;인스턴스가 생성된 것을 확인할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;AWS에서 인스턴스를 만들어보았다면 보통 이렇게 인스턴스를 생성하면 SSH에 접속이 가능해야합니다. 접속이 가능한 지 확인해보기 위해서 텔넷 명령어로 이 아이피의 22번 포트에 접속해봅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ telnet 54.175.41.41 22
Trying 54.175.41.41...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아무런 응답이 오지 않습니다. 시간이 지나도 계속 응답이 오지 않을 것입니다. EC2 인스턴스에 외부에서 접속하기 위해서는 이 인스턴스에서 인터넷 액세스가 활성화되어있어야합니다. 이 조건에 대해서는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Internet_Gateway.html&quot;&gt;아마존 공식 문서&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;VPC 서브넷의 인스턴스에 대한 인터넷 액세스를 활성화하려면 다음을 수행해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VPC에 인터넷 게이트웨이를 연결합니다.&lt;/li&gt;
&lt;li&gt;서브넷의 라우팅 테이블이 인터넷 게이트웨이를 가리키는지 확인합니다.&lt;/li&gt;
&lt;li&gt;서브넷의 인스턴스에 전역적으로 고유한 IP 주소(퍼블릭 IPv4 주소, 탄력적 IP 주소 또는 IPv6 주소)가 있는지 확인합니다.&lt;/li&gt;
&lt;li&gt;네트워크 액세스 제어 및 보안 그룹 규칙에서 적절한 트래픽이 인스턴스로, 그리고 인스턴스에서 흐르도록 허용되는지 확인합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;네 가지 조건을 모두 만족해야만 인스턴스에서 인터넷 액세스가 가능하고, 거꾸로 외부에서 SSH에 접속하는 것도 가능해집니다. 먼저 마지막 조건부터 살펴보겠습니다. ACL(네트워크 액세스 제어)의 경우 모든 연결을 허용하고 있기 때문에 조건이 충족되어있습니다. 또한 시큐리티 그룹(보안 그룹) 역시 인스턴스 생성시 만들어지는 시큐리티 그룹에서 22번 포트를 허용하고 있습니다. 3번째 조건은 퍼블릭 IP할당을 이야기합니다. 인스턴스 생성시에 퍼블릭 IP 자동 할당을 활성화했으므로 이 조건 역시 충족합니다.&lt;/p&gt;
&lt;p&gt;문제는 첫 번째와 두 번째 조건입니다. VPC와 서브넷을 만들었지만 아직 인터넷 게이트웨이를 만들거나 라우트 테이블에서 연결한 적은 없습니다. 따라서 외부에서 SSH로 접속하는 것도 불가능한 상황입니다. 다음 단계에서는 인터넷 게이트웨이를 만들고, SSH를 통해 이 인스턴스에 접속해보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;세-번째-스텝-인터넷-게이트웨이-만들기&quot;&gt;세 번째 스텝: 인터넷 게이트웨이 만들기&lt;/h2&gt;
&lt;p&gt;VPC와 서브넷을 만들고, 서브넷에 속한 인스턴스도 만들어보았습니다. 하지만 이 인스턴스에 접속하지는 못 하고 있는 상황입니다. 앞서 살펴보았듯이 이 문제를 해결하려면 다음 두 가지 조건을 추가적으로 만족해야합니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;VPC에 인터넷 게이트웨이를 연결합니다.&lt;/li&gt;
&lt;li&gt;서브넷의 라우팅 테이블이 인터넷 게이트웨이를 가리키는지 확인합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;먼저 첫 번째 조건부터 시작해보겠습니다. 다시 VPC 대시보드로 돌아가서 한 단계 씩 진행해보겠습니다. 인트넷 게이트웨이 목록&lt;sup&gt;Internet Gateways&lt;/sup&gt;에서 인터넷 게이트웨이 생성&lt;sup&gt;Create internet gateway&lt;/sup&gt; 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/294/294e0cc64b5b18c7774d421f263e7134391862337de3837dac0499bf972e47e8.m.png&quot; alt=&quot;인터넷 게이트웨이 생성 과정. 이름만 지정하면 됩니다.&quot;&gt;&lt;figcaption&gt;인터넷 게이트웨이 생성 과정. 이름만 지정하면 됩니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;화면에서 확인할 수 있듯이 지정해야하는 값은 이름 태그 하나인데, 이마저도 지정하지 않아도 됩니다. 바로 인터넷 게이트웨이를 생성합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/6e5/6e5b5ba4e00fce05b82837ca7d2ba18d0a3e3d2aa77800ed6e269278a02c9812.m.png&quot; alt=&quot;막 생성된 인터넷 게이트웨이는 어느 라우팅 테이블과도 연결되어있지 않습니다.&quot;&gt;&lt;figcaption&gt;막 생성된 인터넷 게이트웨이는 어느 라우팅 테이블과도 연결되어있지 않습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;생성된 인터넷 게이트웨이는 &lt;em&gt;연결되지 않음&lt;/em&gt;&lt;sup&gt;detached&lt;/sup&gt; &lt;em&gt;상태&lt;/em&gt;&lt;sup&gt;Status&lt;/sup&gt;입니다. 액션 버튼을 클릭하고 &lt;em&gt;VPC 연결&lt;/em&gt;&lt;sup&gt;Attach to VPC&lt;/sup&gt;을 선택합니다. 앞서 만든 VPC를 선택하고 연결&lt;sup&gt;Attach&lt;/sup&gt;을 클릭합니다. 이제 VPC와 인터넷 게이트웨이가 연결되었습니다.&lt;/p&gt;
&lt;p&gt;이제 남은 건 두 번째 조건입니다. 서브넷의 라우팅 테이블이 인터넷 게이트웨이를 가리키도록 하는 일입니다. 라우트 테이블 목록&lt;sup&gt;Route Tables&lt;/sup&gt;에서 서브넷에 연결된 라우트 테이블을 찾습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/bbe/bbe0fda19bc6d483bde772944979993588c6ac775281c8790790d50a79ffb199.m.png&quot; alt=&quot;라우팅 테이블 목록&quot;&gt;&lt;figcaption&gt;라우팅 테이블 목록&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;라우트 규칙 목록&lt;/em&gt;&lt;sup&gt;Routes&lt;/sup&gt; 탭을 선택하면 VPC 내부 연결을 위한 규칙만 있는 것을 확인할 수 있습니다. &lt;em&gt;라우트 수정&lt;/em&gt;&lt;sup&gt;Edit Routes&lt;/sup&gt;를 클릭하고 &lt;em&gt;라우트 추가&lt;/em&gt;&lt;sup&gt;Add Route&lt;/sup&gt;를 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/ad6/ad67c04fc736e964725510e66c7575d9579dbb1219560372b31ce1b24a766554.m.png&quot; alt=&quot;인터넷 게이트웨이를 연결하는 라우팅 규칙을 추가합니다.&quot;&gt;&lt;figcaption&gt;인터넷 게이트웨이를 연결하는 라우팅 규칙을 추가합니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;목적지&lt;sup&gt;Destination&lt;/sup&gt;은 0.0.0.0/0을 지정하고 타깃&lt;sup&gt;Target&lt;/sup&gt;은 앞서 생성한 인터넷 게이트웨이의 ID를 지정합니다. 라우트 저장&lt;sup&gt;Save routes&lt;/sup&gt; 버튼을 클릭합니다. 라우트 규칙은 위에서부터 차례대로 적용됩니다. 첫 번째 규칙은 VPC CIDR 범위의 접근에 대해서 VPC 내부로 라우트하는 규칙입니다. 두 번째 규칙은 그 이외의 모든 IP 접근(0.0.0.0/0은 모든 IP를 의미합니다)에 대해서 인터넷 게이트웨이로 라우트하는 규칙입니다.&lt;/p&gt;
&lt;p&gt;이제 모든 조건을 만족했습니다. 다시 텔넷을 사용해 두 번째 스텝에서 만들었던 인스턴스에 다시 접속해봅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ telnet 54.175.41.41 22
Trying 54.175.41.41...
Connected to ec2-54-175-41-41.compute-1.amazonaws.com.
Escape character is '^]'.
SSH-2.0-OpenSSH_7.4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제는 정상적으로 반응이 오는 것을 확인할 수 있습니다. SSH로 접속하는 것도 물론 가능합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh ec2-user@54.175.41.41

       __|  __|_  )
       _|  (     /   Amazon Linux AMI
      ___|\___|___|

https://aws.amazon.com/amazon-linux-ami/2018.03-release-notes/
[ec2-user@ip-10-10-1-66 ~]$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기까지 직접 VPC를 만들어보았습니다. 여기까지 셋업한 내용이 실제로 계정 생성시 만들어지는 기본 VPC와 거의 같은 상태입니다. 앞서 살펴본 기본 VPC의 구성 요소는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 VPC&lt;/li&gt;
&lt;li&gt;n 서브넷&lt;sup&gt;Subnet&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 라우트 테이블&lt;sup&gt;Route Table&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 네트워크 ACL&lt;sup&gt;Network ACL&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 시큐리티 그룹&lt;sup&gt;Security Group&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 인터넷 게이트웨이&lt;sup&gt;Internet Gateway&lt;/sup&gt;
&lt;/li&gt;
&lt;li&gt;1 DHCP 옵션셋&lt;sup&gt;DHCP options set&lt;/sup&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서는 편의상 서브넷을 2개만 만들었습니다만 서브넷을 가용존 수만큼 조금 더 큰 CIDR 범위로 만들어주면 기본 VPC와 완전히 같습니다.&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;기본적인 구조만 이해한다면 아마존 VPC를 만드는 것 자체는 크게 어려운 일은 아닙니다. 기본 VPC를 실수로 지워도 직접 만들어낼 수 있습니다. 또한 각 리소스들의 역할에 대해서 이해한다면 원하는 모양으로 VPC를 커스터마이징하는 것도 가능합니다. 프로덕션 환경을 구축하는 경우에는 대부분 기본 VPC보다 복잡한 네트워크를 직접 디자인하고 구성해서 사용하게 됩니다. 기본 VPC는 다른 AWS 리소스들을 사용하고 인터넷에서 접근 가능한 최소한의 네트워크 구성이라고 이해하셔도 무방합니다. 기본 VPC의 서브넷들은 기본적으로 인터넷 게이트웨이 연결되어있는데 이러한 서브넷들을 퍼블릭 서브넷이라고 부릅니다. 따라서 기본 VPC나 이 글에서 함께 만들어본 VPC는 퍼블릭 서브넷들로 구성된 VPC입니다.&lt;/p&gt;
&lt;p&gt;그렇다면 인터넷 게이트웨이에 직접 연결되지 않은 서브넷도 있을까요? 이러한 서브넷을 프라이빗 서브넷이라고 합니다. 이어지는 글에서는 퍼블릭 서브넷과 프라이빗 서브넷을 구성된 VPC를 만드는 방법에 대해서 소개하겠습니다(기억을 더듬어보시면, 이 글에서 이미 프라이빗 서브넷과 퍼블릭 서브넷을 모두 만들어보았다는 걸 알 수 있습니다).&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>nacyot</author>
      <pubDate>Tue, 14 May 2019 00:43:42 +0000</pubDate>
      <dc:date>2019-05-14T00:43:42+00:00</dc:date>
    </item>
    <item>
      <title>깃허브 패키지 레지스트리(Github Package Registry) 베타 발표</title>
      <link>https://www.44bits.io/ko/post/news--announcing-github-package-registry</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        깃허브 패키지 레지스트리 베타 발표
                &lt;div class=&quot;subtitle&quot;&gt;언어 별 패키지 매니저 지원 및 깃헙 권한으로 접근 제어 등&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;5월 10일 깃허브&lt;sup&gt;GitHub&lt;/sup&gt;에서는 새로운 서비스인 &lt;a href=&quot;https://github.blog/2019-05-10-introducing-github-package-registry/&quot;&gt;깃허브 패키지 레지스트리&lt;sup&gt;GitHub Package Registry&lt;/sup&gt; 베타를 발표했습니다&lt;/a&gt;. 깃허브에서 제공하는 레지스트리 서비스는 빌드된 패키지를 저장 및 배포할 수 있도록 도와주는 서비스입니다. 노드js&lt;sup&gt;Node.js&lt;/sup&gt;의 NPM, 자바&lt;sup&gt;Java&lt;/sup&gt;의 메이븐&lt;sup&gt;Maven&lt;/sup&gt;, 닷넷&lt;sup&gt;.NET&lt;/sup&gt;의 누겟&lt;sup&gt;NuGet&lt;/sup&gt;, 루비&lt;sup&gt;Ruby&lt;/sup&gt;의 루비젬&lt;sup&gt;RubyGems&lt;/sup&gt;와 같은 프로그래밍 언어별 패키지 관리자와 더불이 도커&lt;sup&gt;Docker&lt;/sup&gt; 이미지 저장소도 제공할 예정입니다.&lt;/p&gt;
&lt;p&gt;패키지 매니저는 오픈소스는 물론 비공개 프로젝트에서도 사용하는 것이 가능합니다. 기존에도 언어 별로 패키지 매니저를 직접 운영하거나 비공개 저장소를 서비스로 제공하는 경우가 있었습니다. 하지만 여러 언어를 사용하는 경우 패키지 매니저 별로 인증 관리를 별도로 관리하는 등의 어려움이 있었습니다. 깃허브 레지스트에서는 패키지가 저장소와 통합되며 패키지를 배포한 저장소들은 (깃허브에서 지원하는 경우) 패키지 매니저나 언어에 무관하게 깃헙의 인증 권한을 통해서 권한 제어를 하는 것이 가능합니다. 또한 깃허브에서 제공하는 깃허브 액션&lt;sup&gt;GitHub Action&lt;/sup&gt;이나 웹훅과 함께 사용해 패키지 빌드나 배포를 자동화하는 것도 가능합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/391/39192191f2ebe8542a3b5be4e3a400ee9ad63852d87214b744e7bd390001d727.m.png&quot; alt=&quot;깃허브(GitHub)의 패키지 페이지 - 패키지 기능은 저장소와 통합되어 제공될 것으로 보입니다&quot;&gt;&lt;figcaption&gt;깃허브(GitHub)의 패키지 페이지 - 패키지 기능은 저장소와 통합되어 제공될 것으로 보입니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;깃허브 레지스트는 기존 패키지 매니저 인터페이스를 그대로 사용하는 것이 가능합니다. 예를 들어 루비젬을 빌드하고 레지스트리에 배포할 때 &lt;code&gt;gem&lt;/code&gt; 명령어를 그대로 사용하며, 인증 권한 이외에 추가적인 프로그램은 필요하지 않습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &quot;:github: Bearer ${GH_TOKEN}&quot; &amp;gt;&amp;gt; ~/.gem/credentials
$ gem build github_api.gemspec
$ gem push --key github --host https://rubygems.pkg.github.com/phanatic/github_api github_api-1.0.0.gem
Successfully registered gem: github_api (1.0.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;현재 깃허브 레지스트리는 베타 테스트를 진행하고 있으며, &lt;a href=&quot;https://github.com/features/package-registry/signup&quot;&gt;베타 등록 페이지&lt;/a&gt;에서 신청할 수 있습니다. 깃허브 저장소와 마찬가지로 공개된 프로젝트(오픈소스)에 대해서는 무료로 사용할 수 있습니다. 유료 정책에 대해서는 추후 공개 예정입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/c44/c44b6513a73402816480feeaf3c6761a15e43d508a0a89df6cc6539592d8489f.m.png&quot; alt=&quot;깃허브 패키지 레지스트리는 베타 신청을 받고 있습니다&quot;&gt;&lt;figcaption&gt;깃허브 패키지 레지스트리는 베타 신청을 받고 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;자세한 내용은 다음 공식 문서들을 참고해주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.blog/2019-05-10-introducing-github-package-registry/&quot;&gt;깃허브 블로그 - 깃허브 패키지 레지스트를 소개합니다&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/en/articles/about-github-package-registry&quot;&gt;공식 문서 - 깃허브 패키지 레지스트리에 관하여&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=N_-Cu9_2YAA&quot;&gt;Youtube - 깃허브 패키지 레지스트를 소개합니다&lt;/a&gt; `&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>nacyot</author>
      <pubDate>Mon, 13 May 2019 05:30:18 +0000</pubDate>
      <dc:date>2019-05-13T05:30:18+00:00</dc:date>
    </item>
    <item>
      <title>마이크로소프트 빌드 2019,  윈도우 터미널 발표 - 파워셸, 커맨드 프롬프트 WSL 지원</title>
      <link>https://www.44bits.io/ko/post/news--ms-build-2019-introducing-windows-terminal</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        MS 빌드 2019, 윈도우 터미널 발표
                &lt;div class=&quot;subtitle&quot;&gt;파워셸, 커맨드 프롬프트 WSL 지원&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;마이크로소프트가 윈도우에서 실행되는 윈도우 터미널&lt;sup&gt;Windows Terminal&lt;/sup&gt;을 발표 했습니다. 윈도우 터미널은 파워셸&lt;sup&gt;PowerShell&lt;/sup&gt;, 커맨드 프롬프트, WSL&lt;sup&gt;Windows Subsystem for Linux&lt;/sup&gt; 같은 커맨드라인툴 사용자를 위해 만들어 졌습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/eed/eedf43cf3ecff069e7f00222d01543d0fe64eb0210026dcd8dfb20bcff9e968e.m.png&quot; alt=&quot;윈도우 터미널에서 파워셸을 실행한 모습&quot;&gt;&lt;figcaption&gt;윈도우 터미널에서 파워셸을 실행한 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;윈도우 터미널은 윈도우 10의 마이크로소프트 스토어를 이용해 배포되며 오픈소스로 공개 됩니다. 정식 공개 날짜는 2019년 겨울이지만 윈도우 터미널의 &lt;a href=&quot;https://github.com/Microsoft/Terminal&quot;&gt;깃헙 저장소&lt;/a&gt;를 방문해 미리 빌드해보고 테스트 할 수 있습니다. 윈도우 터미널 소개 영상은 유튜브에서 볼 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8gw0rXPMMPE&amp;amp;app=desktop&quot;&gt;새로운 윈도우 터미널 - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;윈도우 터미널의 핵심 기능은 여러개의 탭 지원, GPU 가속을 이용한 텍스트 렌더링, 설정을 이용한 개인화 등입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/a70/a70e255d3547fec82e953bafaafdc81a0eeda84bbc126241c0bb8709ea9a81c6.m.png&quot; alt=&quot;윈도우 터미널은 커맨드 프롬프트, 파워셸, WSL 등 다양한 커맨드라인 환경을 지원합니다&quot;&gt;&lt;figcaption&gt;윈도우 터미널은 커맨드 프롬프트, 파워셸, WSL 등 다양한 커맨드라인 환경을 지원합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;멀티탭 기능을 이용해 탭 하나는 파워셸 다른 탭은 커맨드 프롬프트 또 다른셸은 WSL로 구동되는 우분투등의 터미널을 동시에 실행 할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/2fc/2fc131ae1c58a2e81d0df5b9b49960c890ae2adf646352a0b85aeb801324dd0c.m.png&quot; alt=&quot;이모지, 아이콘, 한자를 출력할 수 있습니다.&quot;&gt;&lt;figcaption&gt;이모지, 아이콘, 한자를 출력할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;GPU 가속을 이용한 새로운 텍스트 렌더링 엔진의 적용으로 문자의 표현을 다양하게 할 수 있게 되었습니다. 이모지, 아이콘, 한자 등을 표현할 수 있습니다.&lt;/p&gt;
&lt;p&gt;설정 기능은 구조화된 텍스트 파일로 작성되며, 터미널의 외관을 꾸미거나 프로필 설정등을 원하는대로 변경하고 저장하는 것도 가능합니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 마이크로소프트의 공식 기사를 확인해주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://devblogs.microsoft.com/commandline/introducing-windows-terminal/&quot;&gt;새로운 윈도우 터미널을 소개합니다 | Windows Command Line Tools For Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Wed, 08 May 2019 06:22:24 +0000</pubDate>
      <dc:date>2019-05-08T06:22:24+00:00</dc:date>
    </item>
    <item>
      <title>아마존 S3(Amazon S3), 2020년 9월 경로(path) 형식의 API 호출 중지 예정</title>
      <link>https://www.44bits.io/ko/post/news--amazon-s3-will-no-longer-support-path-style-API-requests</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        아마존 S3, 2020년 9월 30일부터 path 형식의 API 호출 중지 예정
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;2020년 9월 30일부터 아마존 웹 서비스&lt;sup&gt;AWS, Amazon Web Service&lt;/sup&gt;에서 제공하는 아마존 S3의 경로 형식 API 호출이 작동하지 않을 예정입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forums.aws.amazon.com/ann.jspa?annID=6776&quot;&gt;AWS의 S3 포럼에 올라온 공지글&lt;/a&gt;에 의하면 S3가 지원하던 두 가지 형식의 API 요청 중 경로 형식에 대한 지원이 2020년 9월 30일부터 중단됩니다.&lt;/p&gt;
&lt;p&gt;AWS의 S3는 현재 두 가지 형식의 API 요청을 지원합니다. 하나는 &lt;code&gt;//s3.amazonaws.com/&amp;lt;bucketname&amp;gt;/key&lt;/code&gt;와 같은 (V1이라고 알려진) 경로 형식이고, 다른 하나는 &lt;code&gt;//&amp;lt;bucketname&amp;gt;.s3.amazonaws.com/key&lt;/code&gt;와 같은 (V2라고 알려진) 가상 호스트 형식입니다.&lt;/p&gt;
&lt;p&gt;이는 모든 리전에 적용되는 변경 사항으로 경로 형식으로 호출하는 애플리케이션 코드를 2020년 9월 30일 이전까지 수정하고, AWS SDK는 최신 버전을 사용하도록 권고하였습니다. 2020년 9월 30일부터는 경로 형식의 API 요청이 실패한다고 밝혔습니다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 공식 포럼의 아래의 공지글을 참고해주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forums.aws.amazon.com/ann.jspa?annID=6776&quot;&gt;AWS 개발자 포럼: 아마존 S3는 2020년 9월 30일부터 경로 형식의 API 호출을 지원하지 않습니다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Wed, 08 May 2019 00:35:07 +0000</pubDate>
      <dc:date>2019-05-08T00:35:07+00:00</dc:date>
    </item>
    <item>
      <title>마이크로소프트 비주얼 스튜디오 코드(Visual Studio Code), 원격 개발 기능 지원</title>
      <link>https://www.44bits.io/ko/post/news--vs-code-now-supports-remote-development</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        마이크로소프트 비주얼 스튜디오 코드, 원격 개발 기능 지원
                &lt;div class=&quot;subtitle&quot;&gt;컨테이너, 원격 서버 등 세 가지 모드로 사용 가능&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;비주얼-스튜디오-코드의-원격-개발-지원-발표&quot;&gt;비주얼 스튜디오 코드의 원격 개발 지원 발표&lt;/h2&gt;
&lt;p&gt;비주얼 스튜디오 코드(이하 VS 코드)&lt;sup&gt;Visual Studio Code&lt;/sup&gt;에서 원격 환경(SSH 등)의 개발을 지원한다고 발표했습니다.&lt;/p&gt;
&lt;p&gt;원격 개발 지원에 대해서는 2019년 5월 2일에 공개된 &lt;a href=&quot;https://code.visualstudio.com/blogs/2019/05/02/remote-development&quot;&gt;VS 코드 블로그의 글&lt;/a&gt;과, &lt;a href=&quot;https://devblogs.microsoft.com/python/remote-python-development-in-visual-studio-code/&quot;&gt;마이크로소프트의 파이썬 블로그&lt;/a&gt;에서 다루고 있습니다. 또한 5월 1일부터 진행 중인 파이콘 US 2019에 설치된 마이크로소프트 부스에서는 데모를 볼 수 있다고 합니다.&lt;/p&gt;
&lt;p&gt;이번에 추가된 원격 개발 기능은 다음과 같은 세 가지 기능을 포함합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컨테이너 지원&lt;/li&gt;
&lt;li&gt;원격 서버 지원&lt;/li&gt;
&lt;li&gt;WSL&lt;sup&gt;Windows Subsystem for Linux&lt;/sup&gt; 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VS 코드의 원격 환경 지원은 이전부터 논의 되어오던 기능입니다. &lt;a href=&quot;https://github.com/Microsoft/vscode-python/issues/79&quot;&gt;이에 관한 깃허브 이슈&lt;/a&gt;는 2017년 11월에 생성된 이래 무려 100개가 넘는 댓글이 달렸습니다. 이번 발표와 함게 이 이슈도 닫혔습니다.&lt;/p&gt;
&lt;h2 id=&quot;예제로-살펴보는-원격-개발-기능&quot;&gt;예제로 살펴보는 원격 개발 기능&lt;/h2&gt;
&lt;p&gt;VS 코드에서 원격 개발 기능을 사용하려면 다음 두 가지를 먼저 설치해야합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;비주얼 스튜디오 코드의 인사이더스&lt;sup&gt;Visual Studio Code Insiders&lt;/sup&gt; 버전&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack&quot;&gt;원격 개발&lt;sup&gt;Remote Development&lt;/sup&gt; 확장팩&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서는 마이크로소프트가 제공하는 예시 파이썬 프로젝트를 통해 VS 코드의 원격 개발 기능을 살펴보겠습니다. 먼저 샘플 파이썬 프로젝트를 클론합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/Microsoft/vscode-remote-try-python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;VS 코드 인사이더스에서 해당 폴더를 열고 왼쪽 아래의 초록색 &amp;gt;&amp;lt; 모양을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/769/7699727479b4394067e29085b64f3a790bde71d7b70f90bd36dd2d2f3a9307bc.m.png&quot; alt=&quot;원격 환경을 선택할 수 있는 왼쪽 아래의 &amp;gt;&amp;lt; 버튼&quot;&gt;&lt;figcaption&gt;원격 환경을 선택할 수 있는 왼쪽 아래의 &amp;gt;&amp;lt; 버튼&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;선택 창에서 &lt;code&gt;Remote-Containers: Reopen Folder in Container&lt;/code&gt;를 선택합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/a4e/a4ebf7c4eebb3d1454b1f5fa084c58a35dddc21a83c1b62e1a0c7c71ea1bb3b6.m.png&quot; alt=&quot;원격 환경 선택 창&quot;&gt;&lt;figcaption&gt;원격 환경 선택 창&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;왼쪽 익스플로어 창을 보면 컨테이너 안에서 폴더가 열렸음을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/a9c/a9c1a1a077e46723b341edfb109f6eafa47ec1fe0c0c06b31aff4aa7503dac80.m.png&quot; alt=&quot;예시 폴더를 컨테이너 안에서 연 모습&quot;&gt;&lt;figcaption&gt;예시 폴더를 컨테이너 안에서 연 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VS 코드에서는 원격 개발 환경에 대한 설정을 &lt;code&gt;.devcontainer.json&lt;/code&gt;이라는 파일로 관리합니다. 샘플 프로젝트의 &lt;code&gt;.devcontainer.json&lt;/code&gt; 파일은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;Python Sample&quot;,
    &quot;dockerFile&quot;: &quot;Dockerfile&quot;,
    &quot;appPort&quot;: 9000,
    &quot;context&quot;: &quot;..&quot;,
    &quot;extensions&quot;: [
      &quot;ms-python.python&quot;
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;a href=&quot;http://app.py&quot;&gt;&lt;code&gt;app.py&lt;/code&gt;&lt;/a&gt; 파일을 열고 Cmd 키를 누른 채 키워드에 커서를 올려보면 선언부 내용을 잘 보여줍니다. 이 상태에서 클릭을 하면 해당 파일을 열어줍니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/2ea/2ea61a694df04ffeba8194555cef8fe83fcc3ff31d48df12b45d9967e0cbfca4.m.png&quot; alt=&quot;패키지에 설치한 Flask의 내용도 잘 보여줍니다.&quot;&gt;&lt;figcaption&gt;패키지에 설치한 Flask의 내용도 잘 보여줍니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;여기까지 VS 코드에 새롭게 추가된 원격 개발 기능에 대해서 간단히 살펴보았습니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Tue, 07 May 2019 04:58:57 +0000</pubDate>
      <dc:date>2019-05-07T04:58:57+00:00</dc:date>
    </item>
    <item>
      <title>스티븐 레비의 '해커, 광기의 랩소디' 재발간 텀블벅 펀딩 진행 중</title>
      <link>https://www.44bits.io/ko/post/news--hackers-heroes-of-the-computer-revolution-is-funding-on-tumblbug</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        스티븐 레비의 ‘해커, 광기의 랩소디’ 재발간 텀블벅 펀딩 진행 중
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;p&gt;스티븐 레비&lt;sup&gt;Steven Levy&lt;/sup&gt;의 ⟪해커, 광기의 랩소디⟫가 재출간을 앞두고 텀블벅에서 펀딩을 진행하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tumblbug.com/hackers&quot;&gt;세 번 절판하고 네 번째 ’hackers’를 준비 하기 :: 텀블벅&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⟪해커스: 세상을 바꾼 컴퓨터 천재들⟫로도 출간된 적이 있는 ⟪해커, 광기의 랩소디⟫가 번역서만으로 네 번째 재발간을 앞두고 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;원서&quot;&gt;원서&lt;/h2&gt;
&lt;p&gt;해커의 역사를 다룬 이 책은, 1984년에 ⟪Hackers: Heroes of the Computer Revolution⟫이라는 제목으로 첫 출간되었고, 1994년에 “10년 이후”라는 후기를 담아 개정되었습니다. 2010년에는 발간 25주년을 기념하여 오라일리 출판사&lt;sup&gt;O’Reilly Media&lt;/sup&gt;가 재발간하였습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/4b5/4b5ecc5498e968916282e45e838a8ae66921e94b9695b21c9e4d6897631f5300.m.png&quot; alt=&quot;⟪Hackers: Heroes of the Computer Revolution⟫ 초판의 모습&quot;&gt;&lt;figcaption&gt;⟪Hackers: Heroes of the Computer Revolution⟫ 초판의 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;번역서의-발간-기록&quot;&gt;번역서의 발간 기록&lt;/h2&gt;
&lt;p&gt;우리나라에서는 1991년에 &lt;a href=&quot;~http://www.pressian.com/news/article/?no=136123#09T0~&quot;&gt;출판기획모임인 ’과학세대’가 번역한 것을 사민서각이 ⟪해커⟫라는 제목으로 처음 출간&lt;/a&gt;했고, 1995년에는 김동광 씨가 새로 번역한 ⟪&lt;a href=&quot;http://www.yes24.com/Product/goods/2256&quot;&gt;해커, 그 광기와 비밀의 기록&lt;/a&gt;⟫을 사민서각에서 재출간하였습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/f10/f1089c70afff0d858c2e88d57a00a836cefa96ba9034514a6b1beff1f64d3ae9.m.png&quot; alt=&quot;⟪해커⟫의 발간 소식을 알리는 1991년 8월 8일자 경향신문&quot;&gt;&lt;figcaption&gt;⟪해커⟫의 발간 소식을 알리는 1991년 8월 8일자 경향신문&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이후 사민서각본은 절판되었고, 2013년에 한빛미디어가 정식 계약을 맺고 &lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=30061214&quot;&gt;25주년 기념판을 ⟪해커스: 세상을 바꾼 컴퓨터 천재들⟫이라는 제목으로 번역 출간&lt;/a&gt;했고, 이후 절판한 역사가 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;네-번째-번역본&quot;&gt;네 번째 번역본&lt;/h2&gt;
&lt;p&gt;출판사 내부 사정에 의해 정식판이 절판되어 아쉬웠던 번역가, 에디터, 디자이너가 뜻을 모아 독자들과 함께 이 책을 다시 출간하려는 의도로 텀블벅 프로젝트를 시작하였습니다.&lt;/p&gt;
&lt;p&gt;이번 프로젝트의 성공을 위해 후원 금액에 따라 특별한 리워드도 준비했다고 합니다. (기사 작성 시점에는 이미 목표 금액을 초과달성했으며, 텀블벅에서는 5월 10일까지 후원이 가능합니다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;세 가지 색상의 표지 - 초록색, 파란색, 빨간색 중 택1&lt;/li&gt;
&lt;li&gt;제목이 인쇄된 다용도 가습기&lt;/li&gt;
&lt;li&gt;해커 뱃지&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;책 본문에서 달라지는 점도 있다고 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대명사를 명사로 바꿈&lt;/li&gt;
&lt;li&gt;반복해 부르는 이름은 꼭 필요하지 않으면 삭제&lt;/li&gt;
&lt;li&gt;이름, 성, 별칭으로 섞어 부르는 경우 하나로 통일&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://tumblbug.com/hackers&quot;&gt;텀블벅 프로젝트 페이지&lt;/a&gt;를 참고해주세요.&lt;/p&gt;
&lt;h2 id=&quot;프로젝트-이후&quot;&gt;프로젝트 이후&lt;/h2&gt;
&lt;p&gt;텀블벅 프로젝트와 별개로 5월 중순부터 오프라인 서점에서도 초록색 표지의 책을 구입할 수 있고, 5월 말부터는 전자책으로도 발매될 예정입니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Sun, 05 May 2019 07:39:41 +0000</pubDate>
      <dc:date>2019-05-05T07:39:41+00:00</dc:date>
    </item>
    <item>
      <title>디자이너와 포토샵 없이 Write the Docs 행사 굿즈 제작하기</title>
      <link>https://www.44bits.io/ko/post/preparing-wtd-meetup-without-a-designer-nor-photoshop</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        디자이너와 포토샵 없이 Write the Docs 행사 굿즈 제작하기
                &lt;div class=&quot;subtitle&quot;&gt;당신의 행사에 디자이너가 필요한 이유&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;write-the-docs를-준비하자&quot;&gt;Write the Docs를 준비하자&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://festa.io/events/191/&quot;&gt;Write The Docs 서울에서 2019년 첫 밋업&lt;/a&gt;을 준비하게 되었습니다. 2년 만에 행사를 준비하면서, 디자이너가 없어서 꾸역꾸역 대표 이미지와 스티커, 현수막, 배너를 직접 제작한 경험을 정리해볼까 합니다.&lt;/p&gt;
&lt;h2 id=&quot;저작권-문제-없는-이미지-찾고-배너-만들기-w-visual-hunt&quot;&gt;저작권 문제 없는 이미지 찾고 배너 만들기 w/ Visual Hunt&lt;/h2&gt;
&lt;p&gt;이번 행사는 &lt;a href=&quot;festa.io&quot;&gt;Festa!&lt;/a&gt;라는 곳에 등록하려고 했는데 대표 이미지를 요구하더군요. 일단 동공을 한 번 흔들어주고, 방법을 찾아보았습니다. &lt;a href=&quot;https://archive.pycon.kr/2016apac/program/tutorial/4&quot;&gt;2년 전 파이콘에서 진행된 밋업&lt;/a&gt; 때는 저작권 문제가 없는 이미지를 찾고자 고민을 하다가 마침 친구가 찍은 경복궁 사진이 있어 허락을 받고 사용할 수 있었습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b43/b436c54cab4bcf5e83a3b4a17fe3fcc3c081aa8e6bf4c3ade5a3e8813f83136b.m.png&quot; alt=&quot;경복궁의 겨울 풍경&quot;&gt;&lt;figcaption&gt;경복궁의 겨울 풍경&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;행사는 여름이었는데 겨울 경복궁 사진이라는 점이 이불킥…&lt;/p&gt;
&lt;p&gt;이 사진으로 만든 소셜 미디어용 커버 이미지를 만들었습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/ed9/ed9e2a5901d0067822add8a3e2e0d573a56961755ec3090db26e7804f75497e2.m.png&quot; alt=&quot;1회 밋업 커버 이미지&quot;&gt;&lt;figcaption&gt;1회 밋업 커버 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Write The Docs는 국제적인 행사고 우리 행사는 서울에서 하니까, 서울과 관련된 사진을 사용하고 싶은데, 궁궐 같은 사진은 2년 전에 사용하기도 했고 서울 산다고 해도 ‘궁궐을 몇 번이나 본다고?’ 싶어서, 다른 사진을 찾고 싶었습니다.&lt;/p&gt;
&lt;p&gt;저작권 걱정 없이 사용할 수 있는 이미지는 &lt;a href=&quot;https://visualhunt.com/&quot;&gt;비주얼 헌트&lt;sup&gt;Visual Hunt&lt;/sup&gt;&lt;/a&gt;와 &lt;a href=&quot;https://pixabay.com/ko/&quot;&gt;픽사베이&lt;sup&gt;Pixabay&lt;/sup&gt;&lt;/a&gt;에서 주로 검색하는데요. 비주얼 헌트에서 다음과 같은 멋진 한강 다리 사진을 발견하고 사용하기로 했습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/49a/49a44920a8e6f2f473ba2b03bf6129712cff38e4fcd10fd0d0ce692667b39218.m.png&quot; alt=&quot;Image by David Mark from Pixabay&quot;&gt;&lt;figcaption&gt;Image by &lt;a href=&quot;https://pixabay.com/users/12019-12019/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=71469&quot;&gt;David Mark&lt;/a&gt; from &lt;a href=&quot;https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=71469&quot;&gt;Pixabay&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;이미지-편집-서비스-캔바canva&quot;&gt;이미지 편집 서비스 캔바(Canva)&lt;/h2&gt;
&lt;p&gt;그런데 좋은 이미지라고 해서 날 것으로 사용하기는 좀 그렇습니다. 간단한 글자를 적어 넣어야 할 텐데, 아무렇게나 넣자니 오히려 이미지를 망쳐버릴까 걱정도 되고, 이럴 때 제가 즐겨 사용하는 도구는 &lt;a href=&quot;canva.com&quot;&gt;캔바&lt;sup&gt;Canva&lt;/sup&gt;&lt;/a&gt;입니다. 캔바는 포토샵&lt;sup&gt;Photoshop&lt;/sup&gt; 없이 이미지를 편집할 수 있는 방법이기도 합니다.&lt;/p&gt;
&lt;p&gt;1회 밋업의 커버 이미지와 2회 밋업의 대표 이미지를 만들 때 모두 캔바를 사용했는데요. 잘 만들어진 템플릿에 제가 원하는 글자와 사진을 넣으면, 제법 그럴 듯한 결과물이 나옵니다. 물론 실제 디자이너분들의 결과물과는 비교 조차 되지 않습니다.&lt;/p&gt;
&lt;p&gt;여담으로, 첫 밋업을 준비하던 2년 전만 해도 캔바가 한글을 제대로 지원하지 않았습니다. 한글 서체가 없어서 영문 산세리프체를 선택한 후 한글을 입력했고요. 그러면 일단 맥OS&lt;sup&gt;macOS&lt;/sup&gt; 기본 서체인 산돌 고딕으로 보이긴 하는데 결과물을 다운로드하면 이상하게 생긴 궁서체나 명조체로 렌더링되어서, 결국 캔바의 화면을 확대한 후 이미지 부분을 캡처해서 사용했더랬습니다.&lt;/p&gt;
&lt;p&gt;그간 캔바도 꽤 발전하여 한글 서체를 선택할 수 있고, 결과물을 다운로드해도 한글 서체가 깨지지 않더군요. 고화질을 원할 때 PDF를 선택할 수 있다는 점도 좋았습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/052/0520622039315172876954e80c01c4f01e4af5c73a6b5308c04ebc2ce32ea20b.m.png&quot; alt=&quot;Download 뿐 아니라 다양한 퍼블리시 옵션을 제공하는 캔바(Canva)&quot;&gt;&lt;figcaption&gt;Download 뿐 아니라 다양한 퍼블리시 옵션을 제공하는 캔바(Canva)&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 해서 대표 이미지를 완성했습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/8d3/8d37a6395c6f16aa4799de2d4192e767912bb83f7e16eb1d24031d9b9cad41f1.m.png&quot; alt=&quot;Write The Docs 서울 2019 첫 밋업의 대표 이미지&quot;&gt;&lt;figcaption&gt;Write The Docs 서울 2019 첫 밋업의 대표 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 이미지를 festa.io에 행사를 등록하니 이런 식으로 보이네요.&lt;/p&gt;
&lt;p&gt;행사 목록 부분에는 이렇게,&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/692/6923f19c68ea5b7d3a1e0e89abcbc5e6951791c58088cb1a5a790fb11b551703.m.png&quot; alt=&quot;행사 목록에 보이는 대표 이미지&quot;&gt;&lt;figcaption&gt;행사 목록에 보이는 대표 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;행사 상세 페이지에서는 이렇게요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/dca/dcac27bc322282ffe509e24f54aa024fe3d99409e7ade8175ffb816ed280899e.m.png&quot; alt=&quot;행사 상세 페이지에 보이는 대표 이미지&quot;&gt;&lt;figcaption&gt;행사 상세 페이지에 보이는 대표 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;원래의 대표 이미지랑 살짝 다른 부분이 있는데요. 회색 사각형에 ’글쓰기와 기술의 접점을…’이라고 적은 글자가 너무 작게 보여서 그 부분을 삭제했습니다.&lt;/p&gt;
&lt;h2 id=&quot;스티커-준비&quot;&gt;스티커 준비&lt;/h2&gt;
&lt;p&gt;행사를 준비하면서 Write the Docs 미국 쪽에 계신 분들께 연락해서 스티커를 요청했는데요. 제작해서 보내주려고 했지만 한국까지 배송해주는 업체를 못 찾았다면서, 제가 직접 제작하는 대신 결제할 때 자신들의 일회용 결제 번호를 사용해보라고 하더군요.&lt;/p&gt;
&lt;p&gt;일단, 스티커 제작용 이미지를 받고,&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/42e/42e6a00e1a67252847109860966029bb98569dcfc821f6a2d2d48b87a6f0357f.m.png&quot; alt=&quot;Write The Docs 스티커용 이미지&quot;&gt;&lt;figcaption&gt;Write The Docs 스티커용 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;개발자 스티커라면 역시 도톰해야하니, 국내에서 이렇게 제작해주는 업체를 찾아보았습니다. &lt;a href=&quot;http://www.msprint.co.kr/goods/goods_view.php?goodsNo=1000000026&quot;&gt;미성 출력&lt;/a&gt;이라는 업체가 도톰한 스티커를 제작할 수 있다는 소개를 받아서 견적을 내고, WTD 미국 친구분들께 일회용 결제 번호를 받아 막 결제를 하려는 순간, 스티커 제작 업체의 결제 페이지에 해외 카드가 안 먹힌다는 사실을 발견합니다. 이래저래 찾아보니 KG 이니시스는 해외 결제 옵션을 지원하지만, 제작 업체 쪽에서 옵션으로 넣어두지 않은 것 같았습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/70f/70f33eed1c35f943844821f9c594a5d0971723e080d3808f035083be4bb44926.m.png&quot; alt=&quot;어렵사리 외국 카드 번호를 따왔건만…&quot;&gt;&lt;figcaption&gt;어렵사리 외국 카드 번호를 따왔건만…&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 된 이상 일단 결제부터 하고, 이 사실을 WTD 미국 친구분들께 알렸더니 비용을 페이팔로 보내주더군요. 고마워요 &lt;strong&gt;Eric Holscher&lt;/strong&gt;와 &lt;strong&gt;Samuel Wright&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;이렇게 해서 만들어진 WTD 스티커!&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e78/e783e74566ef64362c267c38f0402919f7323af73744c98a1147304644523c5d.m.png&quot; alt=&quot;행사엔 스티커!&quot;&gt;&lt;figcaption&gt;행사엔 스티커!&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이걸로 정말 끝난 줄 알았는데, 행사 일주일 전 머릿 속으로 행사장에 들어가다가 뭔가 허전하다는 사실을 발견했습니다. 바로, 현수막과 배너가 필요한 시점이죠.&lt;/p&gt;
&lt;h2 id=&quot;현수막과-배너-제작&quot;&gt;현수막과 배너 제작&lt;/h2&gt;
&lt;p&gt;대관 경험이 많은 마루180이어서인지, &lt;a href=&quot;https://maru180.com/event-guide&quot;&gt;이벤트홀 대관 및 사용 가이드 문서&lt;/a&gt;에 현수막의 위치와 크기를 잘 안내하고 있었습니다. 발표 화면 양쪽에 180cm X 255cm 현수막을 걸고, 배너를 두 개 제작하여 하나는 1층에, 하나는 지하에 두기로 마음 먹었습니다. 디자인이 필요하니 캔바에 들어갑니다.&lt;/p&gt;
&lt;p&gt;그런데 180cm X 255cm가 너무 크다고 퇴짜를 놓네요. 😭 머릿 속이 하얘지다가, 어차피 PDF(=벡터)로 다운로드되니까 절반 크기로 만들어서 나중에 두 배 늘리기로 했습니다. (90cm X 127.5cm)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e80/e80d4c8122da8d3dd685c6eecab3ad3752513837e6ee6f91b162463c43f371f8.m.png&quot; alt=&quot;1.058cm과 211.664cm 사이 값만 가능합니다&quot;&gt;&lt;figcaption&gt;1.058cm과 211.664cm 사이 값만 가능합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이제 괜찮은 템플릿을 찾아 봅니다. 지금껏 행사 대표 이미지로 한강 사진을 사용하고 있었으니, 여기에 맞춰 배경 사진이 큰 2쪽짜리 템플릿을 골랐습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/84e/84e55d5d3f0ea95513c9128258fdefb7185d5fcd74dec22fa7db203264f4d54c.m.png&quot; alt=&quot;배경 그림이 큰 템플릿&quot;&gt;&lt;figcaption&gt;배경 그림이 큰 템플릿&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;템플릿에서 필요 없는 글자를 지우고, 배경 사진을 바꾸니 다음과 같은 모양이 되었네요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e74/e74efa94a90549f27bc22a1eea2e7b7d93f3c16a468039d9f826c978575efcc1.m.png&quot; alt=&quot;완성된 현수막&quot;&gt;&lt;figcaption&gt;완성된 현수막&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;왼쪽 위에 노란색 사각형을 살리고 싶었지만, Write The Docs 로고의 배경색을 바꿔도 된다는 조항이 없어서 포기했고요. 로고를 제일 위로 올릴까도 생각했지만, 재단할 때 어긋나면 이상해지니까 안전하게 안쪽으로 넣었습니다. 실제 출력물을 걸어보니 다음과 같이 되었네요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/1a2/1a2b50e237f0660af7c059f6bc11670e083bf0e0e58211e70266d9939e60b9fd.m.png&quot; alt=&quot;실제 출력물이 배치된 모습&quot;&gt;&lt;figcaption&gt;실제 출력물이 배치된 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;원래는 왼쪽에 제목이 들어 있는 현수막을, 오른쪽에 일정이 들어 있는 현수막을 배치하려 했는데요. 강연자가 오른쪽에 서다보니, 강연자를 보는데 뒤에 글씨가 눈에 들어오거나, 일정을 보고 싶은데 강연자에게 가려지거나 할까봐 서로 위치를 바꿨습니다.&lt;/p&gt;
&lt;p&gt;막상 배치해놓고 보니 발표단이 낮고 의자 배치도 평면이어서 아랫부분이 청중에게 가려진다는 사실을 발견했습니다. 다음에도 여기에서 진행한다면 아래쪽 1/3은 채우지 않거나, 글씨를 최대한 위쪽으로 배치해야겠습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/0e4/0e45383fe66a99fba7065e31fafee4727143f2f16945b88a4727cc0ab3950a16.m.png&quot; alt=&quot;현수막 아래쪽의 글씨는 많이 가려집니다&quot;&gt;&lt;figcaption&gt;현수막 아래쪽의 글씨는 많이 가려집니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;배너는 자원을 아껴쓰는 의미에서 현수막 디자인에서 크기와 배치만 조금씩 수정하였습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b4d/b4df71dfe5aab4742cfeead26a54a4656910023631acb7a8029b5302457271e1.m.png&quot; alt=&quot;배너 이미지&quot;&gt;&lt;figcaption&gt;배너 이미지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;실제 출력 결과는 다음과 같습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/4bd/4bd18b0693d414b5924705cc47a144d7d6d286a72b79a3a531167828c07d462c.m.png&quot; alt=&quot;실제 배너의 모습&quot;&gt;&lt;figcaption&gt;실제 배너의 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 해서 디자인 작업을 겨우 마칠 수 있었습니다.&lt;/p&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;div class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;
노트
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;
별책부록1: 인쇄물 제작시 꼭 고려해야하는 경계면
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 인쇄물을 맡기면 재단을 고려하여 5mm 정도 여유를 두고 배경을 꽉 채워달라고 합니다. (인쇄물 경계면까지 색을 칠하지 않는다면 상관 없습니다.)&lt;/p&gt;
&lt;p&gt;예를 들어 다음과 같은 이미지를 용지에 꽉차게 출력하고 싶다면, 조금 더 여유있게 만들어야합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/107/107f3a3c968e38e1ed29069fc272794f3c1d880bad5c58add849b190b07da398.m.png&quot; alt=&quot;이 이미지를 출력한다고 가정합시다&quot;&gt;&lt;figcaption&gt;이 이미지를 출력한다고 가정합시다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;상하좌우로 최소 3mm, 여유 있게는 5mm 정도를 크게 만들어야 합니다. 그러나 이런 식으로는 곤란해요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/8d5/8d5b3a83fe1783d821ade161206b46be9cbd2bf4def12bef44b33a5252c9e175.m.png&quot; alt=&quot;여백을 하얗게 두면, 출력물을 보고 머릿속이 하얘질 겁니다&quot;&gt;&lt;figcaption&gt;여백을 하얗게 두면, 출력물을 보고 머릿속이 하얘질 겁니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;대신, 주변부가 조금 잘린다는 생각으로 이렇게 해야 합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/fd4/fd47d89fffb905bbf9f215f1dc66f6e2b32d52b6bc07a485e98a9e1c70997db3.m.png&quot; alt=&quot;바깥쪽에 뭘 두려면 재단선 너머까지 꽉 채워서&quot;&gt;&lt;figcaption&gt;바깥쪽에 뭘 두려면 재단선 너머까지 꽉 채워서&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;실제 안전하게 출력되는 부분은 빨간선 안쪽이고, 디자인 요소(글자나 도형)들은 노란선 안에 있어야 안전합니다.&lt;/p&gt;
&lt;p&gt;캔바에서도 이런 사항을 고려하여, &lt;code&gt;PDF Print&lt;/code&gt;를 선택하면 재단선을 추가할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/501/5010f8ec7385c122c9421310c8258bf6e47a93c972845f48a26af25b59bbd3ec.m.png&quot; alt=&quot;출출력용 PDF에 크롭/블리드 선을 넣어 주는 Canva&quot;&gt;&lt;figcaption&gt;출출력용 PDF에 크롭/블리드 선을 넣어 주는 Canva&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 다운로드하면 네 귀퉁이에 다음과 같이 재단선이 표시됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/a6a/a6a1730b279e8edb5aef81e05aecb7ba61b06508b1fab254989d9a627aacb4ee.m.png&quot; alt=&quot;재단선의 모습. 이미지에 살짝 걸친 모습을 주목하세요&quot;&gt;&lt;figcaption&gt;재단선의 모습. 이미지에 살짝 걸친 모습을 주목하세요&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 이미지를 출력소에 넘기면 경계면까지 꽉 찬 결과물이 나올 겁니다.&lt;/p&gt;
&lt;p&gt;별책부록1에서와 같이 현수막용 디자인에는 재단선이 잘 들어갔습니다. 그래서 배너용 디자인을 다운로드했는데, 무슨 문제인지 재단선이 이상하게 들어가더군요. 재단선이 이미지를 파고들어야 하는데, 아래 이미지처럼 붕 떠 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/f31/f31301a79d1b9a68831c3cc7ec6fe8fd757b5514583441509be3a6d920f858d2.m.png&quot; alt=&quot;재단선인데 이미지에 걸치지 못해서 실패&quot;&gt;&lt;figcaption&gt;재단선인데 이미지에 걸치지 못해서 실패&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;앞서 말했듯 제겐 포토샵도 없고, 도와줄 디자이너를 찾기에도 늦었기 때문에 고민하다가, 맥OS의 미리보기 앱에서 확대 출력하는 방법을 사용했습니다.&lt;/p&gt;
&lt;p&gt;일단 재단선을 추가하지 않고 PDF Print로 다운로드한 후, 미리보기 앱으로 열고 메뉴의 파일 -&amp;gt; 인쇄를 누른 후(혹은 Cmd + P), &lt;code&gt;Paper Size&lt;/code&gt; 드롭다운 메뉴의 &lt;code&gt;Manage Custom Sizes&lt;/code&gt; 항목을 선택합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/ea1/ea1e2d1a40fd671f9396ddafc914fe34291e42551d097647bba344f27f8a2ca0.m.png&quot; alt=&quot;미리보기 앱의 인쇄 화면&quot;&gt;&lt;figcaption&gt;미리보기 앱의 인쇄 화면&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 버튼을 눌러 용지 이름을 입력한 후(실제 출력물의 크기를 입력하면 좋습니다), &lt;code&gt;Paper Size&lt;/code&gt;에 출력할 크기에 (상하좌우 5mm씩이니) 가로 + 10mm, 세로 + 10mm를 입력합니다. 예를 들어 1,800mm x 2,550mm 짜리 출력물을 만들 땐, 1,810mm x 2,560mm를 입력합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/0a7/0a7bec77d3e5d7ddba7a9bea6fa179a123e684eb9d340f7cf8fb89b741624a50.m.png&quot; alt=&quot;사용자가 원하는 용지 크기를 추가&quot;&gt;&lt;figcaption&gt;사용자가 원하는 용지 크기를 추가&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;여백은 모두 0으로 하고, OK를 눌러 저장을 합니다.&lt;/p&gt;
&lt;p&gt;이후 다시 인쇄 화면이 나타나면 &lt;code&gt;Scale to Fit&lt;/code&gt; 옵션을 선택(1)하고, 오른쪽 아래의 PDF 버튼을 눌러 &lt;code&gt;Save As PDF&lt;/code&gt;를 선택(2)합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/881/88146598b552c326ab0b8e786d4e384b1d89cbb68aec7cdebc386b7e18e39aa5.m.png&quot; alt=&quot;확대 출력하기&quot;&gt;&lt;figcaption&gt;확대 출력하기&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 만들어진 PDF는 제작하려는 결과물의 가로세로에 10mm씩을 더한 지면을 꽉 채우게 됩니다. 마침 캔바의 크기 제한 때문에 현수막용 디자인은 50% 크기로 만들었으니, 이번 기회에 함께 늘릴 수 있겠네요.&lt;/p&gt;
&lt;p&gt;이제 만들어진 PDF의 크기는 1,810mm x 2,560mm입니다. 이 파일을 출력소에 전달하면 경계면까지 꽉 찬 출력물이 만들어집니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;디자이너가-필요해요&quot;&gt;디자이너가 필요해요&lt;/h2&gt;
&lt;p&gt;지금껏 보셔서 아시겠지만, 이 이야기가 장황해진 이유는 모두 디자이너가 없었기 때문입니다. 올해 안에 한두 차례 밋업을 더 진행하고 싶은데 그때마다 이런 장황한 이야기를 만들어내서는 안 되겠죠. 그래서 Write The Docs 행사의 취지에 동의하고 행사를 도울 마음이 있는 디자이너를 운영진으로 모시고 싶습니다.&lt;/p&gt;
&lt;p&gt;Write The Docs 서울에 어울리는 멋진 디자인을 함께 만들고 싶은 분께서는 raccoonyy@gmail.com으로 연락주세요!&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Fri, 03 May 2019 00:51:20 +0000</pubDate>
      <dc:date>2019-05-03T00:51:20+00:00</dc:date>
    </item>
    <item>
      <title>우분투(Ubuntu) 14.04 트러스티 타르 LTS 4월 30일 부로 지원 종료</title>
      <link>https://www.44bits.io/ko/post/news--ubuntu-14-04-end-of-life</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        우분투 14.04 트러스티 타르 LTS 4월 30일 부로 지원 종료
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;우분투&lt;sup&gt;Ubuntu&lt;/sup&gt; 14.04 LTS 트러스티 타르&lt;sup&gt;Trusty Tahr&lt;/sup&gt;가 2019년 4월 30일부로 종료 되었습니다. 우분투 LTS(Long Term Support) 릴리즈는 매 2년마다 4월에 발표되는 짝수 버전으로 릴리즈로부터 5년간 지원합니다.&lt;/p&gt;
&lt;p&gt;지원 종료 이후에는 보안 이슈 등에 대한 업데이트가 이루어지지 않습니다. LTS가 종료되더라도 캐노니컬&lt;sup&gt;Canonical&lt;/sup&gt;의 &lt;a href=&quot;https://buy.ubuntu.com/&quot;&gt;우분투 어드벤티지&lt;/a&gt;&lt;sup&gt;Ubuntu Advantage&lt;/sup&gt;를 통해 3년간 추가적인 지원을 받을 수 있습니다. 이 서비스는 우분투 12.04부터 도입된 유료 서비스입니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/c07/c070e26b99d113bb41cd7e831c09e7ad20f16a5462f93d54972123b03da83628.m.png&quot; alt=&quot;우분투(Ubuntu) 릴리즈 사이클&quot;&gt;&lt;figcaption&gt;우분투(Ubuntu) 릴리즈 사이클&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;현재 우분투 최신 버전은 19.04 디스코 딩고&lt;sup&gt;Disco Dingo&lt;/sup&gt;이며, 최신 LTS는 18.04 바이오닉 비버&lt;sup&gt;Bionic Beaver&lt;/sup&gt;입니다. 최신 LTS 버전인 18.04 LTS는 2023년까지 지원될 예정입니다. LTS가 아닌 경우 지원 기간이 9개월로 1년이 채 되지 않습니다. 서버를 운영하는 경우 14.04 이상 버전의 LTS를 사용하는 것을 추천드립니다. 릴리스 정보에 관해서는 &lt;a href=&quot;https://wiki.ubuntu.com/Releases&quot;&gt;우분투 공식 릴리스&lt;/a&gt; 페이지와 &lt;a href=&quot;https://www.ubuntu.com/about/release-cycle&quot;&gt;릴리즈 사이클&lt;/a&gt; 문서를 참고해주세요.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Thu, 02 May 2019 01:02:34 +0000</pubDate>
      <dc:date>2019-05-02T01:02:34+00:00</dc:date>
    </item>
    <item>
      <title>구글, 도커(Docker) 컨테이너 기반 서버리스 서비스인 클라우드 런(Cloud Run) 발표</title>
      <link>https://www.44bits.io/ko/post/news--cloud-run-is-launched-on-gcp</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        구글, 도커 컨테이너 기반 서버리스 서비스인 클라우드 런 발표
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;구글-클라우드-런cloud-run-소개&quot;&gt;구글 클라우드 런(Cloud Run) 소개&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://console.cloud.google.com&quot;&gt;구글 클라우드 플랫폼&lt;/a&gt;&lt;sup&gt;Google Cloud Platform&lt;/sup&gt;은 지난 4월 11일, 구글 클라우드 넥스트 2019&lt;sup&gt;Google Cloud Next 2019&lt;/sup&gt;에서 도커&lt;sup&gt;Docker&lt;/sup&gt; 컨테이너를 서버리스 환경에서 운영할 수 있는 &lt;a href=&quot;https://cloud.google.com/run/&quot;&gt;클라우드 런&lt;/a&gt;&lt;sup&gt;Cloud Run&lt;/sup&gt; 서비스를 발표했습니다.&lt;/p&gt;
&lt;p&gt;클라우드 런은 &lt;a href=&quot;https://kubernetes.io/&quot;&gt;쿠버네티스&lt;/a&gt;&lt;sup&gt;Kubernetes&lt;/sup&gt; 위에서 &lt;a href=&quot;https://cloud.google.com/knative/&quot;&gt;케이네이티브&lt;/a&gt;&lt;sup&gt;Knative&lt;/sup&gt; 기반으로 동작합니다. 도커 이미지만 있다면 외부에 노출된 서버 애플리케이션을 손쉽게 실행하는 것이 가능합니다. 또한 케이네이티브 기반이기 때문에 구글 클라우드에 종속되지 않고 높은 이식성을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;클라우드 런은 기존 서버리스 서비스들과는 조금 다른 과금 정책을 가지고 있습니다. &lt;a href=&quot;https://aws.amazon.com/lambda/&quot;&gt;AWS 람다&lt;/a&gt;&lt;sup&gt;AWS Lambda&lt;/sup&gt;의 경우 함수가 호출되고 실행된 시간에 비례해서 요금이 계산됩니다. 이와 달리 &lt;a href=&quot;https://aws.amazon.com/fargate/&quot;&gt;AWS 파게이트&lt;/a&gt;&lt;sup&gt;AWS Fargate&lt;/sup&gt;의 경우 컨테이너가 실행되는 시간에 비례해서 요금이 부과됩니다. 클라우드 런의 서비스는 기본적으로 서버 리퀘스트를 가정하고 있습니다. 리퀘스트를 받으면 컨테이너가 실행되고 요청을 처리합니다. 기본적으로 이 요청을 처리하는 시간만큼 요금이 계산됩니다. 이는 얼핏 AWS 람다와 비슷해보이지만, 하나의 이상의 요청을 동시에 처리하는 경우 계산 방식이 다릅니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/eb4/eb410c9f8e554f511c176e4e358d9028817752232d777131ba4295eb2e14afa7.m.png&quot; alt=&quot;클라우드 런의 사용 시간 계산 방식&quot;&gt;&lt;figcaption&gt;클라우드 런의 사용 시간 계산 방식&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;예를 들어 AWS 람다의 경우 2개의 호출에 대해서는 별도의 요금이 청구됩니다. 반면에 클라우드 런에서는 하나의 서비스가 두 개의 요청을 받은 경우, 첫 번째 요청을 처리하기 시작한 시점부터 두 요청을 모두 처리한 시간까지의 시간에 대해서 요금을 청구합니다.&lt;/p&gt;
&lt;p&gt;또한 매월 아래만큼의 무료 사용량을 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;180,000 vCPU 초&lt;/li&gt;
&lt;li&gt;메모리 360,000 GB 초&lt;/li&gt;
&lt;li&gt;2백만 요청&lt;/li&gt;
&lt;li&gt;1 GB 외부 이그레스 트래픽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://cloud.google.com/run/pricing&quot;&gt;클라우드 런 요금 페이지&lt;/a&gt;를 참고해주시기 바랍니다.&lt;/p&gt;
&lt;h2 id=&quot;예제-이미지로-클라우드-런-시작하기&quot;&gt;예제 이미지로 클라우드 런 시작하기&lt;/h2&gt;
&lt;p&gt;클라우드 플랫폼 계정이 있다면 별도의 설정 과정 없이도 곧바로 클라우드 런으로 도커 컨테이너를 실행할 수 있습니다. 여기서는 웹 콘솔에서 데모 컨테이너를 실행하는 방법을 소개하겠습니다. 먼저 클라우드 런 웹 콘솔에 접속합니다. 아직 아무런 서비스도 보이지 않습니다. 위쪽에 보이는 ‘서비스 만들기’ 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b4d/b4d609daa547d49535ec02feacbe82f371e388626003803b8f249b13209cbc27.m.png&quot; alt=&quot;클라우드 런 웹 콘솔 화면&quot;&gt;&lt;figcaption&gt;클라우드 런 웹 콘솔 화면&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;서비스를 만들기 위해서는 몇 가지 항목을 입력해야 합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/5e9/5e98f7bede68585bf85c71131001dd8140db422bd40d0efc6810e4d715aebbe7.m.png&quot; alt=&quot;클라우드 런 서비스 생성 과정&quot;&gt;&lt;figcaption&gt;클라우드 런 서비스 생성 과정&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;컨테이너 이미지에는 사용하려는 도커 이미지 URL을 입력합니다. 단, 클라우드 런에서는 컨테이너 레지스트리&lt;sup&gt;gcr.io, Google Container Registry&lt;/sup&gt;에 업로드된 이미지만을 사용할 수 있습니다. 여기서는 미리 업로드되어 있는 &lt;code&gt;gcr.io/cloudrun/hello&lt;/code&gt; 이미지를 사용해보겠습니다. 서비스 이름은 &lt;code&gt;hello&lt;/code&gt;로 지정합니다. 현재 시점(2019년 4월)에 위치는 &lt;code&gt;us-central1&lt;/code&gt;만 선택할 수 있습니다. ‘인증되지 않은 호출 허용’ 체크박스를 선택해줍니다. 이제 ‘만들기’ 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e91/e91f03fc3e84ae4401d60002887646ed25c7d133b562c3d223adc32828d8a89e.m.png&quot; alt=&quot;클라우드 런 hello 서비스가 생성중입니다&quot;&gt;&lt;figcaption&gt;클라우드 런 hello 서비스가 생성중입니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;서비스를 생성하고 있습니다. 1분 이내에 &lt;code&gt;hello&lt;/code&gt; 서비스가 만들어지고, 서비스 이름 오른쪽에서 접근 가능한 URL을 확인할 수 있습니다. 이 주소를 사용하면 방금 클라우드 런으로 실행한 컨테이너에 곧바로 접속할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/edd/edd625dc0ccf2bd5b2e82c338e7fbe7abb9b8f413417bd75ce974b2e0c008ec9.m.png&quot; alt=&quot;서비스가 생성되면 URL을 확인할 수 있습니다&quot;&gt;&lt;figcaption&gt;서비스가 생성되면 URL을 확인할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;서비스의 URL에 접속해봅니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/fbc/fbc4221f5994561da1caffce83171b28c8bf07cc0922f090a80c6bd97581a3cf.m.png&quot; alt=&quot;클라우드 런으로 실행한 서비스가 정상적으로 동작하고 있습니다&quot;&gt;&lt;figcaption&gt;클라우드 런으로 실행한 서비스가 정상적으로 동작하고 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;예제 서버가 정상적으로 실행 중인 것을 확인할 수 있습니다. 도커 이미지만 준비되면 클라우드 런을 활용해 이처럼 간단하게 서비스를 실행하는 것이 가능합니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Wed, 01 May 2019 01:21:19 +0000</pubDate>
      <dc:date>2019-05-01T01:21:19+00:00</dc:date>
    </item>
    <item>
      <title>AWS 시스템 매니저 파라미터 스토어 개선 발표: 고급 파라미터 추가 및 API 처리량 증가</title>
      <link>https://www.44bits.io/ko/post/news--aws-introduces-advanced-parameter-store</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        AWS 시스템 매니저 파라미터 스토어 개선
                &lt;div class=&quot;subtitle&quot;&gt;고급 파라미터 추가 및 API 처리량 증가&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;p&gt;AWS 시스템 매니저&lt;sup&gt;AWS System Manager&lt;/sup&gt;에서는 구성 데이터 관리를 위한 매니지드 키 밸류 저장소인 파리미터 스토어&lt;sup&gt;Parameter Store&lt;/sup&gt;를 제공하고 있습니다. 4월 25일, AWS에서는 파라미터 스토어에 대한 2가지 개선 사항을 발표했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2019/04/aws_systems_manager_parameter_store_introduces_advanced_parameters/&quot;&gt;AWS 시스템 매니저 파라미터 스토어에 고급 파라미터 추가&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2019/04/aws_systems_manager_now_supports_use_of_parameter_store_at_higher_api_throughput/&quot;&gt;AWS 시스템 매니저에서 기존보다 많은 API 처리 지원&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;고급-파라미터-기능&quot;&gt;고급 파라미터 기능&lt;/h2&gt;
&lt;p&gt;유료로 제공되는 고급 파라미터&lt;sup&gt;Advanced Parameter&lt;/sup&gt;에서는 기존의 표준 파라미터&lt;sup&gt;Standard Parameter&lt;/sup&gt;보다 긴 내용을 저장할 수 있고 추가적인 기능을 제공합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/b12/b12298e224307ae7e58d4e42ca261b52ce46ea9b605181978b9bf5928ddb409d.m.png&quot; alt=&quot;파라미터 생성 화면에서 표준 파라미터와 고급 파라미터 중에 선택할 수 있습니다&quot;&gt;&lt;figcaption&gt;파라미터 생성 화면에서 표준 파라미터와 고급 파라미터 중에 선택할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;고급 파라미터는 파라미터 생성 시 선택할 수 있습니다. 표준 파라미터의 경우 최대 4KB까지만 저장할 수 있는 것과 달리 고급 파라미터로 지정하는 경우 최대 8KB까지 데이터를 저장할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e10/e1091fb9e23d8dc392bdaaf8d842195d680ee84c9c102a8198fc5f886d9c9c16.m.png&quot; alt=&quot;고급 파라미터 스토어에는 최대 8KB(8,192자)의 데이터를 저장할 수 있습니다.&quot;&gt;&lt;figcaption&gt;고급 파라미터 스토어에는 최대 8KB(8,192자)의 데이터를 저장할 수 있습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;표준 파리미터의 경우 최대 1만 개까지만 생성할 수 있었지만, 고급 파라미터의 경우는 최대 10만 개까지 생성할 수 있습니다. 이와 더불어 항목 별로 TTL과 알림 설정을 지원합니다. 항목이 만료되었거나 일정 기간 동안 값이 변하지 않으면 클라우드와치 이벤트&lt;sup&gt;CloudWatch Events&lt;/sup&gt;에 알림을 보낼 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/186/1867fed04f0dcb110c13f23c72614fdc91aa242f2c9a20b9dbcdfd52d287d631.m.png&quot; alt=&quot;고급 파라미터는 항목 별로 TTL과 알림 정책을 지원합니다&quot;&gt;&lt;figcaption&gt;고급 파라미터는 항목 별로 TTL과 알림 정책을 지원합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;표준 파라미터 스토어 항목을 고급 파라미터 스토어 항목으로 바꿀 수는 있지만, 그 반대는 불가능하므로 주의가 필요합니다. 고급 기능이 필요하지 않은 항목은 삭제한 후 표준 파라미터로 다시 생성해야 합니다.&lt;/p&gt;
&lt;p&gt;표준 파라미터는 무료인 반면, 고급 파라미터는 개당 월 $0.05만큼 요금이 발생합니다. 고급 파라미터의 정확한 비용에 대해서는 시스템 매니저의 &lt;a href=&quot;https://aws.amazon.com/systems-manager/pricing/?nc1=h_ls&quot;&gt;요금 페이지&lt;/a&gt;를 참고해주시기 바랍니다.&lt;/p&gt;
&lt;h2 id=&quot;api-처리량-증가&quot;&gt;API 처리량 증가&lt;/h2&gt;
&lt;p&gt;파라미터 스토어를 사용할 때 가장 큰 제약 중 하나가 불분명한 API 처리량이었습니다. 이제 유료로 더 높은 처리량을 지정하는 것이 가능해졌습니다. 이 기능은 파라미터 스토어 페이지의 설정&lt;sup&gt;Settings&lt;/sup&gt;에서 활성화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;API 처리량은 표준 파라미터와 고급 파라미터에 모두 적용됩니다. 더 높은 처리량을 활성화하면 초당 1천 번까지 API 요청을 보낼 수 있습니다. 기본적으로 파리미터 스토어는 저장 및 API 요청이 모두 무료입니다. 하지만 이 기능을 활성화하면 1만 건의 API 호출당 $0.05의 요금이 발생합니다. 이에 대한 정확한 비용에 대해서는 시스템 매니저의 &lt;a href=&quot;https://aws.amazon.com/systems-manager/pricing/?nc1=h_ls&quot;&gt;요금 페이지&lt;/a&gt;를 참고해주시기 바랍니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Tue, 30 Apr 2019 06:19:51 +0000</pubDate>
      <dc:date>2019-04-30T06:19:51+00:00</dc:date>
    </item>
    <item>
      <title>4월 25일, 도커 허브(Docker Hub) 계정 정보 유출: 비밀번호 변경 등 조치 필요</title>
      <link>https://www.44bits.io/ko/post/news--docker-found-unauthorized-access-to-docker-hub-database</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        4월 25일, 도커 허브 계정 정보 유출
                &lt;div class=&quot;subtitle&quot;&gt;19만개의 계정 정보 유출되었을 가능성, 비밀번호 변경 등 조치 필요&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/fa2/fa204630bed1deaf4e18a19a180f885934b613c6293584180ef1412fe8ed5283.m.png&quot; alt=&quot;도커 허브 로고&quot;&gt;&lt;figcaption&gt;도커 허브 로고&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;도커&lt;sup&gt;Docker&lt;/sup&gt;사는 2019년 4월 25일, 도커 허브&lt;sup&gt;Docker Hub&lt;/sup&gt; 데이터베이스에 허가되지 않은 접근을 발견하고 바로 보안 조치를 취했다고 밝혔습니다.&lt;/p&gt;
&lt;p&gt;도커 허브 데이터베이스에 허가되지 않은 접근으로 인해 19만개의 계정의 중요 정보가 노출 되었을 우려가 있습니다. 누출 우려가 있는 중요 정보에는 깃허브&lt;sup&gt;GitHub&lt;/sup&gt;, 빗버킷&lt;sup&gt;BitBucket&lt;/sup&gt; 인증 토큰과 도커 허브 사용자 이름, 해시된 비밀번호가 포함됩니다.&lt;/p&gt;
&lt;p&gt;또한 보안을 위해 사용자들이 &lt;a href=&quot;https://success.docker.com/article/docker-hub-user-notification&quot;&gt;다음 조치들을 적용할 것을 권고&lt;/a&gt;했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도커 허브 비밀번호 변경 및 동일한 비밀번호를 사용하는 다른 사이트의 비밀번호 변경&lt;/li&gt;
&lt;li&gt;자동 빌드를 위해 깃헙 및 빗버킷을 연동한 경우 부적절한 접근이 있었는지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/0eb/0ebd21fcbeca814fc06074fb16bc39e3aacf8f60deb7347585e67f8e42007157.m.png&quot; alt=&quot;Docker에서 사용자에게 보낸 이메일 중 일부&quot;&gt;&lt;figcaption&gt;Docker에서 사용자에게 보낸 이메일 중 일부&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 사건에 대한 자세한 내용은 도커 사의 기사를 참고하시기 바랍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://success.docker.com/article/docker-hub-user-notification&quot;&gt;Docker - Unauthorized access to Docker Hub database&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Tue, 30 Apr 2019 01:17:57 +0000</pubDate>
      <dc:date>2019-04-30T01:17:57+00:00</dc:date>
    </item>
    <item>
      <title>AWS RDS for PostgreSQL에서 S3 데이터 임포트 기능 지원</title>
      <link>https://www.44bits.io/ko/post/news--aws-rds-postgresql-supports-data-import-from-s3</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        AWS RDS for PostgreSQL에서 S3 데이터 임포트 기능 지원
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;4월 24일 아마존 웹 서비스&lt;sup&gt;AWS, Amazon Web Service&lt;/sup&gt;에서는 아마존 S3&lt;sup&gt;Amazon S3&lt;/sup&gt;에 있는 데이터를 &lt;a href=&quot;https://aws.amazon.com/ko/rds/postgresql/&quot;&gt;Amazon RDS for PostgreSQL&lt;/a&gt;에 가져오는(import) 기능을 &lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2019/04/amazon-rds-postgresql-supports-data-import-from-amazon-s3/&quot;&gt;발표했습니다&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;이 기능은 aws_s3의 확장 기능(Extension)을 이용합니다. 내부적으로 PostgreSQL의 &lt;a href=&quot;https://www.postgresql.org/docs/current/sql-copy.html&quot;&gt;COPY&lt;/a&gt; 명령어를 사용하므로 PostgreSQL 11.1 이상 버전에서만 사용할 수 있으며, 지원하는 데이터 포맷은 text, csv, binary입니다.&lt;/p&gt;
&lt;p&gt;다음은 S3에 저장된 CSV 데이터를 PostgreSQL에 가져오는 예시입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT aws_s3.table_import_from_s3(
   '44bits_table',
   '', 
   '(format csv)',
   aws_commons.create_s3_uri('44bitsBucket', 'sample.csv', 'ap-northeast-2')
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;S3 데이터를 PostgreSQL에 추가하는 자세한 내용은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/USER_PostgreSQL.S3Import.html&quot;&gt;아마존 공식 문서&lt;/a&gt;를 참고하기 바랍니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Fri, 26 Apr 2019 05:17:57 +0000</pubDate>
      <dc:date>2019-04-26T05:17:57+00:00</dc:date>
    </item>
    <item>
      <title>아마존 웹 서비스(AWS), 아시아 태평양 지역에 홍콩 리전(ap-east-1)을 새롭게 추가</title>
      <link>https://www.44bits.io/ko/post/news--aws-announced-new-hongkong-region</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        AWS, 아시아 태평양 지역에 홍콩 리전을 새롭게 추가
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;p&gt;아마존 웹 서비스&lt;sup&gt;Amazon Web Service&lt;/sup&gt;는 아시아 태평양 지역에 홍콩 리전(Region)을 추가했다고 발표 했습니다. 홍콩 리전은 코드 이름이 &lt;code&gt;ap-east-1&lt;/code&gt;이며, 전세계적으로 스물한 번째, 아시아 태평양 지역에서는 여덟 번째로 추가되었습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/1f4/1f41cf7b80a746357bb481666b67255b704663abbbc037cae7d53b92f08748b8.m.png&quot; alt=&quot;리전 목록에서 홍콩 리전을 확인할 수 있습니다&quot;&gt;&lt;figcaption&gt;리전 목록에서 홍콩 리전을 확인할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;홍콩 리전은 세 개의 가용 영역으로 구성되어 있습니다. 가격은 EC2 m5.large 2019년 4월 25일 현재 온디맨드 기준으로 시간당 $0.132이며, 이는 서울($0.118), 도쿄($0.124), 싱가포르($0.12) 리전에 비해 다소 비싼 편입니다. 홍콩 리전에서 사용 가능한 서비스 목록은 아직 공개되지 않았지만, AWS 공식 블로그에 따르면 Amazon EC2, Amazon S3, Amazon RDS가 가능하다고 합니다. 이 외에도 AWS의 기반이 되는 서비스들은 대부분 이용이 가능하지만 EFS나 EKS와 같은 서비스들은 현재 지원하고 있지 않습니다.&lt;/p&gt;
&lt;p&gt;홍콩 리전은 다른 리전들과 달리 기본적으로 활성화되어있지 않습니다. 따라서 이 리전을 사용하고자 한다면 먼저 활성화(Enable)를 해야 합니다. 리전 목록에서 홍콩 리전을 선택하면 다음과 같은 안내 메시지가 나타납니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/2b4/2b46be960aef68c1139ea3c43a33c130b06d78adb604a0c4c0e729ac06dcfc25.m.png&quot; alt=&quot;홍콩 리전을 선택하면 리전 활성화에 대한 안내가 나옵니다&quot;&gt;&lt;figcaption&gt;홍콩 리전을 선택하면 리전 활성화에 대한 안내가 나옵니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;계속(Continue) 버튼을 누르면 계정 설정(결제) 페이지로 이동합니다. 여기서 홍콩 리전을 활성화할 수 있습니다. 홍콩 리전 옆의 활성화(Enable) 링크를 클릭합니다. 리전을 활성화하는 작업은 계정 별로 6시간에서 9시간 정도가 걸리며 활성화 자체에 대한 비용은 없습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/019/019dbeae2aa051a9d61ab3f58ba9511d4f874a3b390d3d005ec59173bb4300cf.m.png&quot; alt=&quot;계정 설정 페이지에서 홍콩 리전을 활성화할 수 있습니다&quot;&gt;&lt;figcaption&gt;계정 설정 페이지에서 홍콩 리전을 활성화할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;홍콩 리전 발표에 대한 공식 정보는 AWS 공식 발표와 블로그를 참고해주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2019/04/announcing-the-aws-asia-pacific-hong-kong-region/&quot;&gt;AWS 아시아 태평양(홍콩) 리전 발표 | AWS What’s new&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/aws/now-open-aws-asia-pacific-hong-kong-region/&quot;&gt;Now Open – AWS Asia Pacific (Hong Kong) Region | AWS News Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Fri, 26 Apr 2019 00:32:06 +0000</pubDate>
      <dc:date>2019-04-26T00:32:06+00:00</dc:date>
    </item>
    <item>
      <title>CNCF, Fluentd 프로젝트 졸업을 발표</title>
      <link>https://www.44bits.io/ko/post/news--fluentd-has-graduated-cncf</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        CNCF, Fluentd 프로젝트 졸업을 발표
                &lt;/h1&gt;
      &lt;/header&gt;
                  &lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/542/5426c791bae7a0d83ac03fe3ed2a161ebb9e642d1e3748d396c56d0b23836860.m.png&quot; alt=&quot;Fluentd가 CNCF 졸업 단계 프로젝트가 되었습니다.&quot;&gt;&lt;figcaption&gt;Fluentd가 CNCF 졸업 단계 프로젝트가 되었습니다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;!--- 리드 --&gt;
&lt;p&gt;클라우드 네이티브 컴퓨팅 파운데이션&lt;sup&gt;CNCF, Cloud Native Computing Foundation&lt;/sup&gt;은 지난 4월 11일 Fluentd가 졸업(Graduated) 단계 프로젝트가 되었다고 발표했습니다. 이로써 오픈소스 로깅 프로젝트인 &lt;a href=&quot;https://www.fluentd.org/&quot;&gt;Fluentd&lt;/a&gt;는 CNCF 프로젝트 중에 쿠버네티스&lt;sup&gt;Kubernetes&lt;/sup&gt;, 프로메테우스&lt;sup&gt;Prometheus&lt;/sup&gt;, 엔보이&lt;sup&gt;Envoy&lt;/sup&gt;, 코어DNS&lt;sup&gt;CoreDNS&lt;/sup&gt;, 컨테이너d&lt;sup&gt;containerd&lt;/sup&gt;에 이은 여섯 번째 졸업 단계 프로젝트가 되었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cncf.io/announcement/2019/04/11/cncf-announces-fluentd-graduation/&quot;&gt;CNCF 블로그 - 클라우드 네이티브 컴퓨팅 파운데이션에서 Fluentd의 졸업을 발표&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fluentd.org/blog/fluentd-cncf-graduation&quot;&gt;Fluentd 블로그 - Fluentd가 졸업했습니다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--- Fluentd에 대한 간단한 설명 --&gt;
&lt;p&gt;Fluentd는 2011년 통합된 로깅 레이어를 제공하려는 목적으로 개발된 프로젝트입니다. 여러 형식의 로그를 수집하여 다양한 형태로 변환 및 전송할 수 있는 도구로 아마존 웹 서비스&lt;sup&gt;Amazon Web Service&lt;/sup&gt;, 마이크로소프트&lt;sup&gt;Microsoft&lt;/sup&gt;, 아틀라시안&lt;sup&gt;Atlassian&lt;/sup&gt; 같은 큰 규모의 회사들에서도 사용하고 있습니다. 예를 들어 JSON 형태의 로그를 실시간으로 읽어 CSV로 변환한다거나 엘라스틱서치&lt;sup&gt;ElasticSearch&lt;/sup&gt;, 구글 빅쿼리&lt;sup&gt;Google BigQuery&lt;/sup&gt;, 아마존 S3&lt;sup&gt;Amazon S3&lt;/sup&gt; 등으로 전송할 수 있습니다. 또한 중간 단계에서 필요에 따라 로그를 조작하거나 다른 곳으로 전송하는 것도 가능합니다.&lt;/p&gt;
&lt;p&gt;Fluentd는 루비 프로젝트로 이를 사용하려면 루비 환경이 필요했습니다. td-agent 패키지를 사용하면 루비 환경을 직접 구축할 필요 없이 Fluentd를 사용할 수 있습니다. 다음은 우분투 환경에서 Fluentd를 설치하는 예시입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -L https://toolbelt.treasuredata.com/sh/install-ubuntu-bionic-td-agent3.sh | sh&lt;/code&gt;&lt;/pre&gt;
&lt;!-- CNCF 프로젝트 성숙도에 대한 간단한 설명 --&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/dea/deaa1d739e2ce49bceb3e08b68e3bc89544f108cbd7e6bb64163219d62a1a208.m.png&quot; alt=&quot;CNCF 프로젝트의 성숙도 수준은 샌드박스, 인큐베이팅, 졸업 단계로 나누어집니다&quot;&gt;&lt;figcaption&gt;CNCF 프로젝트의 성숙도 수준은 샌드박스, 인큐베이팅, 졸업 단계로 나누어집니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;CNCF에서는 프로젝트를 성숙도에 따라서 샌드박스 단계, 인큐베이팅 단계, 졸업 단계로 나눕니다. Fluentd는 원래 &lt;a href=&quot;https://www.treasuredata.com/&quot;&gt;트레저 데이터&lt;sup&gt;Treasure Data&lt;/sup&gt;&lt;/a&gt;에서 개발하던 프로젝트로, 2016년 비영리 재단인 CNCF에 합류했습니다. 이번 발표로 2019년 4월 졸업 단계 프로젝트가 되었습니다. 졸업 수준은 가장 높은 성숙도 수준으로, 이 단계의 프로젝트는 당장 프로덕션에 도입 가능한 정도의 성숙도를 가졌다고 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;프로젝트의 성숙도는 CNCF 위원회 멤버들에 의해서 결정됩니다. 졸업 단계의 프로젝트가 되기 위해서는 졸업 요건을 갖추고 위원회 멤버 과반수 이상의 찬성표를 받아야 합니다. CNCF 프로젝트의 진행 과정에 대한 보다 자세한 내용은 다음 문서들을 참고하시기 바랍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cncf/toc#projects&quot;&gt;cncf/toc: Technical Oversight Committee (TOC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&quot;&gt;toc/graduation_criteria.adoc at master · cncf/toc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>44bits</author>
      <pubDate>Thu, 25 Apr 2019 01:44:42 +0000</pubDate>
      <dc:date>2019-04-25T01:44:42+00:00</dc:date>
    </item>
    <item>
      <title>장고(Django) 2.2 LTS 릴리스와 주요 변경 사항</title>
      <link>https://www.44bits.io/ko/post/django-2-2-release-note-summary</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        Django 2.2 LTS 릴리스와 주요 변경 사항
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;p&gt;Django 2.2가 드디어 출시되었습니다. 2.x 버전으로는 첫 LTS&lt;sup&gt;Long-term Support Release&lt;/sup&gt;입니다. 이 글에서는 Django 2.2에 추가된 기능과 바뀐 점을 알아보려 합니다. &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/releases/2.2/&quot;&gt;Django 2.2 공식 릴리스 노트&lt;/a&gt; 를 참고하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의! 개인적으로 판단하기에 사소한 사항들은 번역하지 않았고, 릴리스 노트만으로 이해하기가 어려운 기능엔 설명을 조금 보태었습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;파이썬-호환성&quot;&gt;파이썬 호환성&lt;/h2&gt;
&lt;p&gt;Django 2.2는 파이썬&lt;sup&gt;Python&lt;/sup&gt; 3.5, 3.6, 3.7에서 작동합니다. 각 버전별 마지막 릴리스를 사용하기를 추천합니다.&lt;/p&gt;
&lt;h2 id=&quot;새-기능&quot;&gt;새 기능&lt;/h2&gt;
&lt;h3 id=&quot;모델-제약-조건인-checkconstraint와-uniqueconstraint&quot;&gt;모델 제약 조건인 CheckConstraint와 UniqueConstraint&lt;/h3&gt;
&lt;p&gt;모델의 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/options/#django.db.models.Options.constraints&quot;&gt;Meta.contraints&lt;/a&gt; 옵션에 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/constraints/#django.db.models.CheckConstraint&quot;&gt;CheckConstraint&lt;/a&gt;와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/constraints/#django.db.models.UniqueConstraint&quot;&gt;UniqueConstraint&lt;/a&gt;를 사용하여, 데이터베이스 제약 조건을 추가할 수 있습니다. 예를 들어 여덟 자 이하로는 비밀번호를 저장하지 않으려고 한다면,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomUser(models.Model):&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;    password &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField()&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;        constraints &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-5&quot; data-line-number=&quot;5&quot;&gt;            models.CheckConstraint(check&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.Q(password__gte&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;), name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'password_should_longer_than_8'&lt;/span&gt;),&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-6&quot; data-line-number=&quot;6&quot;&gt;        ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;사소한-변경&quot;&gt;사소한 변경&lt;/h2&gt;
&lt;h3 id=&quot;django.contrib.admin&quot;&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/admin/#module-django.contrib.admin&quot;&gt;django.contrib.admin&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/admin/#django.contrib.admin.TabularInline&quot;&gt;TabularInline&lt;/a&gt;의 컬럼 헤더에 CSS 클래스를 추가할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;django.contrib.auth&quot;&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/auth/#module-django.contrib.auth&quot;&gt;django.contrib.auth&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/auth/#django.contrib.auth.backends.RemoteUserBackend.configure_user&quot;&gt;RemoteUserBackend.configure_user()&lt;/a&gt;의 첫 번째 인자로 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/request-response/#django.http.HttpRequest&quot;&gt;HttpRequest&lt;/a&gt; 객체를 전달할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;django.contrib.postgres&quot;&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/postgres/#module-django.contrib.postgres&quot;&gt;django.contrib.postgres&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/postgres/aggregates/#django.contrib.postgres.aggregates.ArrayAgg&quot;&gt;ArrayAgg&lt;/a&gt;와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/postgres/aggregates/#django.contrib.postgres.aggregates.StringAgg&quot;&gt;StringAgg&lt;/a&gt;를 사용하면서 애그리게이트 객체의 순서를 결정하기 위해 &lt;code&gt;ordering&lt;/code&gt; 인자를 지정할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;django.contrib.staticfiles&quot;&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/staticfiles/#module-django.contrib.staticfiles&quot;&gt;django.contrib.staticfiles&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/staticfiles/#cmdoption-collectstatic-ignore&quot;&gt;collectstatic –ignore&lt;/a&gt; 옵션에 &lt;code&gt;/vender/*.js&lt;/code&gt; 같은 패턴을 추가할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;데이터베이스-백엔드&quot;&gt;데이터베이스 백엔드&lt;/h3&gt;
&lt;p&gt;SQLite에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/querysets/#django.db.models.query.QuerySet.iterator&quot;&gt;QuerySet.iterator()&lt;/a&gt;를 실행해도 결과를 일부분씩만 얻을 수 있습니다. (다른 데이터베이스에 대해서는 이미 지원하던 기능인데, 이번에 SQLite에 대해서도 지원하기 시작했습니다.)&lt;/p&gt;
&lt;h3 id=&quot;제네릭-뷰&quot;&gt;제네릭 뷰&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/class-based-views/base/#django.views.generic.base.View.dispatch&quot;&gt;dispatch()&lt;/a&gt; 전에 뷰 속성을 초기화하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/class-based-views/base/#django.views.generic.base.View.setup&quot;&gt;View.setup&lt;/a&gt; 훅이 추가되었습니다.&lt;/p&gt;
&lt;h3 id=&quot;국제화&quot;&gt;국제화&lt;/h3&gt;
&lt;p&gt;아르메니아 언어&lt;sup&gt;հայերեն&lt;/sup&gt; 에 대한 지원과 번역이 추가되었습니다.&lt;/p&gt;
&lt;h3 id=&quot;관리용-명령어&quot;&gt;관리용 명령어&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#cmdoption-force-color&quot;&gt;–force-color&lt;/a&gt; 옵션을 사용하면 실행 결과에 색이 입혀집니다.&lt;/li&gt;
&lt;li&gt;PostgreSQL에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#django-admin-inspectdb&quot;&gt;inspectdb&lt;/a&gt; 명령을 사용하면 외래 테이블&lt;sup&gt;foreign tables&lt;/sup&gt;용 모델도 생성해줍니다.&lt;/li&gt;
&lt;li&gt;오라클과 PostgreSQL에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#cmdoption-inspectdb-include-views&quot;&gt;inspectdb –include-views&lt;/a&gt; 명령을 사용하면, 데이터베이스의 뷰에 대해서도 모델을 생성해줍니다.&lt;/li&gt;
&lt;li&gt;PostgreSQL에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#cmdoption-inspectdb-include-partitions&quot;&gt;inspectdb –include-partitions&lt;/a&gt; 명령을 사용하면, 파티션 테이블용 모델을 생성해줍니다.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#django-admin-inspectdb&quot;&gt;inspectdb&lt;/a&gt; 명령이 오라클과 PostgreSQL에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/fields/#django.db.models.DurationField&quot;&gt;DurationField&lt;/a&gt;를, SQLite에서 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/fields/#django.db.models.AutoField&quot;&gt;AutoField&lt;/a&gt;를 인식합니다.&lt;/li&gt;
&lt;li&gt;리눅스나 맥OS에서 &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;Watchman&lt;/a&gt;과 &lt;a href=&quot;https://pypi.org/project/pywatchman/&quot;&gt;pywatchman&lt;/a&gt; 라이브러리를 사용하여, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#django-admin-runserver&quot;&gt;runserver&lt;/a&gt; 명령의 파일 변경 감시 성능을 높였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;마이그레이션&quot;&gt;마이그레이션&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;마이그레이션 명령이 실행할 내용을 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/django-admin/#cmdoption-migrate-plan&quot;&gt;&lt;code&gt;migrate --plan&lt;/code&gt;&lt;/a&gt; 명령으로 미리 볼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;./manage.py&lt;/span&gt; migrate --plan&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Planned&lt;/span&gt; operations:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;contenttypes.0001_initial&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-4&quot; data-line-number=&quot;4&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model ContentType&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; unique_together for contenttype (1 constraint(s))&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0001_initial&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-7&quot; data-line-number=&quot;7&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model Permission&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-8&quot; data-line-number=&quot;8&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model Group&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-9&quot; data-line-number=&quot;9&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model User&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-10&quot; data-line-number=&quot;10&quot;&gt;&lt;span class=&quot;ex&quot;&gt;admin.0001_initial&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-11&quot; data-line-number=&quot;11&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model LogEntry&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-12&quot; data-line-number=&quot;12&quot;&gt;&lt;span class=&quot;ex&quot;&gt;admin.0002_logentry_remove_auto_add&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-13&quot; data-line-number=&quot;13&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field action_time on logentry&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-14&quot; data-line-number=&quot;14&quot;&gt;&lt;span class=&quot;ex&quot;&gt;admin.0003_logentry_add_action_flag_choices&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-15&quot; data-line-number=&quot;15&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field action_flag on logentry&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-16&quot; data-line-number=&quot;16&quot;&gt;&lt;span class=&quot;ex&quot;&gt;contenttypes.0002_remove_content_type_name&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-17&quot; data-line-number=&quot;17&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Change&lt;/span&gt; Meta options on contenttype&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-18&quot; data-line-number=&quot;18&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field name on contenttype&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-19&quot; data-line-number=&quot;19&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Raw&lt;/span&gt; Python operation -&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; IRREVERSIBLE&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-20&quot; data-line-number=&quot;20&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Remove&lt;/span&gt; field name from contenttype&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-21&quot; data-line-number=&quot;21&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0002_alter_permission_name_max_length&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-22&quot; data-line-number=&quot;22&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field name on permission&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-23&quot; data-line-number=&quot;23&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0003_alter_user_email_max_length&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-24&quot; data-line-number=&quot;24&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field email on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-25&quot; data-line-number=&quot;25&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0004_alter_user_username_opts&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-26&quot; data-line-number=&quot;26&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field username on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-27&quot; data-line-number=&quot;27&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0005_alter_user_last_login_null&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-28&quot; data-line-number=&quot;28&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field last_login on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-29&quot; data-line-number=&quot;29&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0006_require_contenttypes_0002&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-30&quot; data-line-number=&quot;30&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0007_alter_validators_add_error_messages&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-31&quot; data-line-number=&quot;31&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field username on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-32&quot; data-line-number=&quot;32&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0008_alter_user_username_max_length&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-33&quot; data-line-number=&quot;33&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field username on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-34&quot; data-line-number=&quot;34&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0009_alter_user_last_name_max_length&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-35&quot; data-line-number=&quot;35&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field last_name on user&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-36&quot; data-line-number=&quot;36&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0010_alter_group_name_max_length&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-37&quot; data-line-number=&quot;37&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Alter&lt;/span&gt; field name on group&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-38&quot; data-line-number=&quot;38&quot;&gt;&lt;span class=&quot;ex&quot;&gt;auth.0011_update_proxy_permissions&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-39&quot; data-line-number=&quot;39&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Raw&lt;/span&gt; Python operation -&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;     Update the content_type of prox…&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-40&quot; data-line-number=&quot;40&quot;&gt;&lt;span class=&quot;ex&quot;&gt;sessions.0001_initial&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-41&quot; data-line-number=&quot;41&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Create&lt;/span&gt; model Session&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;값을 특정 형태로 시리얼라이즈하고 싶다면 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/migrations/#custom-migration-serializers&quot;&gt;커스텀 시리얼라이저&lt;/a&gt;를 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;모델&quot;&gt;모델&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#django.db.models.functions.NullIf&quot;&gt;NullIf&lt;/a&gt;와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#django.db.models.functions.Reverse&quot;&gt;Reverse&lt;/a&gt; 데이터베이스 함수가 추가되었습니다. 이 외에도 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#math-functions&quot;&gt;수학 관련 데이터베이스 함수&lt;/a&gt;가 많이 추가되었습니다.
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#django.db.models.functions.NullIf&quot;&gt;NullIf&lt;/a&gt;는 두 인자가 같으면 None을 반환하고, 다르면 첫 인자를 반환합니다.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#django.db.models.functions.Reverse&quot;&gt;Reverse&lt;/a&gt;는 지정된 문자열 필드의 문자를 역순으로 반환합니다. (&lt;code&gt;reverse&lt;/code&gt;라는 값이 있었다면, &lt;code&gt;esrever&lt;/code&gt;이 반환됩니다.)&lt;/li&gt;
&lt;li&gt;수학 계산과 관련하여 절대 값을 반환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#abs&quot;&gt;Abs&lt;/a&gt;, 삼각함수 관련 함수인 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#cos&quot;&gt;Cos&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#sin&quot;&gt;Sin&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#tan&quot;&gt;Tan&lt;/a&gt; 등과, 올림 값을 반환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#ceil&quot;&gt;Ceil&lt;/a&gt;, 내림 값을 반환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#floor&quot;&gt;Floor&lt;/a&gt;, 라디안 값을 각도로 변환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#degrees&quot;&gt;Degrees&lt;/a&gt;, 로그 관련 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#log&quot;&gt;로그&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#ln&quot;&gt;자연로그&lt;/a&gt;, &lt;a href=&quot;(null)&quot;&gt;자연상수&lt;/a&gt;, 이 외에도 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#pi&quot;&gt;파이&lt;/a&gt;, 나머지를 반환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#mod&quot;&gt;Mod&lt;/a&gt; 등 엄청나게 다양한 함수들이 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;벌크로 추가하려는 데이터 중 데이터베이스 제약에 어긋나는 데이터가 있을 때, 해당 데이터를 무시할 수 있도록 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/querysets/#django.db.models.query.QuerySet.bulk_create&quot;&gt;QuerySet.bulk_create()&lt;/a&gt; 메서드에 &lt;code&gt;ignore_conflicts&lt;/code&gt; 매개변수를 전달할 수 있습니다. (기본 값은 &lt;code&gt;False&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://ko.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO-8601 표준&lt;/a&gt;에 맞춰 년도를 반환하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/database-functions/#django.db.models.functions.ExtractIsoYear&quot;&gt;ExtractIsoYear&lt;/a&gt; 가 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; datetime &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; datetime&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.utils &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; timezone&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db.models.functions &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExtractYear&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;end_2015 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; week_1_day_2014_2015 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; datetime(&lt;span class=&quot;dv&quot;&gt;2014&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, tzinfo&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;timezone.utc)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-6&quot; data-line-number=&quot;6&quot;&gt;Movie.objects.create(published_at&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;end_2015)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-7&quot; data-line-number=&quot;7&quot;&gt;Movie.objects.annotate(pub_year&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;ExtractIsoYear(&lt;span class=&quot;st&quot;&gt;'published_at'&lt;/span&gt;)).values(&lt;span class=&quot;st&quot;&gt;'pub_year'&lt;/span&gt;)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;co&quot;&gt;# [{'pub_year': 2015}]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;Model.save()&lt;/code&gt;, &lt;code&gt;QuerySet.update()&lt;/code&gt;, &lt;code&gt;Model.delete()&lt;/code&gt; 등에서 쿼리가 단 하나 실행될 때는 성능 향상을 위해 트랜젝션을 시작하지 않습니다.&lt;/li&gt;
&lt;li&gt;쿼리셋에서 애그리게이션 표현식aggregate expressions을 실행할 때 중복된 값을 제거하려면 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/expressions/#django.db.models.Aggregate.allow_distinct&quot;&gt;allow_distinct&lt;/a&gt; 매개변수를 전달할 수 있습니다. (기본 값은 &lt;code&gt;False&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;연관 모델용 메서드인 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.add&quot;&gt;RelatedManager.add()&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.create&quot;&gt;create()&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.remove&quot;&gt;remove()&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/relations/#django.db.models.fields.related.RelatedManager.set&quot;&gt;set()&lt;/a&gt; , get_or_create(), update_or_create()에서 중개 모델intermediate model을 허용합니다. &lt;code&gt;through_defaults&lt;/code&gt; 전달인자를 사용하면, 중개 모델에 특정 값을 지정할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;요청과-응답&quot;&gt;요청과 응답&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;헤더에 접근하기 편하게 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/request-response/#django.http.HttpRequest.headers&quot;&gt;HttpRequest.headers&lt;/a&gt;가 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;직렬화&quot;&gt;직렬화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;serializers.deserialize()&lt;/code&gt;에서 자연 키&lt;sup&gt;natural key&lt;/sup&gt;로 연결된 객체까지 역직렬화&lt;sup&gt;deserialize&lt;/sup&gt;하려면 &lt;code&gt;handle_forward_references=True&lt;/code&gt;를 전달하면 됩니다. (이를 가리켜 전방 참조&lt;sup&gt;forward reference&lt;/sup&gt;라고 합니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;테스트&quot;&gt;테스트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL이 같은지 확인하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.SimpleTestCase.assertURLEqual&quot;&gt;SimpleTestCase.assertURLEqual()&lt;/a&gt; 메서드가 추가되었습니다.&lt;/li&gt;
&lt;li&gt;응답이 다른 URL로 리디렉션하는지를 확인하는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.SimpleTestCase.assertRedirects&quot;&gt;assertRedirects()&lt;/a&gt;도 추가되었습니다.&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;content_type&lt;/code&gt;이 &lt;code&gt;'application/json'&lt;/code&gt;일 때 리스트나 터플이 포함된 데이터를 JSON 형태로 자동 직렬화합니다.&lt;/li&gt;
&lt;li&gt;테스트에서 참조되지 않는 데이터베이스는 구성되지 않습니다.skips the setup of databases&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;url&quot;&gt;URL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ResolverMatch 클래스에 추가된 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/urlresolvers/#django.urls.ResolverMatch.route&quot;&gt;route&lt;/a&gt; 속성에, URL 패턴의 route가 저장됩니다. 예를 들어 &lt;code&gt;path('users/&amp;lt;id&amp;gt;/', ...)&lt;/code&gt; 같은 패턴이 있다면, route에는 &lt;code&gt;'users/&amp;lt;id&amp;gt;/'&lt;/code&gt;가 저장됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;validator&quot;&gt;Validator&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/validators/#django.core.validators.MaxValueValidator&quot;&gt;MaxValueValidator&lt;/a&gt;와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/validators/#django.core.validators.MinValueValidator&quot;&gt;MinValueValidator&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/validators/#django.core.validators.MinLengthValidator&quot;&gt;MinLengthValidator&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/validators/#django.core.validators.MaxLengthValidator&quot;&gt;MaxLengthValidator&lt;/a&gt;의 &lt;code&gt;limit_value&lt;/code&gt;를 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;하위-호환이-중단된-기능&quot;&gt;하위 호환이 중단된 기능&lt;/h2&gt;
&lt;h3 id=&quot;django-admin의-actions-수집-방식&quot;&gt;Django Admin의 actions 수집 방식&lt;/h3&gt;
&lt;p&gt;Django 관리 도구의 actions에서 부모 ModelAdmin 클래스의 actions를 수집하지 않습니다. 부모 클래스의 actions까지 사용하고 싶다면 파이썬의 기본 상속 방식을 따라, 다음과 같이 해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SubAdmin(BaseAdmin):
    actions = BaseAdmin.actions + ['sub_admin_action']&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;gdal-지원&quot;&gt;GDAL 지원&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/gis/#module-django.contrib.gis&quot;&gt;Geo Django&lt;/a&gt;에서 GDAL 1.9와 1.10 지원을 중단합니다.&lt;/p&gt;
&lt;h3 id=&quot;테스트-실행시-초기화용-데이터-마이그레이션&quot;&gt;테스트 실행시 초기화용 데이터 마이그레이션&lt;/h3&gt;
&lt;p&gt;초기화용 데이터 마이그레이션 과정은 기존 데이터베이스가 삭제된 후 테스트의 마지막에 실행됩니다. 이전 버전에서는 테스트 시작 부분에 실행되었는데 이 때문에 &lt;code&gt;test --keepdb&lt;/code&gt; 옵션이 제대로 작동하지 않곤 했습니다. (기본 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.TransactionTestCase&quot;&gt;TransactionTestCase&lt;/a&gt;를 수정하지 않았다면, 여러분의 테스트 케이스에 아무런 영향을 주지 않을 겁니다.)&lt;/p&gt;
&lt;h3 id=&quot;sqlparse-라이브러리-의존성-추가&quot;&gt;sqlparse 라이브러리 의존성 추가&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sqlparse&lt;/code&gt; 라이브러리 의존성이 추가되었습니다.&lt;/p&gt;
&lt;h3 id=&quot;cached_property를-alias화하기&quot;&gt;cached_property를 alias화하기&lt;/h3&gt;
&lt;p&gt;일반적인 방식으로는 &lt;code&gt;cached_property&lt;/code&gt;를 alias화할 수 없습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Sample:
    @cached_property
    def method_name(self):
        return ...
    m_name = method_name&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;대신, 이렇게 할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import operator

class Sample:
    @cached_property
    def method_name(self):
        return ...

    m_nmae = property(operator.attrgetter('method_name'))&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;프록시-모델의-권한&quot;&gt;프록시 모델의 권한&lt;/h3&gt;
&lt;p&gt;이전 버전에서는 프록시 모델에 권한을 설정하더라도, (프록시 모델이 아닌) 구체concrete 모델의 content type이 생성되었습니다. 이제부터는 프록시 모델은 권한을 상속받지 않습니다. 따라서, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/auth/default/#proxy-models-permissions-topic&quot;&gt;프록시 모델에 자체적인 권한&lt;/a&gt;을 설정하면 프록시 모델의 content type이 생성됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal(models.Model):
    class Meta:
        permissions = (('can_sleep', 'Can sleep'))

class Cat(Animal):
    class Meta:
        proxy = True
        permissions = (('can knead', 'Can knead'))

&amp;gt;&amp;gt;&amp;gt; content_type = ContentType.objects.get_for_model(Cat, for_concrete_model=False)
&amp;gt;&amp;gt;&amp;gt; cat_permissions = Permission.objects.filter(content_type=content_type)
&amp;gt;&amp;gt;&amp;gt; [perm.codename for perm in cat_permissions]
['add_cat', 'change_cat', 'delete_cat', 'view_cat', 'can_knead']&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;폼의-media-에셋&quot;&gt;폼의 Media 에셋&lt;/h3&gt;
&lt;p&gt;폼의 Media 에셋들을 합칠 때 위상 정렬topological sort algorithm 알고리즘을 사용합니다. 이전에 사용하던 쌍 정렬pairwise merging algorithm이 몇몇 경우에 제대로 작동하지 않았기 때문입니다. 이 변화로 인해, 의존성을 명시하지 않은 자바스크립트 파일과 CSS 파일은 제대로 정렬되지 않을 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;django.jQuery&lt;/code&gt;를 의존하는 위젯에서는 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/forms/media/#assets-as-a-static-definition&quot;&gt;폼 미디어 에셋을 정의할 때&lt;/a&gt; 반드시 &lt;code&gt;js = ['admin/js/jquery.init.js']&lt;/code&gt;를 명시해야 합니다.&lt;/p&gt;
&lt;h3 id=&quot;자잘한-변경&quot;&gt;자잘한 변경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가독성을 높이기 위해 &lt;code&gt;UUIDField&lt;/code&gt;의 값 중간에 대시가 추가됩니다. &lt;code&gt;550e8400e29b41d4a716446655440000&lt;/code&gt; 대신 &lt;code&gt;550e8400-e29b-41d4-a716-446655440000&lt;/code&gt; 처럼요.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/utils/#django.utils.text.slugify&quot;&gt;django.utils.text.slugify()&lt;/a&gt; 함수는 더이상 HTML로 출력하기에 안전한 값을 반환한다고 판단되지 않습니다&lt;sup&gt;no longer marked as HTML safe&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/templates/builtins/#std:templatefilter-urlizetrunc&quot;&gt;urlizetrunc&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/templates/builtins/#std:templatefilter-truncatechars&quot;&gt;truncatechars&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/templates/builtins/#std:templatefilter-truncatechars_html&quot;&gt;truncatechars_html&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/templates/builtins/#std:templatefilter-truncatewords&quot;&gt;truncatewords&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/templates/builtins/#std:templatefilter-truncatewords_html&quot;&gt;truncatewords_html&lt;/a&gt; 처럼 문자를 자르는 템플릿 필터를 사용하면, 마침표 문자(&lt;code&gt;.&lt;/code&gt;) 세 개 대신 말줄임 문자(&lt;code&gt;…&lt;/code&gt;) 하나가 덧붙습니다.&lt;/li&gt;
&lt;li&gt;테스트 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.Client&quot;&gt;Client&lt;/a&gt; 와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/utils/#django.utils.http.urlencode&quot;&gt;django.utils.http.urlencode()&lt;/a&gt;에서 &lt;code&gt;None&lt;/code&gt; 값을 만나면 &lt;code&gt;TypeError&lt;/code&gt; 예외를 발생시킵니다. (&lt;code&gt;None&lt;/code&gt;을 GET이나 POST 데이터로 인코딩할 수 없기 때문입니다.)&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/sitemaps/#django-admin-ping_google&quot;&gt;ping_google&lt;/a&gt; 명령에서 기본으로 &lt;code&gt;http&lt;/code&gt; 대신 &lt;code&gt;https&lt;/code&gt;를 사용합니다. 서비스에서 &lt;code&gt;http&lt;/code&gt;를 사용하는 경우를 위해 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/sitemaps/#cmdoption-ping-google-sitemap-uses-http&quot;&gt;ping_google –sitemap-uses-http&lt;/a&gt; 옵션이 추가되었습니다.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/querysets/#django.db.models.Avg&quot;&gt;Avg&lt;/a&gt; 와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/querysets/#django.db.models.StdDev&quot;&gt;StdDev&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/models/querysets/#django.db.models.Variance&quot;&gt;Variance&lt;/a&gt; 애그리게이션 함수에서 입력 값이 &lt;code&gt;Decimal&lt;/code&gt;이면 &lt;code&gt;Decimal&lt;/code&gt;형을 반환합니다. (이전에는 &lt;code&gt;float&lt;/code&gt;형을 반환)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;중단-예정인-기능&quot;&gt;중단 예정인 기능&lt;/h2&gt;
&lt;h3 id=&quot;meta.ordering이-group-by에-영향을-끼치지-않음&quot;&gt;Meta.ordering이 GROUP BY에 영향을 끼치지 않음&lt;/h3&gt;
&lt;p&gt;모델의 Meta.ordering 속성은 GROUP BY 쿼리에 영향을 끼치지 않습니다. 이런 식의 쿼리를 작성하면 &lt;code&gt;order_by()&lt;/code&gt;를 추가하라는 안내문이 나타나며, Django 3.1부터는 이런 식의 쿼리가 무시될 예정입니다.&lt;/p&gt;
&lt;h3 id=&quot;자잘한-변경-1&quot;&gt;자잘한 변경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;django.core.paginator.Paginator&lt;/code&gt;의 축약 표현이자 문서에는 없었던 &lt;code&gt;QuerySetPaginator&lt;/code&gt;가 사라질 예정입니다.&lt;/li&gt;
&lt;li&gt;postgres에서 사용하던 모델과 폼의 &lt;code&gt;FloatRangeField&lt;/code&gt;가 사라질 예정이므로, 새 이름인 &lt;code&gt;DecimalRangeField&lt;/code&gt;을 사용하세요.&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;FILE_CHARSET&lt;/code&gt; 설정 값이 사라질 예정입니다. Django 3.1부터 디스크에서 읽는 파일은 반드시 UTF-8로 인코딩되어 있어야 합니다.&lt;/li&gt;
&lt;li&gt;다루기 어려운 문제가 있는 &lt;code&gt;django.contrib.staticfiles.storage.CachedStaticFilesStorage&lt;/code&gt;가 사라질 예정입니다. &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/ref/contrib/staticfiles/#django.contrib.staticfiles.storage.ManifestStaticFilesStorage&quot;&gt;ManifestStaticFilesStorage&lt;/a&gt;나 서드파티의 클라우드 스토리지를 사용하세요.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.SimpleTestCase.allow_database_queries&quot;&gt;SimpleTestCase.allow_database_queries&lt;/a&gt;와 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.TransactionTestCase.multi_db&quot;&gt;TransactionTestCase.multi_db&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.TestCase.multi_db&quot;&gt;TestCase.multi_db&lt;/a&gt; 속성이 사라질 예정입니다. 대신 &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.SimpleTestCase.databases&quot;&gt;SimpleTestCase.databases&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.TransactionTestCase.databases&quot;&gt;TransactionTestCase.databases&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/topics/testing/tools/#django.test.TestCase.databases&quot;&gt;TestCase.databases&lt;/a&gt;를 사용하세요. 아울러, &lt;code&gt;allow_database_queries=True&lt;/code&gt;와 &lt;code&gt;multi_db=True&lt;/code&gt; 속성을 설정했었다면 &lt;code&gt;databases='__all__'&lt;/code&gt;만 설정하셔도 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요약은 여기까지입니다. 개인적으론 중요하지 않아 보여서 적지 않은 내용이 여러분에겐 더 중요할 수도 있으니, &lt;a href=&quot;https://docs.djangoproject.com/ko/2.2/releases/2.2/&quot;&gt;Django 2.2 공식 릴리스 노트&lt;/a&gt;를 꼼꼼히 살펴보시는 건 어떨까요?&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Fri, 12 Apr 2019 06:11:21 +0000</pubDate>
      <dc:date>2019-04-12T06:11:21+00:00</dc:date>
    </item>
    <item>
      <title>도커(Docker) 컴포즈를 활용하여 완벽한 개발 환경 구성하기</title>
      <link>https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        도커 컴포즈를 활용하여 완벽한 개발 환경 구성하기
                &lt;div class=&quot;subtitle&quot;&gt;컨테이너 시대의 Django 개발환경 구축하기&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;사전-학습-도커가-뭐야&quot;&gt;0 (사전 학습) 도커가 뭐야?&lt;/h2&gt;
&lt;p&gt;아직 도커&lt;sup&gt;Docker&lt;/sup&gt;를 잘 모르는 분께는 &lt;a href=&quot;https://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/&quot;&gt;도커 튜토리얼: 깐 김에 배포까지&lt;/a&gt;를 추천합니다. 도커를 왜 써야할지 설득이 필요한 분께는 &lt;a href=&quot;https://www.44bits.io/ko/post/why-should-i-use-docker-container&quot;&gt;왜 굳이 도커를 써야 하나요?&lt;/a&gt; 글을 추천합니다.&lt;/p&gt;
&lt;p&gt;그럼, 바로 본론으로 넘어갑니다.&lt;/p&gt;
&lt;h2 id=&quot;개발-환경-구성이라는-어려움&quot;&gt;1 개발 환경 구성이라는 어려움&lt;/h2&gt;
&lt;p&gt;새 프로젝트를 시작하거나 기존 프로젝트에 참여한 후 가장 먼저 하는 일은 바로, 개발 환경 구성일 겁니다. 파이썬&lt;sup&gt;Python&lt;/sup&gt;을 사용하는 프로젝트라면 보통 &lt;code&gt;pip&lt;/code&gt; 명령과 &lt;code&gt;requirements.txt&lt;/code&gt; 파일을 사용해 의존 패키지를 설치합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;pip&lt;/span&gt; install -r requirements.txt&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;거의 언제나 하나 이상의 프로젝트를 진행해야 하니까, 의존성이 섞이지 않게 &lt;a href=&quot;https://github.com/pypa/virtualenv&quot;&gt;virtualenv&lt;/a&gt;도 사용합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;virtualenv&lt;/span&gt; my-env&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;bu&quot;&gt;source&lt;/span&gt; /usr/local/bin/my-env/bin/activate&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb2-3&quot; data-line-number=&quot;3&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;pip&lt;/span&gt; install -r requirements.txt&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 프로젝트별로 의존성을 관리하더라도 문제가 없는 것은 아닙니다. 의존성 패키지를 설치하는 과정이 무사히 성공하면 좋겠지만 실제로는 다음 상황을 거의 항상 겪기 마련입니다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;패키지 설치가 막힌다(SSL, LDAP 관련).&lt;/li&gt;
&lt;li&gt;(실수가 있건 없건) 로컬 컴퓨터에 이미 존재하는 환경과 꼬였다.&lt;/li&gt;
&lt;li&gt;막상 배포를 했더니 개발 환경과 서버 환경이 같지 않아서 문제가 발생했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;보안 관련 패키지에서는 이런 식의 오류를 만납니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;pip&lt;/span&gt; install -r requirements.txt&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;build/temp.macosx-10.11-x86_64-3.5&lt;/span&gt;/_openssl.c:&lt;span class=&quot;ex&quot;&gt;400&lt;/span&gt;:10:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;fatal&lt;/span&gt; error: &lt;span class=&quot;st&quot;&gt;'openssl/aes.h'&lt;/span&gt; file not found&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;co&quot;&gt;#include &amp;lt;openssl/aes.h&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-7&quot; data-line-number=&quot;7&quot;&gt;         ^&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;ex&quot;&gt;1&lt;/span&gt; error generated.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;ex&quot;&gt;error&lt;/span&gt;: command &lt;span class=&quot;st&quot;&gt;'clang'&lt;/span&gt; failed with exit status 1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스와 관련해서는 이런 오류도 만나고요.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;ld&lt;/span&gt;: library not found for -lpq&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;collect2&lt;/span&gt;: ld returned 1 exit status&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;ld&lt;/span&gt;: library not found for -lpq&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;collect2&lt;/span&gt;: ld returned 1 exit status&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb4-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;error&lt;/span&gt;: command &lt;span class=&quot;st&quot;&gt;'clang'&lt;/span&gt; failed with exit status 1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이미지 관련 패키지는 이런 오류를 선사합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;building&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'_imaging'&lt;/span&gt; extension&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;creating&lt;/span&gt; build/temp.macosx-10.8-intel-2.7&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;creating&lt;/span&gt; build/temp.macosx-10.8-intel-2.7/libImaging&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;unable&lt;/span&gt; to execute clang: No such file or directory&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb5-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;error&lt;/span&gt;: command &lt;span class=&quot;st&quot;&gt;'clang'&lt;/span&gt; failed with exit status 1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어떤 패키지는 sudo 권한을 달라고도 하고요.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Skipping&lt;/span&gt; installation of /Library/Python/2.7/site-packages/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;virtualenvwrapper/init.py&lt;/span&gt; (namespace package)&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;copying&lt;/span&gt; virtualenvwrapper/hook_loader.py -&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; /Library/Python/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;2.7/site-packages/virtualenvwrapper&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;error&lt;/span&gt;: /Library/Python/2.7/site-packages/virtualenvwrapper:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-7&quot; data-line-number=&quot;7&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Permission&lt;/span&gt; denied&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해결책은 이런 것들입니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;bu&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;XXXXXXX=&lt;/span&gt;-xxxxxx&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;sudo&lt;/span&gt; pip install xxx  # 절대 따라하지 마세요&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb7-3&quot; data-line-number=&quot;3&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;brew&lt;/span&gt; install xxx&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론 설치가 잘 끝났어도 이런 오류를 만날 수 있죠.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ImportError: No module named xxx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;설치야 어차피 한 번만 하고 마는 것 아닌가?&lt;/code&gt;하고 생각하실 수도 있겠지만, 프로젝트에 새로운 사람이 합류하면 내가 겪었을 어려움 혹은 그 사람의 개발 환경에 따른 또다른 어려움들을 겪게 됩니다. 문서화를 잘 해두었다면 조금은 수월할 수도 있겠지만, 이미 개발 환경을 구성한 사람이라면 굳이 개발 환경 구성에 시간을 더 들일 필요가 없으니 가이드 문서는 금새 낡아버립니다. 게다가 설치 과정 외에도 신경 써야 할 요소(환경 변수, 데이터베이스 인코딩 등)가 항상 발목을 잡기 마련입니다.&lt;/p&gt;
&lt;p&gt;개발 환경 구성에 대한 문서를 계속 업데이트한다면 이런 문제가 최소화되겠지만, 상상하는 것만으로도 진이 빠지는 일인 건 분명합니다.&lt;/p&gt;
&lt;h2 id=&quot;도커로-개발-환경-구성하기&quot;&gt;2 도커로 개발 환경 구성하기&lt;/h2&gt;
&lt;p&gt;도커를 통해 여러 환경에 동일한 서버를 배포할 수 있다는 점에 주목하면, 개발 환경도 어디서나 동일하게 구성할 수 있겠다고 상상할 수 있습니다. 먼저, 간단한 웹 애플리케이션의 개발 환경을 도커로 구성해보고 불편한 점을 살펴본 후, 이를 편하게 만들어 주는 도커 컴포즈&lt;sup&gt;Docker Compose&lt;/sup&gt;로 넘어가겠습니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 도커에 익숙한 분이라면 &lt;strong&gt;도커 컴포즈로 개발 환경 구성하기&lt;/strong&gt;로 건너뛰어도 좋습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;먼저 도커 컴포즈 용 예시 프로젝트 저장소를 클론합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb9-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; clone https://github.com/raccoonyy/django-sample-for-docker-compose.git&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;도커-이미지-빌드&quot;&gt;2.1 도커 이미지 빌드&lt;/h3&gt;
&lt;p&gt;이제 프로젝트의 루트 디렉터리에서 도커 이미지를 만듭니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb10-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; build -t django-sample .&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;docker-sample&lt;/code&gt;이라는 도커 이미지가 만들어집니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb11&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; image ls &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grep&lt;/span&gt; django-sample&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb11-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django-sample&lt;/span&gt;   latest   bac627808fb8   1 minute ago   995MB&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;django-앱-컨테이너-실행&quot;&gt;2.2 Django 앱 컨테이너 실행&lt;/h3&gt;
&lt;p&gt;이제 Django 앱 컨테이너를 실행해봅시다. 다음 명령은 &lt;code&gt;django-sample&lt;/code&gt; 이미지를 컨테이너로 실행합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb12&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-2&quot; data-line-number=&quot;2&quot;&gt;    -p 8000:8000 \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-3&quot; data-line-number=&quot;3&quot;&gt;    django-sample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb12-4&quot; data-line-number=&quot;4&quot;&gt;    ./manage.py runserver 0:8000&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스가 연결되지 않았기 때문에, 마지막 부분에 이런 오류가 나타날 겁니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb13&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django.db.utils.OperationalError&lt;/span&gt;: could not connect to server: Connection refused&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-2&quot; data-line-number=&quot;2&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Is&lt;/span&gt; the server running on host &lt;span class=&quot;st&quot;&gt;&quot;localhost&quot;&lt;/span&gt; (127.0.0.1) &lt;span class=&quot;ex&quot;&gt;and&lt;/span&gt; accepting&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;TCP/IP&lt;/span&gt; connections on port 5432?&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;could&lt;/span&gt; not connect to server: Cannot assign requested address&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;Is&lt;/span&gt; the server running on host &lt;span class=&quot;st&quot;&gt;&quot;localhost&quot;&lt;/span&gt; (::1) &lt;span class=&quot;ex&quot;&gt;and&lt;/span&gt; accepting&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb13-6&quot; data-line-number=&quot;6&quot;&gt;    &lt;span class=&quot;ex&quot;&gt;TCP/IP&lt;/span&gt; connections on port 5432?&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;데이터베이스-컨테이너-실행&quot;&gt;2.3 데이터베이스 컨테이너 실행&lt;/h3&gt;
&lt;p&gt;물론 데이터베이스 서버도 도커로 실행할 수 있습니다. 터미널 창을 하나 더 열고 다음 명령을 입력해보세요.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb14&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb14-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm postgres&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 서버가 실행되었지만, 앱 개발 서버는 여전히 동작하지 않을 겁니다. 일단 두 컨테이너의 터미널 창에서 &lt;code&gt;Ctrl + C&lt;/code&gt; 키를 눌러 컨테이너를 종료하고, 이 문제를 해결해봅시다.&lt;/p&gt;
&lt;h3 id=&quot;데이터베이스-연결하기&quot;&gt;2.4 데이터베이스 연결하기&lt;/h3&gt;
&lt;p&gt;기본적으로 도커 컨테이너들은 각각 격리된 환경에서 실행됩니다. 다시 말해, 별도의 옵션을 지정하지 않으면 다른 컨테이너의 존재를 알 수 없죠. 앞에서는 앱 컨테이너에 별 옵션을 지정하지 않고 실행한 후, 데이터베이스 컨테이너를 실행했습니다. 따라서 앱 컨테이너는 PostgreSQL 컨테이너가 실행되었는지 여부를 알지 못합니다.&lt;/p&gt;
&lt;p&gt;앱 컨테이너에게 데이터베이스 컨테이너의 존재를 알려주기 위해서는 다음 과정을 거쳐야 합니다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;데이터베이스 컨테이너를 실행하면서 컨테이너 이름을 붙이고(&lt;code&gt;db&lt;/code&gt;라고 하죠),&lt;/li&gt;
&lt;li&gt;앱 컨테이너를 실행할 때 &lt;code&gt;db&lt;/code&gt; 컨테이너를 연결해 줍니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;먼저 데이터베이스 컨테이너를 실행해보죠.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb15&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-2&quot; data-line-number=&quot;2&quot;&gt;    --name db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-3&quot; data-line-number=&quot;3&quot;&gt;    -e POSTGRES_DB=djangosample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-4&quot; data-line-number=&quot;4&quot;&gt;    -e POSTGRES_USER=sampleuser \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-5&quot; data-line-number=&quot;5&quot;&gt;    -e POSTGRES_PASSWORD=samplesecret \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb15-6&quot; data-line-number=&quot;6&quot;&gt;    postgres&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;이번에는 &lt;code&gt;-it&lt;/code&gt; 옵션을 삭제하여, 컨테이너를 데몬 형태로 실행했습니다.&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--name&lt;/code&gt;: 데이터베이스 컨테이너에 &lt;code&gt;db&lt;/code&gt;라는 이름을 붙였습니다.&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;-e&lt;/code&gt;: 환경변수를 설정하여 컨테이너를 실행할 수 있습니다. 여기서는 컨테이너 시작과 함께 &lt;code&gt;djangosample&lt;/code&gt; 데이터베이스를 만들고(&lt;code&gt;POSTGRES_DB&lt;/code&gt;) &lt;code&gt;sampleuser&lt;/code&gt;라는 사용자에게 접속 권한을 부여(&lt;code&gt;POSTGRES_USER&lt;/code&gt;, &lt;code&gt;POSTGRES_PASSWORD&lt;/code&gt;)합니다. &lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; &lt;a href=&quot;https://hub.docker.com/_/postgres/&quot;&gt;도커 허브의 공식 포스트그레SQL 저장소&lt;/a&gt;에 가보면 설정할 수 있는 환경 변수 종류를 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;참고로, 여기서 설정한 사용자 이름이나 비밀번호, 데이터베이스 이름 같은 환경변수들은 &lt;code&gt;djangosample/settings.py&lt;/code&gt; 파일 안에 설정해 둔 기본값들입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;이제 앱 컨테이너를 실행하면서 &lt;code&gt;db&lt;/code&gt; 컨테이너를 연결(&lt;code&gt;link&lt;/code&gt;)해 줍시다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb16&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-2&quot; data-line-number=&quot;2&quot;&gt;    -p 8000:8000 \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-3&quot; data-line-number=&quot;3&quot;&gt;    --link db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-4&quot; data-line-number=&quot;4&quot;&gt;    -e DJANGO_DB_HOST=db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-5&quot; data-line-number=&quot;5&quot;&gt;    -e DJANGO_DEBUG=True \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-6&quot; data-line-number=&quot;6&quot;&gt;    django-sample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb16-7&quot; data-line-number=&quot;7&quot;&gt;    ./manage.py runserver 0:8000&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--link&lt;/code&gt;: 참조할 다른 컨테이너를 지정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 해서 Django 서버가 잘 실행되었다면 다음과 같은 Django 실행 화면을 볼 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/721/721c79d7eac3cfa98edda52b7a1f2a2b7374884e9446e7fbb8c492a38fd0c288.m.png&quot; alt=&quot;Django 개발 서버가 잘 실행되었습니다&quot;&gt;&lt;figcaption&gt;Django 개발 서버가 잘 실행되었습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이제 개발만 하면 될까요? 아쉽게도 그렇지 않습니다.&lt;/p&gt;
&lt;h3 id=&quot;코드-변경이-실시간으로-반영되게-하기&quot;&gt;2.5 코드 변경이 실시간으로 반영되게 하기&lt;/h3&gt;
&lt;p&gt;프로젝트의 &lt;code&gt;Dockerfile&lt;/code&gt;을 살펴보면 &lt;code&gt;ADD ./djangosample /app/djangosample/&lt;/code&gt; 부분이 존재합니다(10행). 도커 이미지가 만들어지다가 10행을 만나면 컨테이너 밖의 소스 코드가 컨테이너 속에 추가되고, 이 시점부터 컨테이너 밖의 소스 코드 변경에 영향을 받지 않습니다. 그래서, 평소 개발하듯 소스 코드를 아무리 수정하더라도 Django 개발 서버가 이를 반영하여 재시작하는 일이 발생하지 않습니다.&lt;/p&gt;
&lt;p&gt;이를 해결하고자 격리된 컨테이너에 통로를 하나 만듭니다. 수정할 소스 코드의 디렉터리를 앱 컨테이너 내부의 소스 코드와 연결하여, 코드를 바꿀 때마다 컨테이너 속 코드도 바뀌게 해보겠습니다. &lt;code&gt;Ctrl + C&lt;/code&gt; 키를 눌러 앱 컨테이너를 종료한 후, 다음 명령어를 실행합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb17&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-2&quot; data-line-number=&quot;2&quot;&gt;    -p 8000:8000 \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-3&quot; data-line-number=&quot;3&quot;&gt;    --link db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-4&quot; data-line-number=&quot;4&quot;&gt;    -e DJANGO_DB_HOST=db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-5&quot; data-line-number=&quot;5&quot;&gt;    -e DJANGO_DEBUG=True \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-6&quot; data-line-number=&quot;6&quot;&gt;    --volume=&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;:/app/ \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-7&quot; data-line-number=&quot;7&quot;&gt;    django-sample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-8&quot; data-line-number=&quot;8&quot;&gt;    ./manage.py runserver 0:8000&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--volume&lt;/code&gt;: 이 옵션을 사용하여 로컬 디렉터리의 특정 경로를 컨테이너 내부로 마운트할 수 있습니다. (&lt;code&gt;$(pwd)&lt;/code&gt;는 이 명령을 실행하는 현재 디렉터리의 절대 경로입니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 마지막 문제가 남았습니다. 현재 상태에서 &lt;code&gt;Ctrl + C&lt;/code&gt; 키를 눌러 앱 컨테이너를 종료하고, &lt;code&gt;docker stop db&lt;/code&gt; 명령을 사용해 데이터베이스 컨테이너도 종료해봅시다. 개발하면서 만들었던 데이터들은 다 어떻게 될까요?&lt;/p&gt;
&lt;h3 id=&quot;데이터베이스-데이터를-보존하기&quot;&gt;2.6 데이터베이스 데이터를 보존하기&lt;/h3&gt;
&lt;p&gt;앞에서 데이터베이스 컨테이너를 실행하면서 &lt;code&gt;--rm&lt;/code&gt; 옵션을 지정했는데요. 이렇게 하면 데이터베이스 컨테이너가 종료와 함께 삭제되면서 컨테이너 내부에 쌓였던 데이터베이스 데이터들도 모두 사라집니다. 깔끔해서 좋긴 하지만 개발용 데이터를 매번 쌓기가 귀찮은 경우도 있습니다.&lt;/p&gt;
&lt;p&gt;데이터베이스가 데이터를 저장할 때 파일 시스템을 사용한다는 점을 생각해보면, 이를 해결할 때도 역시 &lt;code&gt;--volume&lt;/code&gt; 옵션을 사용할 수 있습니다. 다음 명령을 살펴봅시다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb18&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; -p ./docker/data&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-3&quot; data-line-number=&quot;3&quot;&gt;    --name db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-4&quot; data-line-number=&quot;4&quot;&gt;    -e POSTGRES_DB=djangosample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-5&quot; data-line-number=&quot;5&quot;&gt;    -e POSTGRES_USER=sampleuser \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-6&quot; data-line-number=&quot;6&quot;&gt;    -e POSTGRES_PASSWORD=samplesecret \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-7&quot; data-line-number=&quot;7&quot;&gt;    --volume=&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;/docker/data:/var/lib/postgresql/data \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb18-8&quot; data-line-number=&quot;8&quot;&gt;    postgres:&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--volume&lt;/code&gt;: 데이터베이스 컨테이너 내부의 디렉터리(&lt;code&gt;/var/lib/postgresql/data&lt;/code&gt;)를 로컬 컴퓨터의 디렉터리(&lt;code&gt;$(pwd)/docker/data&lt;/code&gt;)로 연결하였습니다. 이제 데이터베이스가 데이터를 저장할 파일 시스템으로 로컬 컴퓨터의 &lt;code&gt;$(pwd)/docker/data&lt;/code&gt; 디렉터리를 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;순서를-맞춰-컨테이너-재실행하기&quot;&gt;2.7 순서를 맞춰 컨테이너 재실행하기&lt;/h3&gt;
&lt;p&gt;이제 컨테이너들을 실행하는 &lt;code&gt;run&lt;/code&gt; 명령어는 모두 완성되었으니, 모든 컨테이너를 종료한 후 순서를 맞춰 컨테이너들을 재시작해봅시다.&lt;/p&gt;
&lt;p&gt;데이터베이스 컨테이너를 실행하고,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb19&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-2&quot; data-line-number=&quot;2&quot;&gt;    --name db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-3&quot; data-line-number=&quot;3&quot;&gt;    -e POSTGRES_DB=djangosample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-4&quot; data-line-number=&quot;4&quot;&gt;    -e POSTGRES_USER=sampleuser \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-5&quot; data-line-number=&quot;5&quot;&gt;    -e POSTGRES_PASSWORD=samplesecret \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-6&quot; data-line-number=&quot;6&quot;&gt;    --volume=&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;/docker/data:/var/lib/postgresql/data \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb19-7&quot; data-line-number=&quot;7&quot;&gt;    postgres&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;새 터미널 창에서 앱 컨테이너를 실행합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb20&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; run -it --rm \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-2&quot; data-line-number=&quot;2&quot;&gt;    -p 8000:8000 \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-3&quot; data-line-number=&quot;3&quot;&gt;    --link db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-4&quot; data-line-number=&quot;4&quot;&gt;    -e DJANGO_DB_HOST=db \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-5&quot; data-line-number=&quot;5&quot;&gt;    -e DJANGO_DEBUG=True \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-6&quot; data-line-number=&quot;6&quot;&gt;    --volume=&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;:/app/ \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-7&quot; data-line-number=&quot;7&quot;&gt;    django-sample \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb20-8&quot; data-line-number=&quot;8&quot;&gt;    ./manage.py runserver 0:8000&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 Django 서버가 데이터베이스와 잘 연결되고, 소스 코드를 변경하면 개발 서버가 알아서 재시작하며, 컨테이너를 종료해도 데이터베이스에 쌓인 데이터가 사라지지 않습니다.&lt;/p&gt;
&lt;p&gt;그런데 개발에 앞서 매번 이 명령어들을 입력한다고 생각해보면… 그리 유쾌하진 않겠죠?&lt;/p&gt;
&lt;h3 id=&quot;도커가-별로-편하진-않네요&quot;&gt;2.8 도커가 별로 편하진 않네요?&lt;/h3&gt;
&lt;p&gt;도커로 개발 환경을 구성하는 데 성공하긴 했지만, 몇몇 불편한 부분이 남았습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장황한 옵션&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발 서버를 실행할 때마다 장황한 도커 명령어의 옵션들을 적기가 귀찮습니다. 헷갈리기도 하고, 빼먹는 경우도 생깁니다. 옵션들을 미리 적어두고 한 번에 짜잔~! 실행하면 좋겠는데 말이죠.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앱 컨테이너와 데이터베이스 컨테이너의 실행 순서&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반드시 데이터베이스 컨테이너를 실행한 다음에 앱 컨테이너를 실행해야 합니다. 그렇지 않으면 앱 컨테이너에서 데이터베이스 컨테이너를 찾을 수 없기 때문이죠. 깜박하고 앱 컨테이너부터 실행했다면? 종료하고 데이터베이스 컨테이너 실행하고, 다시 앱 컨테이너를 실행하는 불편함이 있죠.&lt;/p&gt;
&lt;h2 id=&quot;도커-컴포즈로-개발-환경-구성하기&quot;&gt;3 도커 컴포즈로 개발 환경 구성하기&lt;/h2&gt;
&lt;p&gt;실행하기 불편하다는 이유로 도커를 포기하기에는 환경 독립성이 주는 장점이 너무 컸나봅니다. 도커가 출시된지 얼마 지나지 않아 독립된 개발 환경을 빠르게 구성할 수 있는 &lt;a href=&quot;http://www.fig.sh/&quot;&gt;피그&lt;sup&gt;Fig&lt;/sup&gt; 프로젝트&lt;/a&gt;가 선보였습니다. 이때만 해도 도커 명령을 실행하는 서드파티 같은 도구였으나 피그가 인기를 얻자, 도커에서는 피그 프로젝트를 흡수하여 &lt;a href=&quot;https://blog.docker.com/2015/02/announcing-docker-compose/&quot;&gt;도커 컴포즈&lt;sup&gt;Docker Compose&lt;/sup&gt;라는 이름의 도구로 만들어버립니다&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;도커 컴포즈를 사용하면 컨테이너 실행에 필요한 옵션을 &lt;code&gt;docker-compose.yml&lt;/code&gt;이라는 파일에 적어둘 수 있고, 컨테이너 간 실행 순서나 의존성도 관리할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;선행-조건&quot;&gt;3.1 선행 조건&lt;/h3&gt;
&lt;p&gt;이후의 과정을 따라하려면, 도커 엔진의 버전이 1.13.1 이상이어야 하고, 도커 컴포즈의 버전은 1.6.0 이상이어야 합니다. 최근에 도커를 설치했다면 큰 문제가 없을 겁니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 만들어 봅시다.&lt;/p&gt;
&lt;h3 id=&quot;docker-compose.yml-파일&quot;&gt;3.2 docker-compose.yml 파일&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;은 장황한 도커 실행 옵션을 미리 적어둔 문서라고 볼 수 있습니다. 프로젝트 루트에 파일을 만들고, 다음 내용을 붙여 넣습니다. (&lt;a href=&quot;https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1/79fe204485726b37ce73486fc93d73cef1b55004&quot;&gt;gist 링크&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb21&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;version:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; &lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'3'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-4&quot; data-line-number=&quot;4&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-5&quot; data-line-number=&quot;5&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;image:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; postgres&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-6&quot; data-line-number=&quot;6&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-7&quot; data-line-number=&quot;7&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;./docker/data:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;/var/lib/postgresql/data&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-8&quot; data-line-number=&quot;8&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;environment:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-9&quot; data-line-number=&quot;9&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_DB=sampledb&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-10&quot; data-line-number=&quot;10&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_USER=sampleuser&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-11&quot; data-line-number=&quot;11&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_PASSWORD=samplesecret&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-12&quot; data-line-number=&quot;12&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_INITDB_ARGS=--encoding=UTF-8&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-13&quot; data-line-number=&quot;13&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-14&quot; data-line-number=&quot;14&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-15&quot; data-line-number=&quot;15&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;build:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-16&quot; data-line-number=&quot;16&quot;&gt;      &lt;span class=&quot;fu&quot;&gt;context:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; .&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-17&quot; data-line-number=&quot;17&quot;&gt;      &lt;span class=&quot;fu&quot;&gt;dockerfile:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; ./compose/django/Dockerfile-dev&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-18&quot; data-line-number=&quot;18&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;environment:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-19&quot; data-line-number=&quot;19&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DEBUG=True&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-20&quot; data-line-number=&quot;20&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_HOST=db&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-21&quot; data-line-number=&quot;21&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_PORT=5432&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-22&quot; data-line-number=&quot;22&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_NAME=sampledb&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-23&quot; data-line-number=&quot;23&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_USERNAME=sampleuser&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-24&quot; data-line-number=&quot;24&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_PASSWORD=samplesecret&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-25&quot; data-line-number=&quot;25&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_SECRET_KEY=dev_secret_key&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-26&quot; data-line-number=&quot;26&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;ports:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-27&quot; data-line-number=&quot;27&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;8000:8000&quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-28&quot; data-line-number=&quot;28&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;command:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; &lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-29&quot; data-line-number=&quot;29&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;python manage.py runserver 0:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;8000&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-30&quot; data-line-number=&quot;30&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb21-31&quot; data-line-number=&quot;31&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;./:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;/app/&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 파일의 윗부분부터 한 줄씩 살펴봅시다.&lt;/p&gt;
&lt;h4 id=&quot;version&quot;&gt;3.2.1 version&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb22&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb22-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;version:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; &lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'3'&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일의 첫 줄에는 파일 규격 버전을 적습니다. 파일의 규격에 따라 지원하는 옵션이 달라지는데, “3”이라만 적으면 3으로 시작하는 최신 버전을 사용한다는 의미입니다. (파일 규격 버전에 따른 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/compose/compose-file/compose-versioning/&quot;&gt;compose 파일의 버전과 호환성을 안내한 공식 문서&lt;/a&gt;를 참고하세요.)&lt;/p&gt;
&lt;h4 id=&quot;services&quot;&gt;3.2.2 services&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb23&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb23-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 항목 밑에 실행하려는 컨테이너들을 정의합니다. 컴포즈에서는 컨테이너 대신 서비스라는 개념을 사용합니다.&lt;/p&gt;
&lt;h4 id=&quot;db&quot;&gt;3.2.3 db&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb24&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;postgres 서비스의 이름을 &lt;code&gt;db&lt;/code&gt;로 정하였습니다.&lt;/p&gt;
&lt;h4 id=&quot;image&quot;&gt;3.2.4 image&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb25&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb25-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb25-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb25-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;image:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; postgres&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;db&lt;/code&gt; 서비스에서 사용할 도커 이미지를 적습니다. 여기서는 &lt;a href=&quot;https://hub.docker.com/_/postgres/&quot;&gt;dockerhub의 공식 postgres 이미지&lt;/a&gt;를 사용하였습니다.&lt;/p&gt;
&lt;h4 id=&quot;volumes&quot;&gt;3.2.5 volumes&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb26&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb26-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb26-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb26-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb26-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;./docker/data:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;/var/lib/postgresql/data&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 db 컨테이너를 실행할 때 &lt;code&gt;--volume&lt;/code&gt; 옵션을 사용하여 데이터베이스의 데이터를 로컬 컴퓨터에 저장했던 부분과 같습니다. 다만 &lt;code&gt;docker-compose.yml&lt;/code&gt;의 &lt;code&gt;volumes&lt;/code&gt;에는 상대 경로를 지정할 수 있어서 편리합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 db 컨테이너를 실행할 때와 마찬가지로, 프로젝트 루트 아래의 &lt;code&gt;docker/data&lt;/code&gt; 디렉터리에 데이터를 저장하기로 했습니다.&lt;/p&gt;
&lt;h4 id=&quot;environment&quot;&gt;3.2.6 environment&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb27&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;environment:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_DB=sampledb&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-5&quot; data-line-number=&quot;5&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_USER=sampleuser&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-6&quot; data-line-number=&quot;6&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_PASSWORD=samplesecret&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb27-7&quot; data-line-number=&quot;7&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; POSTGRES_INITDB_ARGS=--encoding=UTF-8&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 명령어의 &lt;code&gt;-e&lt;/code&gt; 옵션에 적었던 내용들입니다. 마지막의 &lt;code&gt;POSTGRES_INITDB_ARGS&lt;/code&gt; 부분이 추가되었는데, 데이터베이스 서버의 인코딩을 UTF-8로 설정하기 위함입니다.&lt;/p&gt;
&lt;h4 id=&quot;django&quot;&gt;3.2.7 django&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb28&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb28-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb28-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;앱 서비스의 이름은 &lt;code&gt;django&lt;/code&gt;로 지정하였습니다.&lt;/p&gt;
&lt;h4 id=&quot;build&quot;&gt;3.2.8 build&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb29&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb29-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb29-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb29-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;build:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb29-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;fu&quot;&gt;context:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; .&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb29-5&quot; data-line-number=&quot;5&quot;&gt;      &lt;span class=&quot;fu&quot;&gt;dockerfile:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; ./compose/django/Dockerfile-dev&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;db 서비스와 달리 앱 서비스는 특정 이미지 대신 &lt;code&gt;build&lt;/code&gt; 옵션을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;context&lt;/code&gt;는 &lt;code&gt;docker build&lt;/code&gt; 명령을 실행할 디렉터리 경로라고 보시면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dockerfile&lt;/code&gt;에는 &lt;strong&gt;‘개발용’ 도커 이미지&lt;/strong&gt;를 빌드하는 데 사용할 Dockerfile을 지정하면 됩니다. Dockerfile-dev 파일에서는 (운영용 Dockerfile과는 달리) 소스코드를 컨테이너에 넣지 않습니다.&lt;/p&gt;
&lt;h4 id=&quot;environment-1&quot;&gt;3.2.9 environment&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb30&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;environment:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DEBUG=True&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-5&quot; data-line-number=&quot;5&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_HOST=db&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-6&quot; data-line-number=&quot;6&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_PORT=5432&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-7&quot; data-line-number=&quot;7&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_NAME=sampledb&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-8&quot; data-line-number=&quot;8&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_USERNAME=sampleuser&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb30-9&quot; data-line-number=&quot;9&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; DJANGO_DB_PASSWORD=samplesecret&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;환경 변수는 &lt;code&gt;docker run&lt;/code&gt;을 할 때보다 좀더 자세하게 적었습니다. 각 값은 앱 서비스의 환경 변수로 설정되며, Django 설정 파일(&lt;code&gt;djangosample/settings.py&lt;/code&gt;)에서 불러와 사용하게 됩니다. (데이터베이스 관련 정보들은 db 서비스에서 설정한 값들과 일치해야 합니다.)&lt;/p&gt;
&lt;h4 id=&quot;ports&quot;&gt;3.2.10 ports&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb31&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;ports:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;8000:8000&quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 명령어의 &lt;code&gt;-p&lt;/code&gt; 옵션에 해당하는 부분입니다.&lt;/p&gt;
&lt;h4 id=&quot;command&quot;&gt;3.2.11 command&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb32&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;command:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;python manage.py runserver 0:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;8000&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때 가장 마지막에 적었던 명령어 부분입니다.&lt;/p&gt;
&lt;h4 id=&quot;volumes-1&quot;&gt;3.2.12 volumes&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb33&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb33-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb33-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb33-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb33-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;./:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;/app/&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때 &lt;code&gt;-v&lt;/code&gt; 옵션을 사용하여 프로젝트 루트 디렉터리를 컨테이너 안의 &lt;code&gt;/app&lt;/code&gt; 디렉터리와 연결했던 부분과 같습니다.&lt;/p&gt;
&lt;p&gt;이렇게 해서 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 모두 살펴보았습니다.&lt;/p&gt;
&lt;h3 id=&quot;드디어-실행&quot;&gt;3.3 드디어 실행!&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;을 모두 작성했다면 드디어 서비스를 실행할 차례입니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb34&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; up -d&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Creating&lt;/span&gt; network &lt;span class=&quot;st&quot;&gt;&quot;djangosample_default&quot;&lt;/span&gt; with the default driver&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Creating&lt;/span&gt; djangosample_db_1&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Creating&lt;/span&gt; djangosample_django_1&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Attaching&lt;/span&gt; to djangosample_db_1, djangosample_django_1&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;db_1&lt;/span&gt;       &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Initializing&lt;/span&gt; database&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt; (DB 초기화 진행) &lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Django&lt;/span&gt; version 2.1, using settings &lt;span class=&quot;st&quot;&gt;'djangosample.settings'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Starting&lt;/span&gt; development server at http://0.0.0.0:8000/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb34-10&quot; data-line-number=&quot;10&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Quit&lt;/span&gt; the server with CONTROL-C.&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 &lt;a href=&quot;http://127.0.0.1:8000&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:8000&lt;/a&gt;에 접속해보면 개발 서버가 잘 작동함을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;각 컨테이너를 실행하던 길고 복잡한 명령어들이 사라졌고, 간단한 명령어 한 줄로 개발 서버와 데이터베이스를 모두 실행하였습니다.&lt;/p&gt;
&lt;h4 id=&quot;그런데-앱-서비스에서-db-서비스를-어떻게-찾았지&quot;&gt;3.3.1 그런데… 앱 서비스에서 db 서비스를 어떻게 찾았지?&lt;/h4&gt;
&lt;p&gt;사실 &lt;code&gt;docker-compose.yml&lt;/code&gt;에는 &lt;code&gt;docker run&lt;/code&gt;에서 사용하던 옵션 중 하나가 보이지 않습니다. 바로 &lt;code&gt;--link&lt;/code&gt; 옵션인데요. 도커 컴포즈 파일 버전이 2일 때는 다음과 같은 항목으로 연결할 서비스를 명시하곤 했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;services:
  django:
    links:
      - db&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;도커 컴포즈 파일 버전 3으로 와서는 &lt;code&gt;links&lt;/code&gt; 항목을 사용하지 않더라도 한 네트워크 안에 있는 서비스끼리 서로 통신을 할 수 있기 때문에, 이 항목을 사용하지 않았습니다. (관련 문서인 &lt;a href=&quot;https://docs.docker.com/compose/networking/#links&quot;&gt;Links topic in Networking in Compose&lt;/a&gt;도 참고하세요.) 한 네트워크로 선언한 적이 없다고요? 한 &lt;code&gt;docker-compose.yml&lt;/code&gt; 안에 있는 서비스들은 별도로 지정하지 않으면 하나의 네트워크에 속합니다. (네트워크와 관련된 더 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/compose/networking/&quot;&gt;Networking in Compose&lt;/a&gt;를 참고하세요.)&lt;/p&gt;
&lt;h3 id=&quot;개발용-dockerfile을-별도로-관리하기&quot;&gt;3.4 개발용 Dockerfile을 별도로 관리하기&lt;/h3&gt;
&lt;p&gt;앞에서 개발 서버용 &lt;code&gt;Dockerfile-dev&lt;/code&gt; 파일을 짧게 언급하고 넘어갔는데요. 여기서 조금 더 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;크게 보자면 개발 서버에 필요 없는 내용은 지우고, 개발 서버에만 필요한 내용은 추가하면 됩니다. 먼저 &lt;code&gt;./compose/django/Dockerfile-dev&lt;/code&gt; 파일의 내용을 살펴봅시다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb36&quot;&gt;&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; python:3&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; apt-get update &amp;amp;&amp;amp; apt-get -y install \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-4&quot; data-line-number=&quot;4&quot;&gt;    libpq-dev&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /app&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ADD&lt;/span&gt;    ./requirements.txt   /app/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt;    pip install -r requirements.txt&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-9&quot; data-line-number=&quot;9&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-10&quot; data-line-number=&quot;10&quot;&gt;&lt;span class=&quot;co&quot;&gt;# ADD    ./djangosample   /app/djangosample/&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-11&quot; data-line-number=&quot;11&quot;&gt;&lt;span class=&quot;co&quot;&gt;# ADD    ./manage.py      /app/&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-12&quot; data-line-number=&quot;12&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb36-13&quot; data-line-number=&quot;13&quot;&gt;&lt;span class=&quot;co&quot;&gt;# CMD [&quot;python&quot;, &quot;manage.py&quot;, &quot;runserver&quot;, &quot;0:8000&quot;]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 주석으로 처리한 부분들은 원래 &lt;code&gt;Dockerfile&lt;/code&gt;에는 있었지만 개발 서버용 도커 이미지에서 삭제한 내용입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앱 코드: 앱 코드는 컨테이너 안에 집어 넣지 않고 로컬 컴퓨터의 디렉터리를 참조합니다. (&lt;code&gt;docker-compose.yml&lt;/code&gt;의 &lt;code&gt;volume&lt;/code&gt; 부분)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;CMD&lt;/code&gt;: 도커 컴포즈의 &lt;code&gt;command&lt;/code&gt;로 관리하는 편이 더 쉽습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 &lt;code&gt;./compose/django/Dockerfile-dev&lt;/code&gt;의 내용은 다음과 같습니다. (&lt;a href=&quot;https://gist.github.com/raccoonyy/3674be1c8f24f6299b1949a92dbe5795&quot;&gt;gist 링크&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb37&quot;&gt;&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; python:3&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; apt-get update &amp;amp;&amp;amp; apt-get -y install \&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-4&quot; data-line-number=&quot;4&quot;&gt;    libpq-dev&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /app&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ADD&lt;/span&gt;    requirements.txt    /app/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb37-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt;    pip install -r requirements.txt&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게만 해도 개발 환경을 구성하고 실행하기가 한결 수월해지지만, 실제로 사용하다보니 소소하게 불편한 점들이 있더군요. 이를 개선해보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;개선할-점-몇-가지&quot;&gt;3.5 개선할 점 몇 가지&lt;/h3&gt;
&lt;h4 id=&quot;데이터베이스-데이터용-볼륨-추가&quot;&gt;3.5.1 데이터베이스 데이터용 볼륨 추가&lt;/h4&gt;
&lt;p&gt;지금까지는 데이터베이스의 실제 데이터를 &lt;code&gt;./docker/data&lt;/code&gt;에 저장하고 있었는데, 실수로 이 디렉터리가 지워진다거나 소스코드 버전 관리 시스템에 들어가버리면 낭패일 겁니다. 이 디렉터리를 직접 관리하지 말고 도커에 맡겨봅시다. &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb38&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;version:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; &lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'3'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-2&quot; data-line-number=&quot;2&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 변경 부분!&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-5&quot; data-line-number=&quot;5&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django_sample_db_dev:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{}&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-6&quot; data-line-number=&quot;6&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-8&quot; data-line-number=&quot;8&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;db:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-9&quot; data-line-number=&quot;9&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;image:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; postgres&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-10&quot; data-line-number=&quot;10&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;volumes:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-11&quot; data-line-number=&quot;11&quot;&gt;      &lt;span class=&quot;co&quot;&gt;# 여기도!&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-12&quot; data-line-number=&quot;12&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;django_sample_db_dev:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;/var/lib/postgresql/data&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-13&quot; data-line-number=&quot;13&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;environment:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb38-14&quot; data-line-number=&quot;14&quot;&gt;      ...&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;처음 바뀐 부분에서는 &lt;code&gt;django_sample_db_dev&lt;/code&gt;라는 이름으로 볼륨을 하나 만듭니다. 이렇게 만들어진 볼륨은 &lt;code&gt;docker volume ls&lt;/code&gt; 명령으로 확인할 수 있습니다. (볼륨은 도커가 관리하는 가상 디스크라고 생각하면 됩니다.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb39&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb39-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker&lt;/span&gt; volume ls&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb39-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;bu&quot;&gt;local&lt;/span&gt;               &lt;span class=&quot;va&quot;&gt;django_sample_db_dev&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 만든 볼륨을 db 서비스에서 사용하려면, db 서비스 선언부 안에 &lt;code&gt;volumes&lt;/code&gt; 항목을 넣고 &lt;code&gt;- 가상디스크_이름:컨테이너_속_디렉터리&lt;/code&gt;처럼 지정합니다. 이후로는 모든 데이터베이스 데이터가 &lt;code&gt;django_sample_db_dev&lt;/code&gt; 볼륨에 저장됩니다. (이 볼륨을 지우려면 &lt;code&gt;docker volume rm django_sample_db_dev&lt;/code&gt; 명령을 사용합니다.)&lt;/p&gt;
&lt;h4 id=&quot;파이썬-로그가-한-발-느리게-출력되는-문제-수정&quot;&gt;3.5.2 파이썬 로그가 한 발 느리게 출력되는 문제 수정&lt;/h4&gt;
&lt;p&gt;도커 컴포즈에서 파이썬 로그가 한 발 늦게 출력된다는 느낌을 받을 때가 있습니다. 파이썬에서 출력 버퍼가 기본으로 작동하면서 출력 로그를 붙잡고 있기 때문인데요. 이 버퍼링을 없애려면 &lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt; 환경변수를 추가하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./compose/django/Dockerfile-dev&lt;/code&gt;에 다음 내용을 추가합니다. (설정할 값은 0이든 1이든 상관 없고, 환경변수가 존재하기만 하면 됩니다.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb40&quot;&gt;&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb40-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ENV&lt;/span&gt; PYTHONUNBUFFERED=0&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 해서 도커 컴포즈로 개발 환경을 어떻게 구성하는지 살펴보았습니다. 이제 도커 컴포즈에서 주로 사용하는 명령어를 간략하게 훑어보겠습니다.&lt;/p&gt;
&lt;h4 id=&quot;django-서버가-데이터베이스를-못-찾아요&quot;&gt;3.5.3 Django 서버가 데이터베이스를 못 찾아요&lt;/h4&gt;
&lt;p&gt;이는 대부분 첫 실행시에만 발생하는 문제입니다. 데이터베이스 서비스가 실행된 후 초기화되기 전에(대략 5초~10초) Django 서버가 실행되기 때문인데요. 가장 간단한 해결 방법은 서비스를 중지하고 다시 실행하는 것이지만 근본적인 해결책은 아닙니다. 이를 위해 &lt;a href=&quot;https://github.com/vishnubob/wait-for-it/&quot;&gt;wait-for-it.sh&lt;/a&gt;이라는 셸 스크립트를 사용해보겠습니다.&lt;/p&gt;
&lt;p&gt;wait-for-it.sh는 이름이 알려주듯 특정 서버의 특정 포트로 접근할 수 있을 때까지 기다려주는 스크립트입니다. 이 스크립트를 도커 이미지 안에 넣고, 이미지 실행 명령 앞에 붙여주면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./compose/django/Dockerfile-dev&lt;/code&gt; 파일의 마지막 부분에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb41&quot;&gt;&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb41-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ADD&lt;/span&gt;    https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh /&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일의 &lt;code&gt;command&lt;/code&gt; 부분을 다음처럼 수정합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb42&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;fu&quot;&gt;services:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-2&quot; data-line-number=&quot;2&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;django:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-3&quot; data-line-number=&quot;3&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;command:&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-4&quot; data-line-number=&quot;4&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; bash&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-5&quot; data-line-number=&quot;5&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; -c&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-6&quot; data-line-number=&quot;6&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; |&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-7&quot; data-line-number=&quot;7&quot;&gt;        &lt;span class=&quot;fu&quot;&gt;/wait-for-it.sh db:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;5432 -t 10&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb42-8&quot; data-line-number=&quot;8&quot;&gt;        &lt;span class=&quot;fu&quot;&gt;python manage.py runserver 0:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;8000&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면, db 서비스의 5432 포트가 사용 가능할 때까지 기다린 후, Django 개발 서버가 실행되기 때문에 오류가 발생하지 않습니다.&lt;/p&gt;
&lt;h3 id=&quot;도커-컴포즈의-주요-명령어&quot;&gt;3.6 도커 컴포즈의 주요 명령어&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-compose&lt;/code&gt; 명령어를 짧은 alias로 등록해두면 편리합니다. 저는 oh-my-zsh에서 기본으로 제공하는 &lt;code&gt;dco&lt;/code&gt;를 사용하고 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;up--d&quot;&gt;up -d&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행합니다. 자세한 진행 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;서비스를 띄울 네트워크 설정&lt;/li&gt;
&lt;li&gt;필요한 볼륨 생성(혹은 이미 존재하는 볼륨과 연결)&lt;/li&gt;
&lt;li&gt;필요한 이미지 풀(pull)&lt;/li&gt;
&lt;li&gt;필요한 이미지 빌드(build)&lt;/li&gt;
&lt;li&gt;서비스 의존성에 따라 서비스 실행&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;up&lt;/code&gt; 명령에 사용할 수 있는 몇 가지 옵션도 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;-d&lt;/code&gt;: 서비스 실행 후 콘솔로 빠져나옵니다. (&lt;code&gt;docker run&lt;/code&gt;에서의 &lt;code&gt;-d&lt;/code&gt;와 같습니다.)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--force-recreate&lt;/code&gt;: 컨테이너를 지우고 새로 만듭니다.&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;--build&lt;/code&gt;: 서비스 시작 전 이미지를 새로 만듭니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ps&quot;&gt;ps&lt;/h4&gt;
&lt;p&gt;현재 환경에서 실행 중인 각 서비스의 상태를 보여줍니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb43&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb43-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; ps&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb43-2&quot; data-line-number=&quot;2&quot;&gt;        &lt;span class=&quot;ex&quot;&gt;Name&lt;/span&gt;                       Command               State           Ports&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb43-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;--------------------------------------------------------------------------------&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb43-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;djangosample_db_1&lt;/span&gt;       /docker-entrypoint.sh postgres   Up      5432/tcp&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb43-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;djangosample_django_1&lt;/span&gt;   /bash -c python manage.py        Up      0.0.0.0:8000-&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;8000/tcp&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;stop-start&quot;&gt;stop, start&lt;/h4&gt;
&lt;p&gt;서비스를 멈추거나, 멈춰 있는 서비스를 시작합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb44&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; stop&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Stopping&lt;/span&gt; djangosample_django_1 ...&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Stopping&lt;/span&gt; djangosample_db_1 ...&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-5&quot; data-line-number=&quot;5&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; start&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Starting&lt;/span&gt; db ... done&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb44-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Starting&lt;/span&gt; django ... done&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;down&quot;&gt;down&lt;/h4&gt;
&lt;p&gt;서비스를 지웁니다. 컨테이너와 네트워크를 삭제하며, 옵션에 따라 볼륨도 지웁니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb45&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb45-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; down --volume&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb45-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Removing&lt;/span&gt; myproject_django_1 ... done&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb45-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Removing&lt;/span&gt; myproject_db_1 ... done&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb45-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Removing&lt;/span&gt; network djangosample_default&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb45-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Removing&lt;/span&gt; volume django_sample_db_dev&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;--volume&lt;/code&gt;: 볼륨까지 삭제합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;exec&quot;&gt;exec&lt;/h4&gt;
&lt;p&gt;실행 중인 컨테이너에서 명령어를 실행합니다. 자동화된 마이그레이션용 파일 생성이나 유닛 테스트, lint 등을 실행할 때 사용합니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 비슷한 명령으로 &lt;code&gt;run&lt;/code&gt;이 존재합니다. &lt;code&gt;run&lt;/code&gt;은 새 컨테이너를 만들어서 명령어를 실행합니다. &lt;code&gt;docker run&lt;/code&gt;과 마찬가지로 &lt;code&gt;--rm&lt;/code&gt; 옵션을 추가하지 않으면, 컨테이너가 종료된 후에도 삭제되지 않습니다. (이런 이유 때문에 개인적으로는 &lt;code&gt;exec&lt;/code&gt;를 선호하지만, 컨테이너에서 추천하는 방식은 사실 &lt;code&gt;run&lt;/code&gt;입니다.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb46&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb46-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; exec django ./manage.py makemigrations&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb46-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb47&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb47-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; exec node npm run test&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb47-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;expresssample@0.1.0&lt;/span&gt; test /www/service&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb47-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;mocha&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt; test -name &lt;span class=&quot;st&quot;&gt;'*.spec.js'&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb47-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;logs&quot;&gt;logs&lt;/h4&gt;
&lt;p&gt;서비스의 로그를 확인할 수 있습니다. &lt;code&gt;logs&lt;/code&gt; 뒤에 서비스 이름을 적지 않으면 도커 컴포즈가 관리하는 모든 서비스의 로그를 함께 보여줍니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb48&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; logs django&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Attaching&lt;/span&gt; to djangosample_django_1&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;System&lt;/span&gt; check identified no issues (0 silenced)&lt;span class=&quot;ex&quot;&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;February&lt;/span&gt; 13, 2017 - 16:32:28&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Django&lt;/span&gt; version 1.10.4, using settings &lt;span class=&quot;st&quot;&gt;'djangosample.settings'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Starting&lt;/span&gt; development server at http://0.0.0.0:8000/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb48-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;django_1&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;Quit&lt;/span&gt; the server with CONTROL-C.&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;code&gt;-f&lt;/code&gt;: 지금까지 쌓인 로그를 다 보여준 후에도 셸로 빠져나오지 않고, 로그가 쌓일 때마다 계속해서 출력합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;도커-컴포즈-단축-명령어-등록하기&quot;&gt;3.7 도커 컴포즈 단축 명령어 등록하기&lt;/h3&gt;
&lt;p&gt;편의성을 위해 도커 컴포즈를 도입했는데 &lt;code&gt;docker-compose&lt;/code&gt;라는 명령어 자체가 너무 길어서 오히려 불편할 수도 있겠죠. 이를 위해 &lt;code&gt;~/.bashrc&lt;/code&gt;나 &lt;code&gt;~/.zshrc&lt;/code&gt;에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb49&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dco=&lt;span class=&quot;st&quot;&gt;'docker-compose'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcb=&lt;span class=&quot;st&quot;&gt;'docker-compose build'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dce=&lt;span class=&quot;st&quot;&gt;'docker-compose exec'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcps=&lt;span class=&quot;st&quot;&gt;'docker-compose ps'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcr=&lt;span class=&quot;st&quot;&gt;'docker-compose run'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcup=&lt;span class=&quot;st&quot;&gt;'docker-compose up'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcdn=&lt;span class=&quot;st&quot;&gt;'docker-compose down'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dcl=&lt;span class=&quot;st&quot;&gt;'docker-compose logs'&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb49-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;bu&quot;&gt;alias&lt;/span&gt; dclf=&lt;span class=&quot;st&quot;&gt;'docker-compose logs -f'&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 &lt;code&gt;docker-compose up&lt;/code&gt; 대신 &lt;code&gt;dcup&lt;/code&gt;을, &lt;code&gt;docker-compose exec django bash&lt;/code&gt; 대신 &lt;code&gt;dce django bash&lt;/code&gt;를 실행하면 됩니다.&lt;/p&gt;
&lt;p&gt;마지막으로, 몇 가지 삽질 경험을 바탕으로 나름의 팁을 정리해보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;나름의-팁&quot;&gt;3.8 나름의 팁&lt;/h3&gt;
&lt;h4 id=&quot;docker-compose.yml-파일을-수정했다면&quot;&gt;3.8.1 docker-compose.yml 파일을 수정했다면?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 수정하고 이를 서비스에 적용하려면 서비스를 멈추고(&lt;code&gt;stop&lt;/code&gt;), 서비스를 지우고(&lt;code&gt;rm&lt;/code&gt;), 서비스를 시작해야(&lt;code&gt;up&lt;/code&gt;) 합니다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;up&lt;/code&gt; 명령만 실행해도, (현재 실행 중인 서비스 설정과 달라진 부분이 있다면) &lt;strong&gt;알아서 컨테이너를 재생성하고 서비스를 재시작&lt;/strong&gt;해줍니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb50&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb50-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; up -d [서비스_이름]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 혹시 컨테이너를 재생성하지 않는 것 같다면, &lt;code&gt;--force-recreate&lt;/code&gt; 옵션을 붙이면 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;dockerfile-dev-파일을-수정했다면&quot;&gt;3.8.2 Dockerfile-dev 파일을 수정했다면?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Dockerfile-dev&lt;/code&gt; 파일을 수정했을 땐 &lt;code&gt;build&lt;/code&gt; 명령을 사용하여 도커 이미지를 새로 만들어야 합니다. 이후 서비스 중지와 삭제, 재시작을 해야 하죠.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;up&lt;/code&gt; 명령에 다음과 같이 &lt;code&gt;--build&lt;/code&gt; 옵션을 넣으면 &lt;strong&gt;알아서 이미지를 새로 만들고 서비스를 재시작&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb51&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb51-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;docker-compose&lt;/span&gt; up -d --build [서비스_이름]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;dockerfile-dev도-신경-써야-함&quot;&gt;3.8.3 Dockerfile-dev도 신경 써야 함&lt;/h4&gt;
&lt;p&gt;개발용 이미지를 담당하는 Dockerfile-dev 파일과 배포용 이미지를 담당하는 Dockerfile 파일이 따로 존재한다는 점을 꼭 기억해야 합니다. 간혹 &lt;code&gt;Dockerfile&lt;/code&gt;만 고치면서 개발 환경에서 &lt;strong&gt;‘외않돼?’&lt;/strong&gt;라고 생각한 경우가 있습니다. (저만 그럴수도요;;)&lt;/p&gt;
&lt;h4 id=&quot;데이터베이스-내용도-지우고-싶다면&quot;&gt;3.8.4 데이터베이스 내용도 지우고 싶다면&lt;/h4&gt;
&lt;p&gt;열심히 개발하다 보면 데이터베이스에 원치 않는 데이터가 남는 경우가 있습니다. 데이터베이스에 접속해서 테이블을 삭제하거나 할 수도 있겠지만, &lt;code&gt;down&lt;/code&gt; 명령에 &lt;code&gt;--volume&lt;/code&gt; 옵션을 추가하면 서비스에서 사용하는 볼륨(=데이터베이스 데이터가 저장되는 곳)을 삭제하기 때문에, 데이터베이스를 깨끗하게 초기화할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker-compose down --volume&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;mysql보다는-postgresql이-조금-더-편한-듯&quot;&gt;3.8.5 MySQL보다는 PostgreSQL이 조금 더 편한 듯&lt;/h4&gt;
&lt;p&gt;로컬 컴퓨터에 데이터베이스 서버가 없어도, 서비스를 시작하기만 하면 알아서 데이터베이스 서버가 시작된다는 점은 굉장한 매력이었습니다. 그런데 MySQL과 PostgreSQL의 초기화 과정에 걸리는 시간이 꽤 차이가 나더군요.&lt;/p&gt;
&lt;p&gt;제 컴퓨터 기준이긴 하지만 MySQL 초기화에는 대략 15초, PostgreSQL 초기화에 대략 5초 남짓한 시간이 걸립니다. 데이터베이스 초기화가 자주 필요한 일은 아니지만 그래도 15초와 5초의 차이는 꽤 크죠.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 아울러, 데이터를 로컬에 쌓기보다는 도커가 관리하는 가상 디스크를 사용하는 편이 속도 면에서 좀더 유리합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;error-no-space-left-on-device&quot;&gt;3.8.6 ERROR: ‘No space left on device’&lt;/h4&gt;
&lt;p&gt;도커를 열심히 사용하고 있는데 갑자기 다음과 같은 메시지가 뜨면서 새 이미지를 빌드할 수 없는 경우가 발생합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR: 'No space left on device'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하드디스크에 용량이 엄청 많이 남아 있었는데도 말이죠. 이는 도커에서 사용하는 가상 파일 시스템의 기본 최대 값이 64기가바이트여서 발생하는 문제입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의! 다음 내용을 진행하면 도커 이미지와 컨테이너, 볼륨이 모두 사라집니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이 경우 도커의 환경 설정에서 &lt;code&gt;Reset disk image&lt;/code&gt; 버튼을 누르면 해결됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/37f/37f16ab9cf4196177787c4b20e965ef48e15b2d679c131a939e230dc1d404d1b.m.png&quot; alt=&quot;도커 메뉴의 환경 설정을 선택합니다&quot;&gt;&lt;figcaption&gt;도커 메뉴의 환경 설정을 선택합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/295/29500af76a027ffc5c82579c985b803c34db4035aa94ab07f80330613599d586.m.png&quot; alt=&quot;Reset disk image 버튼을 누릅니다&quot;&gt;&lt;figcaption&gt;Reset disk image 버튼을 누릅니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 해서 개발 환경 구성하기를 마쳤습니다. 장황해보이지만, 실제로는 한 번 잘 구성해 두면 다른 프로젝트에는 그저 옮겨 붙이는 정도로 쉽게 적용할 수 있을 겁니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Wed, 20 Mar 2019 03:10:45 +0000</pubDate>
      <dc:date>2019-03-20T03:10:45+00:00</dc:date>
    </item>
    <item>
      <title>테라폼(Terraform) 0.12 베타 1 출시 및 개선된 HCL 문법 살펴보기</title>
      <link>https://www.44bits.io/ko/post/preview-new-feature-of-terraform-012-beta-1</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        테라폼 0.12 베타 1 출시 및 개선된 HCL 문법 살펴보기
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;!--
--&gt;
&lt;h2 id=&quot;들어가며-테라폼terraform-0.12-베타-1-출시&quot;&gt;들어가며: 테라폼(Terraform) 0.12 베타 1 출시&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.terraform.io/&quot;&gt;테라폼&lt;sup&gt;Terraform&lt;/sup&gt;&lt;/a&gt;은 클라우드 상의 리소스들을 코드로 작성하고 관리할 수 있게 도와주는 도구로서 코드로서의 인프라스트럭처&lt;sup&gt;Infrastructure as Code&lt;/sup&gt;를 실현합니다. &lt;a href=&quot;https://www.44bits.io/ko/post/terraform_introduction_infrastrucute_as_code&quot;&gt;테라폼의 기본적인 사용법&lt;/a&gt;에 대해서는 44bits에서도 다룬 적이 있습니다.&lt;/p&gt;
&lt;p&gt;작년 6월 하시코프&lt;sup&gt;Hashicorp&lt;/sup&gt; 블로그에는 &lt;a href=&quot;https://www.hashicorp.com/blog/terraform-0-1-2-preview&quot;&gt;테라폼 0.12 버전의 새 기능을 소개하는 글&lt;/a&gt;이 연재되었습니다. 그 이후로 업데이트 없이 어느덧 일년이 다 되어 가는데요. 2019년 2월 28일, 드디어 베타 1 버전이 출시되었습니다. 이 글에서는 테라폼 0.12 베타 1 버전을 설치하는 방법과 개선된 HCL 문법에 대해서 소개합니다.&lt;/p&gt;
&lt;h3 id=&quot;테라폼-0.12-베타-1-설치&quot;&gt;테라폼 0.12 베타 1 설치&lt;/h3&gt;
&lt;p&gt;테라폼 0.12 베타 1 버전을 사용하려면 먼저 설치를 해야합니다. 하시코프에서는 각 &lt;a href=&quot;https://releases.hashicorp.com/terraform/0.12.0-beta1/&quot;&gt;운영체제 별로 바이너리 파일&lt;/a&gt;을 준비해두었습니다. 자신의 운영체제에 맞는 파일을 다운로드 받아 압축을 풀면 새로운 테라폼을 체험해볼 수 있습니다. 여기서는 맥OS&lt;sup&gt;macOS&lt;/sup&gt;을 가정하고 설치를 진행해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; terraform-012-demo&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; terraform-012-demo&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-3&quot; data-line-number=&quot;3&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;wget&lt;/span&gt; https://releases.hashicorp.com/terraform/0.12.0-beta1/terraform_0.12.0-beta1_darwin_amd64.zip &lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb1-4&quot; data-line-number=&quot;4&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;unzip&lt;/span&gt; terraform_0.12.0-beta1_darwin_amd64.zip&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;terraform&lt;/code&gt; 이름을 가진 바이너리 파일이 생성됩니다. 이 파일을 실행해 버전을 확인해봅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./terraform -v
Terraform v0.12.0-beta1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 새로운 버전을 사용할 수 있습니다. direnv를 사용하면 특정 프로젝트(디렉터리)에서만 새로운 테라폼 버전을 사용하는 것도 가능합니다. 이에 대한 자세한 정보는 부록 1을 참고해주세요.&lt;/p&gt;
&lt;h3 id=&quot;aws-프로바이더-설치&quot;&gt;AWS 프로바이더 설치&lt;/h3&gt;
&lt;p&gt;테라폼 0.12 베타 1과 호환되는 프로바이더는 아직 공식 릴리스되지 않았기 때문에, 여기서는 개발 버전을 다운로드하여 사용하겠습니다. &lt;a href=&quot;http://terraform-0.12.0-dev-snapshots.s3-website-us-west-2.amazonaws.com/&quot;&gt;테라폼 0.12 베타 1과 호환되는 개발 버전 프로바이더 모음&lt;/a&gt;에 가면 다양한 프로바이더를 다운받을 수 있습니다. &lt;strong&gt;여기서는 aws 프로바이더를 기준으로 설명하겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;wget&lt;/span&gt; http://terraform-0.12.0-dev-snapshots.s3-website-us-west-2.amazonaws.com/terraform-provider-aws/1.60.0-dev20190216H00-dev/terraform-provider-aws_1.60.0-dev20190216H00-dev_darwin_amd64.zip&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; -p terraform.d/plugins/darwin_amd64&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb3-3&quot; data-line-number=&quot;3&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;unzip&lt;/span&gt; terraform-provider-aws_1.60.0-dev20190216H00-dev_darwin_amd64.zip -d terraform.d/plugins/darwin_amd64/&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;실습용-테라폼-파일&quot;&gt;실습용 테라폼 파일&lt;/h2&gt;
&lt;p&gt;이제 실습을 위해 다음 내용으로 &lt;code&gt;terraform.tf&lt;/code&gt; 파일을 생성합니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# terraform.tf

provider &quot;aws&quot; {
  version = &quot;~&amp;gt; 1.60.0-dev&quot;
  region  = &quot;ap-northeast-2&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 명령창에서 &lt;code&gt;terraform init&lt;/code&gt;을 실행하여 다음과 같은 메시지가 나타난다면 설정은 끝났습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/fd7/fd7505ff843a0199706e3158f3568469bbe7d12f1752ca719d807d4007600f98.m.png&quot; alt=&quot;마음에 안정을 주는 초록색 메시지&quot;&gt;&lt;figcaption&gt;마음에 안정을 주는 초록색 메시지&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;테라폼-코드를-0.12-베타-1-버전에-맞춰-수정하기&quot;&gt;테라폼 코드를 0.12 베타 1 버전에 맞춰 수정하기&lt;/h3&gt;
&lt;p&gt;테라폼 0.12부터는 새 HCL 문법을 사용합니다. 그런데 기존에 사용하던 HCL 코드를 일일이 새 문법으로 바꾸기란 쉽지 않은 일이기 때문에 테라폼에서는 &lt;code&gt;0.12upgrade&lt;/code&gt;라는 명령어를 제공합니다. 우선, 이전 버전에 맞춰 작성된 간단한 테라폼 파일(&lt;code&gt;main.tf&lt;/code&gt;)을 하나 만들어 봅시다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# main.tf

variable &quot;vpc_cidr&quot; {
  type    = &quot;string&quot;
  default = &quot;172.17.0.0/16&quot;
}

variable &quot;public_cidr&quot; {
  type    = &quot;string&quot;
  default = &quot;172.17.1.0/24&quot;
}

resource &quot;aws_subnet&quot; &quot;public&quot; {
  vpc_id     = &quot;${aws_vpc.this.id}&quot;
  cidr_block = &quot;${var.public_cidr}&quot;
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;${var.vpc_cidr}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;terraform 0.12upgrade&lt;/code&gt; 명령을 실행합니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-1&quot; data-line-number=&quot;1&quot;&gt;&lt;span class=&quot;ex&quot;&gt;This&lt;/span&gt; command will rewrite the configuration files in the given directory so&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;that&lt;/span&gt; they use the new syntax features from Terraform v0.12, and will identify&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;any&lt;/span&gt; constructs that may need to be adjusted for correct operation with&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Terraform&lt;/span&gt; v0.12.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-5&quot; data-line-number=&quot;5&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-6&quot; data-line-number=&quot;6&quot;&gt;&lt;span class=&quot;ex&quot;&gt;We&lt;/span&gt; recommend using this command in a clean version control work tree, so that&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;you&lt;/span&gt; can easily see the proposed changes as a diff against the latest commit.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-8&quot; data-line-number=&quot;8&quot;&gt;&lt;span class=&quot;ex&quot;&gt;If&lt;/span&gt; you have uncommited changes already present, we recommend aborting this&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-9&quot; data-line-number=&quot;9&quot;&gt;&lt;span class=&quot;bu&quot;&gt;command&lt;/span&gt; and dealing with them before running this command again.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-10&quot; data-line-number=&quot;10&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-11&quot; data-line-number=&quot;11&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Would&lt;/span&gt; you like to upgrade the module in the current directory?&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-12&quot; data-line-number=&quot;12&quot;&gt;  &lt;span class=&quot;ex&quot;&gt;Only&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'yes'&lt;/span&gt; will be accepted to confirm.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-13&quot; data-line-number=&quot;13&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb6-14&quot; data-line-number=&quot;14&quot;&gt;  &lt;span class=&quot;ex&quot;&gt;Enter&lt;/span&gt; a value:&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정말로 실행할지를 묻을 때 &lt;code&gt;yes&lt;/code&gt;를 입력하면, 현재 디렉터리의 모든 파일을 테라폼 0.12에 맞춰 수정해줍니다. 이제 &lt;code&gt;main.tf&lt;/code&gt; 파일을 다시 열어봅시다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# main.tf (자동 변경된 내용)

variable &quot;vpc_cidr&quot; {
  type    = string
  default = &quot;172.17.0.0/16&quot;
}

variable &quot;public_cidr&quot; {
  type    = string
  default = &quot;172.17.1.0/24&quot;
}

resource &quot;aws_subnet&quot; &quot;public&quot; {
  vpc_id     = aws_vpc.this.id
  cidr_block = var.public_cidr
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = var.vpc_cidr
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;전체적으로 따옴표가 많이 사라졌음을 알 수 있습니다. 그리고 다음과 같은 내용으로 &lt;code&gt;versions.tf&lt;/code&gt; 파일이 생성되었습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# versions.tf

terraform {
  required_version = &quot;&amp;gt;= 0.12&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마도 &lt;code&gt;terraform 0.12upgrade&lt;/code&gt; 명령을 또다시 실행하는 행위를 막기 위함이 아닌가 싶습니다. (실제로 &lt;code&gt;terraform 0.12upgrade&lt;/code&gt; 명령을 다시 실행해보면, 이미 업그레이드되었다는 메시지가 나타납니다.)&lt;/p&gt;
&lt;h2 id=&quot;새-hcl-문법과-테라폼-0.12의-새-기능-둘러보기&quot;&gt;새 HCL 문법과 테라폼 0.12의 새 기능 둘러보기&lt;/h2&gt;
&lt;p&gt;이제 본격적으로 테라폼 0.12의 새 기능을 둘러보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;변수처럼-리소스모듈-참조&quot;&gt;변수처럼 리소스/모듈 참조&lt;/h3&gt;
&lt;p&gt;이전에는 리소스나 모듈을 참조할 때도 문자열 안에서 &lt;code&gt;${}&lt;/code&gt; 표현식을 사용해야 했습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

resource &quot;aws_subnet&quot; &quot;public&quot; {
  vpc_id = &quot;${aws_vpc.this.id}&quot;
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테라폼 0.12부터는 번거로운 &lt;code&gt;${}&lt;/code&gt; 표현식 없이도 리소스나 모듈을 참조할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

resource &quot;aws_subnet&quot; &quot;public&quot; {
  vpc_id = aws_vpc.this.id
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;다양한-변수-타입&quot;&gt;다양한 변수 타입&lt;/h3&gt;
&lt;p&gt;이전 버전에서는 변수의 타입을 지정할 때 &lt;code&gt;type = &quot;string&quot;&lt;/code&gt;처럼 문자열을 사용하였습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

variable &quot;public_cidrs&quot; {
  type = &quot;string&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제는 타입 자체를 그대로 인식합니다. 따라서 &lt;code&gt;type = string&lt;/code&gt;처럼 입력하면 됩니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

variable &quot;public_cidrs&quot; {
  type = string
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;복잡한-변수-선언&quot;&gt;복잡한 변수 선언&lt;/h3&gt;
&lt;p&gt;아울러, 좀더 복잡한 방식으로 변수를 선언할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

module &quot;vpc&quot; {
  source = &quot;./modules/vpc&quot;

  public_subnets = {
    zone_a = {
      cidr_block        = &quot;172.17.1.0/24&quot;
      availability_zone = &quot;ap-northeast-2a&quot;
    }
    zone_b = {
      cidr_block        = &quot;172.17.2.0/24&quot;
      availability_zone = &quot;ap-northeast-2b&quot;
    }
    zone_c = {
      cidr_block        = &quot;172.17.3.0/24&quot;
      availability_zone = &quot;ap-northeast-2c&quot;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;퍼스트-클래스-표현식&quot;&gt;퍼스트 클래스 표현식&lt;/h3&gt;
&lt;p&gt;이전 버전에서 변수를 사용할 때는 문자열 속에서 &lt;code&gt;${}&lt;/code&gt; 표현식과 함께 사용해야 했었는데요.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;${var.vpc_cidr}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제부터는 그럴 필요가 없습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = var.vpc_cidr
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;for-구문&quot;&gt;for 구문&lt;/h3&gt;
&lt;p&gt;값을 조금씩만 바꾸면서 반복적으로 리소스를 참조하거나 생성할 때, &lt;code&gt;for&lt;/code&gt; 구문을 사용할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

variable &quot;subnet_numbers&quot; {
  type    = list
  default = [1, 2, 3]
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;172.17.0.0/16&quot;
}

resource &quot;aws_subnet&quot; &quot;public&quot; {
  count      = 3
  vpc_id     = aws_vpc.this.id
  cidr_block = [
    for num in var.subnet_numbers:
    cidrsubnet(aws_vpc.this.cidr_block, 8, num)
  ][count.index]
}

output &quot;subnet_cidrs&quot; {
  value = [
    for num in var.subnet_numbers:
    cidrsubnet(aws_vpc.this.cidr_block, 8, num)
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예시를 적용한 후 출력되는 값을 보면 &lt;code&gt;for&lt;/code&gt; 구문이 어떻게 적용되었는지 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb17&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;terraform&lt;/span&gt; apply&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Apply&lt;/span&gt; complete! Resources: 1 added, 0 changed, 0 destroyed.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Outputs&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-6&quot; data-line-number=&quot;6&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;subnet_cidrs&lt;/span&gt; = [&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-8&quot; data-line-number=&quot;8&quot;&gt;  &lt;span class=&quot;st&quot;&gt;&quot;172.17.1.0/24&quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-9&quot; data-line-number=&quot;9&quot;&gt;  &lt;span class=&quot;st&quot;&gt;&quot;172.17.2.0/24&quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-10&quot; data-line-number=&quot;10&quot;&gt;  &lt;span class=&quot;st&quot;&gt;&quot;172.17.3.0/24&quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb17-11&quot; data-line-number=&quot;11&quot;&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 구문은 리스트 뿐 아니라 맵 형태의 데이터를 만들 때도 사용할 수 있습니다. 이때는 &lt;code&gt;[]&lt;/code&gt; 기호 대신 &lt;code&gt;{}&lt;/code&gt; 기호를 사용합니다.&lt;/p&gt;
&lt;h3 id=&quot;for_each-구문&quot;&gt;for_each 구문&lt;/h3&gt;
&lt;p&gt;단순한 값 대신 키-밸류 형태의 값을 순회할 때는 &lt;code&gt;for_each&lt;/code&gt; 구문을 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;예를 들어 이전 버전에서는 이렇게 작성하던 테라폼 코드를,&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

variable &quot;subnet_numbers&quot; {
  type    = &quot;list&quot;
  default = [&quot;ap-northeast-2a&quot;, &quot;ap-northeast-2b&quot;, &quot;ap-northeast-2c&quot;]
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;172.17.0.0/16&quot;
}

resource &quot;aws_subnet&quot; &quot;this&quot; {
  count = 3

  vpc_id = &quot;{aws_vpc.this.id}&quot;
  availability_zone = &quot;${var.subnet_numbers[count.index]}&quot;
  cidr_block = &quot;${cidrsubnet(aws_vpc.this.cidr_block, 8, count.index)}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 작성할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

variable &quot;subnet_numbers&quot; {
  default = {
    &quot;ap-northeast-2a&quot; = 1
    &quot;ap-northeast-2b&quot; = 2
    &quot;ap-northeast-2c&quot; = 3
  }
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;172.17.0.0/16&quot;
}

resource &quot;aws_subnet&quot; &quot;this&quot; {
  for_each = var.subnet_numbers

  vpc_id            = aws_vpc.this.id
  availability_zone = each.key
  cidr_block        = cidrsubnet(aws_vpc.this.cidr_block, 8, each.value)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좀더 자세한 내용은 &lt;a href=&quot;https://www.hashicorp.com/blog/hashicorp-terraform-0-12-preview-for-and-for-each&quot;&gt;테라폼 0.12 프리뷰: For와 For-Each&lt;/a&gt; 문서를 참고하세요.&lt;/p&gt;
&lt;h3 id=&quot;문자열-표현식에서-리스트와-맵-참조법-개선&quot;&gt;문자열 표현식에서 리스트와 맵 참조법 개선&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;var.security_group_id&lt;/code&gt; 가 존재한다면 해당 보안 그룹과 기본 보안 그룹을 리스트 안에 넣어 지정하고, 존재하지 않으면 기본 보안 그룹만 지정하려는 상황이라고 가정해봅시다.&lt;/p&gt;
&lt;p&gt;이전 버전이라면 이렇게 작성했을 겁니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

resource &quot;aws_instance&quot; &quot;example&quot; {
  ...
  vpc_security_group_ids = &quot;${var.security_group_id != &quot;&quot; ? [var.security_group_id] : [aws_default_security_group.this.id, var.security_group_id]}&quot;  # 문법 오류 발생
  vpc_security_group_ids = &quot;${var.security_group_id != &quot;&quot; ? list(var.security_group_id) : list(aws_default_security_group.this.id, var.security_group_id)}&quot;  # 바른 사용법
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2행처럼 사용하면 그나마 괜찮지만, 실제로는 문자열 안에서 배열 값을 참조할 수 없어서 오류가 발생합니다. 이런 문법 오류를 피하고자 3행처럼 &lt;code&gt;list()&lt;/code&gt; 함수를 사용했었죠.&lt;/p&gt;
&lt;p&gt;0.12부터는 문자열 안에 표현식을 넣지 않아도 되어서 다음과 같이 간결하게 작성할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

resource &quot;aws_instance&quot; &quot;example&quot; {
  ...
  vpc_security_group_ids = var.security_group_id != &quot;&quot; ? [aws_default_security_group.this.id, var.security_group_id] : [var.security_group_id]
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;splat-연산자&quot;&gt;Splat 연산자&lt;/h3&gt;
&lt;p&gt;이전 버전에서는 리스트 형태 리소스(&lt;code&gt;count&lt;/code&gt;로 개수를 조정하는)에 대해서만 &lt;code&gt;*&lt;/code&gt; 연산자로 접근할 수 있었습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

resource &quot;aws_subnet&quot; &quot;public&quot; {
  count = 2
  ...
}

resource &quot;aws_default_network_acl&quot; &quot;this&quot; {
  ...
  subnet_ids = [
    &quot;${aws_subnet.public.*.id}&quot;
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;0.12 이후부터는 모든 리스트 형태의 값에 &lt;code&gt;*&lt;/code&gt; 연산자로 접근할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

resource &quot;aws_default_security_group&quot; &quot;this&quot; {
  ...
  ingress {
    to_port = 80
    ...
  }
  ingress { 
    to_port = 443
    ...
  }
}

output &quot;security_gorup_ingress_to_port_list&quot; {
  value = aws_default_security_group.this.ingress.*.to_port
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;output&lt;/code&gt; 결과를 보면 다음과 같을 겁니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb24&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;tf&lt;/span&gt; apply&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;ex&quot;&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Apply&lt;/span&gt; complete! Resources: 1 added, 0 changed, 0 destroyed.&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-4&quot; data-line-number=&quot;4&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Outputs&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-6&quot; data-line-number=&quot;6&quot;&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-7&quot; data-line-number=&quot;7&quot;&gt;&lt;span class=&quot;ex&quot;&gt;security_gorup_ingress_list&lt;/span&gt; = [&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-8&quot; data-line-number=&quot;8&quot;&gt;  &lt;span class=&quot;ex&quot;&gt;443&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-9&quot; data-line-number=&quot;9&quot;&gt;  &lt;span class=&quot;ex&quot;&gt;80&lt;/span&gt;,&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb24-10&quot; data-line-number=&quot;10&quot;&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, 이전 버전에서는 리스트 형태의 값 중 특정 인덱스에 접근할 때, 무조건 가장 마지막에 인덱스를 지정하곤 했는데요.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 이전 버전

resource &quot;aws_default_network_acl&quot; &quot;this&quot; {
  ...
  subnet_ids = [
    &quot;${aws_subnet.public.*.id[count.index]}&quot;
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;0.12부터는 문법이 좀더 명확해졌습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

resource &quot;aws_default_network_acl&quot; &quot;this&quot; {
  ...
  subnet_ids = [
    aws_subnet.public[count.index].id
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;조건-연산자-사용법-개선&quot;&gt;조건 연산자 사용법 개선&lt;/h3&gt;
&lt;p&gt;조건에 따라 변수를 선언하거나 리소스를 생성하기 위해 조건 연산자(&lt;code&gt;condition ? A : B&lt;/code&gt;)를 많이 사용하곤 했는데요. 다음과 같은 제한이 있었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 원시 타입을 선언할 때만 사용할 수 있음(리스트나 맵에서 사용 불가)
- A, B 중 하나만 필요하더라도 둘 다 실제로 평가됨&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;0.12에서는 이러한 제한이 풀려, 다음과 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

locals {
  first_id = length(aws_subnet.public) &amp;gt; 0 ? aws_subnet.public[0].id : &quot;&quot;

  buckets = (var.env == &quot;dev&quot; ? [var.build_bucket, var.qa_bucket] : [var.prod_bucket])
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;null-값&quot;&gt;null 값&lt;/h3&gt;
&lt;p&gt;0.12부터 변수에 &lt;code&gt;null&lt;/code&gt;을 대입할 수 있습니다. &lt;code&gt;null&lt;/code&gt;이 대입되면 해당 리소스를 생성하지 않는다는 의미입니다.&lt;/p&gt;
&lt;pre class=&quot;hcl&quot;&gt;&lt;code&gt;# 테라폼 0.12

variable &quot;override_private_ip&quot; {
  type    = string
  default = null
}

resource &quot;aws_instance&quot; &quot;this&quot; {
  ...
  private_ip = var.override_private_ip
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;템플릿-문법&quot;&gt;템플릿 문법&lt;/h3&gt;
&lt;p&gt;이전 버전에서도 템플릿 안에서 &lt;code&gt;${}&lt;/code&gt; 표현식을 사용하여 변수를 집어넣을 수 있었지만, 0.12부터는 &lt;code&gt;for&lt;/code&gt; 구문이나 조건식 같은 좀더 다양한 표현을 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 테라폼 0.12

locals {
  cidr_list = &amp;lt;&amp;lt;EOT
%{ for subnet in aws_subnet.this ~}
SUBNET ${subnet.availability_zone} ${subnet.cidr_block}
%{ endfor }
EOT
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;local.cidr_list&lt;/code&gt;의 실제 값은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb31&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;terraform&lt;/span&gt; console&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-2&quot; data-line-number=&quot;2&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;local.cidr_list&lt;/span&gt;&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-3&quot; data-line-number=&quot;3&quot;&gt;&lt;span class=&quot;ex&quot;&gt;SUBNET&lt;/span&gt; ap-northeast-2c 172.17.1.0/24&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-4&quot; data-line-number=&quot;4&quot;&gt;&lt;span class=&quot;ex&quot;&gt;SUBNET&lt;/span&gt; ap-northeast-2a 172.17.2.0/24&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb31-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;SUBNET&lt;/span&gt; ap-northeast-2a 172.17.3.0/24&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;테라폼-0.12-업그레이드-가이드&quot;&gt;테라폼 0.12 업그레이드 가이드&lt;/h2&gt;
&lt;p&gt;얼핏만 보더라도 변경 사항이 꽤 많다는 점을 알 수 있습니다. 따라서 테라폼 공식 문서에는 &lt;a href=&quot;https://www.terraform.io/upgrade-guides/0-12.html&quot;&gt;0.12로 업그레이드하기 가이드 문서&lt;/a&gt;가 공개되어 있습니다. 가이드 문서를 아주 간략하게 정리해보면 다음과 같은 순서를 제안하고 있네요.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;테라폼 실행 파일 업그레이드&lt;/li&gt;
&lt;li&gt;프로바이더 업그레이드&lt;/li&gt;
&lt;li&gt;테라폼 설정 파일 업그레이드&lt;/li&gt;
&lt;li&gt;count를 사용하는 리소스 수정&lt;/li&gt;
&lt;li&gt;퍼스트 클래스 표현식 참조 방식을 적용&lt;/li&gt;
&lt;li&gt;공용 모듈 수정&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;이렇게 해서 테라폼 0.12의 새로운 모습을 미리 살펴보았습니다. 꽤나 편리한 기능을 담고 있어 어서 적용해보고 싶어지는데요. 이미 일년 여를 기다려 온 만큼 어서 베타 딱지를 떼고 정식 릴리스되길 바랍니다.&lt;/p&gt;
&lt;h2 id=&quot;부록-1-direnv로-특정-프로젝트에서만-테라폼-새-버전-사용하기&quot;&gt;부록 1: direnv로 특정 프로젝트에서만 테라폼 새 버전 사용하기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/direnv/direnv&quot;&gt;direnv&lt;/a&gt;를 사용하면 &lt;code&gt;.envrc&lt;/code&gt; 파일에 현재 프로젝트에 적용할 테라폼 버전을 지정할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb32&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-1&quot; data-line-number=&quot;1&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; -p .direnv/terraform/bin/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-2&quot; data-line-number=&quot;2&quot;&gt;$ &lt;span class=&quot;fu&quot;&gt;unzip&lt;/span&gt; terraform_0.12.0-beta1_darwin_amd64.zip -d .direnv/terraform/bin/&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-3&quot; data-line-number=&quot;3&quot;&gt;$ &lt;span class=&quot;bu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;load_prefix &lt;/span&gt;&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;ex&quot;&gt;direnv_layout_dir&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/terraform&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; .envrc&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-4&quot; data-line-number=&quot;4&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;terraform&lt;/span&gt; -v&lt;/a&gt;
&lt;a class=&quot;sourceLine&quot; id=&quot;cb32-5&quot; data-line-number=&quot;5&quot;&gt;&lt;span class=&quot;ex&quot;&gt;Terraform&lt;/span&gt; v0.12.0-beta1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 이 디렉터리에서 &lt;code&gt;terraform&lt;/code&gt;을 실행하면 테라폼 0.12 베타 1 버전이 실행됩니다.&lt;/p&gt;
&lt;p&gt;direnv에 대한 자세한 내용은 &lt;a href=&quot;https://www.44bits.io/ko/post/direnv_for_managing_directory_environment&quot;&gt;direnv를 사용한 개발환경 구축&lt;/a&gt;을 참고해주세요.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Wed, 06 Mar 2019 21:59:36 +0000</pubDate>
      <dc:date>2019-03-06T21:59:36+00:00</dc:date>
    </item>
    <item>
      <title>테라폼(Terraform)을 가장 잘 지원하는 에디터는? - 젯브레인 인텔리J(IntelliJ)를 활용한 테라폼 코드 작성</title>
      <link>https://www.44bits.io/ko/post/what-is-the-best-editor-that-supports-terraform</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        테라폼을 가장 잘 지원하는 에디터는?
                &lt;div class=&quot;subtitle&quot;&gt;젯브레인 인텔리J를 활용한 테라폼 코드 작성&lt;/div&gt;
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;테라폼&lt;sup&gt;Terraform&lt;/sup&gt;은 클라우드 시대에 각광받고 있는 인프라스트럭처 관리 도구입니다. 인기 만큼 여러 에디터들이 테라폼을 지원하고 있는데요. 이 글에서는 인텔리J IDEA&lt;sup&gt;IntelliJ IDEA&lt;/sup&gt;의 강력한 테라폼 지원 기능을 소개합니다. 여기서는 무료로 사용할 수 있는 인텔리J 커뮤니티 버전으로 설명하지만, 다른 젯브레인&lt;sup&gt;JetBrains&lt;/sup&gt; 에디터에서도 사용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;테라폼-플러그인-설치하고-파일-준비하기&quot;&gt;테라폼 플러그인 설치하고 파일 준비하기&lt;/h2&gt;
&lt;p&gt;메뉴에서 &lt;code&gt;IntelliJ IDEA -&amp;gt; Preferences&lt;/code&gt;를 누른 후, 왼쪽 트리에서 &lt;code&gt;Plugins&lt;/code&gt;를 선택하고 검색 창에 &lt;code&gt;terraform&lt;/code&gt;을 입력하면 &lt;code&gt;Hashicorp Terraform...&lt;/code&gt; 플러그인이 나타납니다. &lt;code&gt;install&lt;/code&gt; 버튼을 누르고,&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/af6/af6216f495a08a355b3881e62010afaf6a8d5d4390e07b73c49ec39f68b15ceb.m.png&quot; alt=&quot;terraform으로 검색하면 Hashicorp Terraform 플러그인이 나타납니다&quot;&gt;&lt;figcaption&gt;terraform으로 검색하면 Hashicorp Terraform 플러그인이 나타납니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;다음 화면에서 &lt;code&gt;Accept&lt;/code&gt;를 선택하고 인텔리J를 재시작하면 테라폼 플러그인을 사용할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/ef6/ef6350a56ea947c3fe679b6c161b2c93b0bf8aa8cb069c469fd159f3cf741026.m.png&quot; alt=&quot;이 플러그인을 사용하고 싶으니까 Accept 버튼을 누릅니다&quot;&gt;&lt;figcaption&gt;이 플러그인을 사용하고 싶으니까 Accept 버튼을 누릅니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;terraform_best_editor&lt;/code&gt; 폴더를 만들고, &lt;code&gt;terraform_best_editor/terraform.tf&lt;/code&gt; 파일을 다음과 같이 생성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;provider &quot;aws&quot; {
  version = &quot;~&amp;gt; 1.56&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;terraform_best_editor/main.tf&lt;/code&gt; 파일은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resource &quot;aws_vpc&quot; &quot;this&quot; {
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;terraform_best_editor&lt;/code&gt; 폴더를 인텔리J에서 엽니다.&lt;/p&gt;
&lt;h2 id=&quot;자동-완성&quot;&gt;자동 완성&lt;/h2&gt;
&lt;p&gt;테라폼을 처음 마주하면 수많은 리소스 종류와 각 리소스에 선언해야 하는 변수들의 다양함에 기가 죽기 마련인데요. 이름의 일부만 알고 있다면 나머지는 인텔리J가 도와줍니다. &lt;code&gt;main.tf&lt;/code&gt; 파일을 열고 다음과 같이 입력해봅니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/aa0/aa0d74f76969898474869fbcd4d5f4501abc528318d3c03a290ed3ab8ced3947.m.png&quot; alt=&quot;aws_vpc와 관련된 리소스들&quot;&gt;&lt;figcaption&gt;aws_vpc와 관련된 리소스들&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;또한 &lt;code&gt;variable&lt;/code&gt; 같은 테라폼 키워드들도 자동 완성을 지원합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/ab4/ab4de37c77973c90433d5001032c8832698d428f7dfb6f22cbc03f301e26ca59.m.png&quot; alt=&quot;var까지만 입력해도 나머지는 인텔리J가 도와줍니다&quot;&gt;&lt;figcaption&gt;var까지만 입력해도 나머지는 인텔리J가 도와줍니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;현재까지 &lt;code&gt;main.tf&lt;/code&gt;의 내용은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &quot;public_cidr_blocks&quot; {
  type = &quot;list&quot;
  default = [&quot;0.0.0.0/0&quot;]
}

resource &quot;aws_vpc&quot; &quot;this&quot; {

}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;참조-오류-힌트&quot;&gt;참조 오류 힌트&lt;/h2&gt;
&lt;p&gt;테라폼의 리소스 중에는 특정 변수를 반드시 선언해야만 하는 리소스들도 있습니다.&lt;/p&gt;
&lt;p&gt;방금 추가한 &lt;code&gt;aws_vpc&lt;/code&gt; 리소스에서는 &lt;code&gt;cidr_blocks&lt;/code&gt; 변수를 반드시 정의해야 합니다. 인텔리J에서는 필수 변수를 선언하지 않은 리소스에 노란색 하이라이트를 표시해줍니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/1fa/1fa12ee17175cca67743129dc691d93954753389bb258d02ad84ea598e93644f.m.png&quot; alt=&quot;필수 변수를 선언하지 않으면 노란색 하이라이트가 표시됩니다&quot;&gt;&lt;figcaption&gt;필수 변수를 선언하지 않으면 노란색 하이라이트가 표시됩니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;cidr_blocks&lt;/code&gt;을 다음과 같이 작성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;${var.public_cidr_blocks}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;var.&lt;/code&gt;까지 입력해보면 인텔리J가 현재 사용할 수 있는 변수 목록을 보여줍니다. 여기서는 &lt;code&gt;public_cidr_blocks&lt;/code&gt;가 나타납니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/2fc/2fc4f282300db1dabed40ef768ca8135be1f71c04b0ef3bda7bd3d81e92f345d.m.png&quot; alt=&quot;variable 자동 완성 기능&quot;&gt;&lt;figcaption&gt;variable 자동 완성 기능&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;선언하지 않은 변수를 사용하려고 하면 어떻게 될까요? &lt;code&gt;cidr_blocks&lt;/code&gt;에 존재하지 않는 변수를 적으면 다음과 같이 빨간색 글씨로 오류 부분을 알려줍니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/bc6/bc6398006a78280c1aa14ad5c7b39ae2a413c948425e40ad1d9f05b3fd54617d.m.png&quot; alt=&quot;선언하지 않은 변수를 사용하려고 하면 빨간 글씨로 알려줍니다&quot;&gt;&lt;figcaption&gt;선언하지 않은 변수를 사용하려고 하면 빨간 글씨로 알려줍니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;아직까지는 선언한 변수와 리소스가 많지 않지만, 인프라스트럭처의 규모가 커지면 내가 선언한 변수와 리소스 이름을 다른 곳에서 참조하기가 어렵습니다. 그럴 때 이러한 자동완성과 참조 오류 힌트 덕에, 파일 여닫기 작업을 줄일 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;필수 변수를 선언하지 않았을 때(리소스 외에 모듈에 선언된 필수 변수도 지원합니다)&lt;/li&gt;
&lt;li&gt;선언하지 않은 변수를 사용하려고 할 때&lt;/li&gt;
&lt;li&gt;이후 버전에서 사라질 예정인(deprecated) 프로퍼티를 사용했을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재까지 &lt;code&gt;main.tf&lt;/code&gt; 파일의 내용은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &quot;public_cidr_blocks&quot; {
  type = &quot;list&quot;
  default = [&quot;0.0.0.0/0&quot;]
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;${var.public_cidr_blocks}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;참조-따라가기&quot;&gt;참조 따라가기&lt;/h2&gt;
&lt;p&gt;선언한 변수와 리소스가 많아지고 테라폼 파일이 여러 개로 나뉘다보면, 이 변수를 어디에서 사용하는지 혹은 이 변수가 어디에 선언되어 있는지 찾기가 어렵습니다. 인텔리J는 변수 선언부를 찾거나 변수 참조 위치를 찾는 기능을 지원합니다.&lt;/p&gt;
&lt;p&gt;예시를 위해 &lt;code&gt;main.tf&lt;/code&gt;에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resource &quot;aws_vpc&quot; &quot;other&quot; {
  cidr_block = &quot;${var.public_cidr_blocks}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 &lt;code&gt;Cmd&lt;/code&gt; 키를 누른 채 1행의 &lt;code&gt;public_cidr_blocks&lt;/code&gt;를 클릭하면 이 변수를 사용하는 위치의 목록을 확인할 수 있습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/097/097a05f49edd45850fef55ee9313a09fab410c4e9bc8e9cc8ba7e1fbafecfaec.m.png&quot; alt=&quot;Cmd 키를 누른 채 변수 이름을 클릭하면 참조 위치 목록을 볼 수 있습니다&quot;&gt;&lt;figcaption&gt;Cmd 키를 누른 채 변수 이름을 클릭하면 참조 위치 목록을 볼 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;반대로 &lt;code&gt;Cmd&lt;/code&gt; 키를 누른 채 7행이나 12행의 &lt;code&gt;${var.public_cidr_blocks}&lt;/code&gt; 부분에 마우스 커서를 올리면 선언된 위치가 툴팁 형태로 나타납니다. 클릭을 하면 (당연하게도) 선언 위치로 이동하고요.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/93f/93f9c2d9689265eb0804969bcc863360980bcdc5b2bce367c3abb64b51f7eb54.m.png&quot; alt=&quot;Cmd 키를 누른 채 참조한 변수 위에 커서를 올리면 선언 위치를 확인할 수 있습니다&quot;&gt;&lt;figcaption&gt;Cmd 키를 누른 채 참조한 변수 위에 커서를 올리면 선언 위치를 확인할 수 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;현재까지 &lt;code&gt;main.tf&lt;/code&gt; 파일의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &quot;public_cidr_blocks&quot; {
  type = &quot;list&quot;
  default = [&quot;0.0.0.0/0&quot;]
}

resource &quot;aws_vpc&quot; &quot;this&quot; {
  cidr_block = &quot;${var.public_cidr_blocks}&quot;
}

resource &quot;aws_vpc&quot; &quot;other&quot; {
  cidr_block = &quot;${var.public_cidr_blocks}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;이름-일괄-바꾸기&quot;&gt;이름 일괄 바꾸기&lt;/h2&gt;
&lt;p&gt;변수나 리소스의 이름을 바꾸고 싶은데 관련된 내용들을 모두 찾기가 어려워 난감한 경우가 있었을 겁니다. 인텔리J에 기본으로 탑재된 리팩터링 기능을 사용하면 간단히 해결할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 기능이 일반적인 찾기/바꾸기와 다르다는 점을 보이기 위해 &lt;code&gt;main.tf&lt;/code&gt; 파일 제일 위에 &lt;code&gt;not_public_cidr_blocks&lt;/code&gt; 변수를 하나 추가해보겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &quot;not_public_cidr_blocks&quot; {
  type = &quot;list&quot;
  default = [&quot;0.0.0.0/0&quot;]
}
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;public_cidr_blocks&lt;/code&gt;가 적힌 세 부분 중 아무데서나 마우스 오른쪽 버튼을 클릭하거나 &lt;code&gt;Shift + F6&lt;/code&gt; 키를 누릅니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/296/29649f8ebf42a32cb372b6037d2c71fff6653501375dda548235dcc253c7e5c3.m.png&quot; alt=&quot;이름 바꾸기(Rename) 기능&quot;&gt;&lt;figcaption&gt;이름 바꾸기(Rename) 기능&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;새로 정하려는 이름으로 &lt;code&gt;public_cidrs&lt;/code&gt;를 입력하고 &lt;code&gt;Preview&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/3eb/3eb00d1f5473b1645f75f936c96a6c2540f67616a2de4383db27c33d9708116a.m.png&quot; alt=&quot;새 변수명을 입력합니다&quot;&gt;&lt;figcaption&gt;새 변수명을 입력합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;화면 아래쪽에서 어떤 파일의 어느 부분이 바뀌는지 확인할 수 있습니다. 모두 확인했다면 &lt;code&gt;Do Refactor&lt;/code&gt; 버튼을 클릭합니다. (바꾸고 싶지 않은 부분을 클릭하고 &lt;code&gt;Delete&lt;/code&gt; 키나 &lt;code&gt;Cmd + X&lt;/code&gt; 키를 누르면, 해당 부분만 제외됩니다.)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/2e1/2e11cea04dd4fd98d628f6886041959e8651264ac70acfa1e71a0038538cc43b.m.png&quot; alt=&quot;바꾸고 싶지 않은 위치는 제외할 수도 있습니다&quot;&gt;&lt;figcaption&gt;바꾸고 싶지 않은 위치는 제외할 수도 있습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;public_cidr_blocks&lt;/code&gt;가 모두 &lt;code&gt;public_cidrs&lt;/code&gt;로 바뀌었습니다. 단순한 문자열 찾아 바꾸기 기능이었다면 &lt;code&gt;not_public_cidr_blocks&lt;/code&gt;도 &lt;code&gt;not_public_cidrs&lt;/code&gt;로 바뀌었겠지만, 인텔리J의 Rename 기능은 정확히 원하는 이름만 찾아 바꿔줍니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e76/e760322d8cb9126f3d89da739bd1ef190c900231a015b53d03f03e47fef85531.m.png&quot; alt=&quot;not_public_cidr_blocks은 바뀌지 않았습니다&quot;&gt;&lt;figcaption&gt;not_public_cidr_blocks은 바뀌지 않았습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 외에 중복되는 &lt;code&gt;[&quot;0.0.0.0/0&quot;]&lt;/code&gt; 같은 값을 변수화하는 등의 리팩터링 기능도 지원합니다.&lt;/p&gt;
&lt;h2 id=&quot;코드-하이라이팅&quot;&gt;코드 하이라이팅&lt;/h2&gt;
&lt;p&gt;지금까지 내용을 따라오셨다면 HCL 문법 하이라이팅이 잘 되고 있음도 확인하셨겠죠?&lt;/p&gt;
&lt;h2 id=&quot;포매팅&quot;&gt;포매팅&lt;/h2&gt;
&lt;p&gt;테라폼에서 제공하는 &lt;code&gt;terraform fmt&lt;/code&gt; 명령으로 들여쓰기나 정렬 방식을 맞출 수 있지만, 에디터와 콘솔을 오가기가 조금 불편한 것은 사실입니다. 인텔리J에서는 테라폼 포매팅을 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aws_vpc.other&lt;/code&gt; 리소스에 &lt;code&gt;count = 1&lt;/code&gt;을 추가해봅시다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/56e/56e33ace696bf2a6a4c7ce573307157ce7ec897fe50cb1f8afac9772e926ec45.m.png&quot; alt=&quot;파일 포매팅이 맞지 않는 상황&quot;&gt;&lt;figcaption&gt;파일 포매팅이 맞지 않는 상황&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이제 &lt;code&gt;Shift + Alt + Cmd + F&lt;/code&gt; 키를 누르면 포매팅이 적용됩니다. (메뉴에서 &lt;code&gt;Code -&amp;gt; Terraform Tools -&amp;gt; Terraform fmt file&lt;/code&gt;을 선택해도 됩니다.)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/473/473044a5f78c829a95c0d9cf2dabcee1c7e010e046738c542aef2ea4a208b4c4.m.png&quot; alt=&quot;포매팅이 수정된 모습&quot;&gt;&lt;figcaption&gt;포매팅이 수정된 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;현재-파일의-구조-보기파일이-커졌을-때-유용할-듯&quot;&gt;현재 파일의 구조 보기(파일이 커졌을 때 유용할 듯)&lt;/h2&gt;
&lt;p&gt;하나의 테라폼 파일을 길게 관리하는 습관이 있다면 전체 구조를 파악하기가 조금 어려웠을 겁니다. 이를 위해 인텔리J에서는 파일 구조 뷰를 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cmd + 7&lt;/code&gt; 키를 누르면 다음과 같이 파일 구조 뷰가 나타납니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/e71/e71916aff20c6b44a309716b0d37748875d2e3b36ca85e16bcda86ae1d1fa581.m.png&quot; alt=&quot;파일 구조 뷰에서 파일 전체 구조를 파악하기가 쉽습니다&quot;&gt;&lt;figcaption&gt;파일 구조 뷰에서 파일 전체 구조를 파악하기가 쉽습니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;추가-예정-기능들&quot;&gt;추가 예정 기능들&lt;/h2&gt;
&lt;p&gt;이후 버전에서는 변수의 타입 확인이나 모듈 의존성 같은 기능들도 추가된다고 하니, 당분간은 인텔리J가 테라폼 사용자의 필수 에디터로 자리 잡기에 충분하리라 생각합니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Tue, 26 Feb 2019 01:32:54 +0000</pubDate>
      <dc:date>2019-02-26T01:32:54+00:00</dc:date>
    </item>
    <item>
      <title>개발자라면 탐나는 .dev 최상위 도메인 등록 시작</title>
      <link>https://www.44bits.io/ko/post/dot-dev-doamin-for-developers</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        개발자라면 탐나는 .dev 최상위 도메인 등록 시작
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;구글-.dev-최상위-도메인-공개&quot;&gt;구글, .dev 최상위 도메인 공개&lt;/h2&gt;
&lt;p&gt;구글&lt;sup&gt;Google&lt;/sup&gt;은 &lt;a href=&quot;https://get.dev/&quot;&gt;닷데브(.dev)&lt;/a&gt;라는 최상위 도메인(TLD&lt;sup&gt;Top Level Domain&lt;/sup&gt;)을 공개 했습니다. 프로그래머, 커뮤니티, 개발 도구, 개발 문서 등 개발과 관련된 다양한 용도로 많이 사용될 것으로 기대됩니다.&lt;/p&gt;
&lt;p&gt;.dev 도메인은 HSTS 목록에 우선 탑재되어 HTTPS 요청이 강제된다는 점이 다른 도메인과 차별화 되는 요소입니다. HSTS는 웹서버에서 설정 하고 최초 요청 이후부터 HTTPS가 강제되는데 .dev의 모든 도메인은 HSTS가 미리 설정된 상태라서 별도 작업이 필요없이 HTTPS가 강제됩니다.&lt;/p&gt;
&lt;p&gt;공식 공개 전 .dev에 우선 등록된 서비스 몇 가지를 소개합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&quot;https://agile.dev/&quot;&gt;agile.dev&lt;/a&gt; : 지라&lt;sup&gt;Jira&lt;/sup&gt; 등을 서비스하는 아틀라시안&lt;sup&gt;Atlassian&lt;/sup&gt;에서 소유 했으며 애자일 사례를 배울수 있는 사이트가 될것으로 예상됩니다.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://crm.dev/&quot;&gt;crm.dev&lt;/a&gt; : 세일즈포스&lt;sup&gt;Salesforce&lt;/sup&gt; 소유&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://slack.dev/&quot;&gt;slack.dev&lt;/a&gt; : 슬랙&lt;sup&gt;Slack&lt;/sup&gt; SDK 관련&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://github.dev&quot;&gt;github.dev&lt;/a&gt; : 깃헙&lt;sup&gt;GitHub&lt;/sup&gt; 개인 웹사이트&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;https://nodejs.dev&quot;&gt;nodejs.dev&lt;/a&gt; : 노드js&lt;sup&gt;Node.js&lt;/sup&gt; 소개 및 QuickStart 문서&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;등록-및-비용&quot;&gt;등록 및 비용&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/659/659bcebb1553543dee069c5d6bd7c183d90a2a57916cd4c1789c4559e0d4b330.m.png&quot; alt=&quot;.dev 도메인의 사전 등록 비용&quot;&gt;&lt;figcaption&gt;.dev 도메인의 사전 등록 비용&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;.dev 도메인은 2019년 2월 19일부터 28일까지 사전 등록 기간을 가집니다. 사전 등록 시점에 따라서 등록 비용이 다릅니다. 2월 19일에 $11,500를 시작으로 2월 28일에는 $0까지 내려갑니다. 다른 사람보다 먼저 도메인을 선점하고 싶다면 사전 비용을 내고 도메인을 등록해야합니다. 연 $12의 도메인 사용료는 별도입니다.&lt;/p&gt;
&lt;p&gt;사전 등록 기간이 종료되는 2019년 2월 28일 오전 8시 PST(한국시간 3월 1일 새벽 1시)부터는 다른 도메인과 마찬가지로 사전 등록 비용이 없이 1년 $12의 도메인 사용 비용만 납부하면 됩니다.&lt;/p&gt;
&lt;p&gt;도메인의 등록은 &lt;a href=&quot;https://www.namecheap.com/&quot;&gt;namecheap&lt;/a&gt;, &lt;a href=&quot;https://www.godaddy.com&quot;&gt;GoDaddy&lt;/a&gt;, &lt;a href=&quot;https://www.gandi.net&quot;&gt;gandi&lt;/a&gt;, &lt;a href=&quot;https://domains.google&quot;&gt;Google Domains&lt;/a&gt; 등을 통해 가능합니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>seapy</author>
      <pubDate>Mon, 25 Feb 2019 00:49:55 +0000</pubDate>
      <dc:date>2019-02-25T00:49:55+00:00</dc:date>
    </item>
    <item>
      <title>[44bits.tv] AWS 클라우드와치 로그 쉽게보는 방법 - utern</title>
      <link>https://www.44bits.io/ko/post/44bits-tv-aws-cloudwatch-utern-seapy</link>
      <description></description>
      <author>stdoutfm</author>
      <pubDate>Fri, 15 Feb 2019 07:35:33 +0000</pubDate>
      <dc:date>2019-02-15T07:35:33+00:00</dc:date>
    </item>
    <item>
      <title>구글, 사이트 신뢰성 엔지니어링 워크북(Site Reliability Workbook) 온라인 무료 공개</title>
      <link>https://www.44bits.io/ko/post/news--google-open-site-reliability-workbook</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        구글, 사이트 신뢰성 엔지니어링 워크북 온라인 무료 공개
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;사이트-신뢰성-워크북-온라인-공개&quot;&gt;사이트 신뢰성 워크북 온라인 공개&lt;/h2&gt;
&lt;p&gt;2018년 8월 7일에 기사에서는 사이트 신뢰성 워크북 출간과 PDF 버전의 일시 무료 공개 소식을 전해드렸습니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;사이트 신뢰성 워크북&lt;sup&gt;The Site Reliability Workbook&lt;/sup&gt;은 사이트 신뢰성 엔지니어링을 보완하는 책으로서 SRE의 원칙(principle)과 실천(practice)을 실무에 적용하기 위한 구글과 구글 클라우드 플랫폼 고객사들의 예제를 담고 있습니다. &lt;span class=&quot;cite-wrapper&quot;&gt; &lt;cite&gt;&lt;a href=&quot;https://www.44bits.io/ko/post/news--site-reliability-workbook-is-published&quot;&gt;구글, 사이트 신뢰성 워크북 공개 | 44bits&lt;/a&gt;&lt;/cite&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;2019년 1월 26일부터는 이 책을 온라인 상에서 무료로 읽을 수 있게 되었습니다. 사이트 신뢰성 엔지니어링&lt;sup&gt;Site Reliability Engineering&lt;/sup&gt;과 마찬가지로 구글의 &lt;a href=&quot;https://landing.google.com/sre/&quot;&gt;SRE 공식 페이지&lt;/a&gt;에 공개되었습니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/4dc/4dc04052ba5ea3ad1bba9177020cd60a480b6b8d3397bff73830bb783ca00ef7.m.png&quot; alt=&quot;공개된 사이트 신뢰성 워크북&quot;&gt;&lt;figcaption&gt;공개된 사이트 신뢰성 워크북&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://landing.google.com/sre/workbook/toc/&quot;&gt;Google - 사이트 신뢰성 워크북&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;sre-팀-수준-별-체크리스트&quot;&gt;SRE 팀 수준 별 체크리스트&lt;/h2&gt;
&lt;p&gt;구글에서는 사이트 신뢰성 워크북을 공개하면서, 이 책을 잘 활용할 수 있도록 각 회사 SRE 팀의 수준(시작, 초급, 중급, 고급)을 파악할 수 있는 체크리스트를 함께 소개했습니다. 예를 들어 이제 막 SRE 팀을 시작하는 단계에서는 다음과 같은 조건을 만족해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;✔ &lt;a href=&quot;http://landing.google.com/sre/workbook/chapters/implementing-slos&quot;&gt;일부 서비스 수준 목표&lt;sup&gt;SLO, Service level objectives&lt;/sup&gt;가 정의&lt;/a&gt;되어 있음&lt;/li&gt;
&lt;li&gt;✔ &lt;a href=&quot;http://landing.google.com/sre/workbook/chapters/postmortem-culture/&quot;&gt;비난 없는 포스트모템을 만드는 문화&lt;/a&gt;가 있음&lt;/li&gt;
&lt;li&gt;✔ &lt;a href=&quot;http://landing.google.com/sre/workbook/chapters/incident-response/&quot;&gt;사고에 대응하는 프로세스&lt;/a&gt;가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 조건을 모두 만족했다면 다음 단계인 초급&lt;sup&gt;Beginner&lt;/sup&gt; SRE 팀 단계로 넘어갈 수 있습니다. 보다 자세한 내용은 구글 클라우드 블로그의 &lt;a href=&quot;https://cloud.google.com/blog/products/devops-sre/how-to-start-and-assess-your-sre-journey&quot;&gt;아직 SRE 팀이 없나요? SRE 팀을 시작하고 평가하는 방법&lt;/a&gt;을 참고해주세요.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>raccoony</author>
      <pubDate>Tue, 12 Feb 2019 01:04:32 +0000</pubDate>
      <dc:date>2019-02-12T01:04:32+00:00</dc:date>
    </item>
    <item>
      <title>[44bits.tv] VS Code 귀여운 캐릭터 표시하기 with live2d</title>
      <link>https://www.44bits.io/ko/post/44bits-vscode-cute-character-plugin</link>
      <description></description>
      <author>seapy</author>
      <pubDate>Tue, 29 Jan 2019 07:11:26 +0000</pubDate>
      <dc:date>2019-01-29T07:11:26+00:00</dc:date>
    </item>
    <item>
      <title>Bash, Zsh에서 여러줄의 명령어를 에디터로 편집하고 실행하기</title>
      <link>https://www.44bits.io/ko/post/editing-multiline-command-on-shell</link>
      <description>&lt;article&gt;
      &lt;div class=&quot;wrapper&quot;&gt;
      
            &lt;header&gt;
        &lt;h1 class=&quot;title&quot;&gt;
        셸에서 여러줄의 명령어를 에디터로 편집하고 실행하기
                &lt;/h1&gt;
      &lt;/header&gt;
                  
            &lt;h2 id=&quot;들어가며-긴-명령어를-셸에서-편집하는-괴로움&quot;&gt;들어가며: 긴 명령어를 셸에서 편집하는 괴로움&lt;/h2&gt;
&lt;p&gt;커맨드라인 인터페이스에서 긴 명령어를 다루는 일은 상당히 어려운 일입니다. 특히 셸과 같은 인터렉티브한 인터페이스에서는 한 줄에 명령어 하나를 입력하는 것이 기본입니다. 환경에 따라 다르지만 한 줄에 긴 명령어를 입력하면 입력화면이 깨지는 일도 흔합니다. 여러 줄을 편집하다가 실수로 실행해버리는 일도 많고, 히스토리로 이전 명령어를 부르면 줄바꿈 문자가 이상하게 해석되기도 합니다. 긴 명령어나 여러 줄의 명령어를 입력하는 것이 불가능한 것은 아니지만 실제로 사용하기에는 상당히 불편합니다.&lt;/p&gt;
&lt;p&gt;예를 들어보겠습니다. 다음과 같이 도커 컨테이너로 포스트그레SQL&lt;sup&gt;PostgreSQL&lt;/sup&gt;을 실행하는 명령어가 있습니다. 도커 명령어는 환경변수를 통해서 컨테이너의 실행 환경을 정의하기 때문에 환경변수의 수에 비례해서 실명 명령어가 길어집니다. 도커를 사용해보신 분이라면 이 정도 길이의 명령어가 아주 흔하다는 걸 이해하실 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -d -p 5432:5432 --name my_postgres -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=inviolable_password -e POSTGRES_DATABASE=postgres -e PGDATA=/var/lib/postgresql/my_data -v $(PWD)/data:/var/lib/postgresql/my_data postgres:11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아주 불편합니다. 온라인 튜토리얼을 따라하고 있다고 생각해보겠습니다. 아무리 길어도 차라리 &lt;strong&gt;실행 가능한&lt;/strong&gt; 명령어를 한 줄로 알려주는 것은 편리한 일입니다. 왜냐면 복사해서 붙여넣으면 어떻게든 실행이 되기 때문입니다.&lt;/p&gt;
&lt;p&gt;하지만 모든 경우에 완성된 명령어를 제공할 수는 없습니다. 다음과 같이 사용자가 환경이나 상황에 따라 명령어를 편집해야하는 경우도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -d -p 5432:5432 --name my_postgres -e POSTGRES_USER=&amp;lt;USERNAME&amp;gt; -e POSTGRES_PASSWORD=&amp;lt;PASSWORD&amp;gt; -e POSTGRES_DATABASE=&amp;lt;DATABASE&amp;gt; -e PGDATA=/var/lib/postgresql/my_data -v $(PWD)/data:/var/lib/postgresql/my_data postgres:11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일반적으로 이러한 명령어의 경우 &lt;code&gt;&amp;lt;USERNAME&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PASSWORD&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;DATABASE&amp;gt;&lt;/code&gt;를 사용자가 직접 수정해서 실행해야만합니다. 이제 저 명령어를 그대로 셸에다 복사해놓고 편집하려고 하면 아주 고통스러운 상황이 펼쳐집니다. 어떻게든 수정해서 실행할 수는 있습니다. 그래서 글을 쓰는 사람들은 이렇게 명령어가 길어진다면 보통 아래와 같이 여러줄로 명령어를 표현합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -d \
  -p 5432:5432 \
  --name my_postgres \
  -e POSTGRES_USER=&amp;lt;USERNAME&amp;gt; \
  -e POSTGRES_PASSWORD=&amp;lt;PASSWORD&amp;gt; \
  -e POSTGRES_DATABASE=&amp;lt;DATABASE&amp;gt; \
  -e PGDATA=/var/lib/postgresql/my_data \
  -v $(PWD)/data:/var/lib/postgresql/my_data \
  postgres:11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보기 좋네요! &lt;a href=&quot;https://www.44bits.io/ko&quot;&gt;44bits.io&lt;/a&gt;에서도 긴 명령어를 표현할 때 자주 사용하는 방법입니다. 하지만 보기만 좋을 뿐 이러한 명령어를 셸에 그대로 복사해서 편집하는 것은 아주아주 어렵습니다. 셸에서 직접 멀티라인 명령어를 편집하는 것은 교묘합니다. 셸에 익숙하다면 도전해볼만합니다만, 커서는 생각처럼 움직이지 않고, 입력 인터페이스가 깨지기도 하며, 변수(&lt;code&gt;&amp;lt;USERNAME&amp;gt;&lt;/code&gt; 등)를 편집하다가 실수로 명령어를 실행해버리는 일도 흔합니다. 디버깅은 더욱 어렵습니다. 일반적으로 멀티라인은 역슬래시(&lt;code&gt;\&lt;/code&gt;) 문자로 구분합니다만, 역슬래시 뒤에 공백 문자라도 하나 들어가있다면, 이 명령어는 실행되지 않습니다.&lt;/p&gt;
&lt;p&gt;이런 상황이면 한 줄 짜리 명령어가 차라리 낫다고 느낄지도 모릅니다. 그래서 보통 이렇게 긴 명령어를 편집하고자할 때는 다른 에디터를 열어서 명령어를 편집하고 그 명령어를 다시 복사하고, 셸에 붙여넣어서 실행할 것입니다. (여전히 실행하기 전에 꼭 역슬래시 뒤에 공백이 있는지 확인해야합니다)&lt;/p&gt;
&lt;p&gt;이러한 고통에서 벗어나기 위한 손쉬운 방법이 있습니다. 셸에서 에디터를 열고 명령어를 편집하고 바로 실행하는 방법입니다. 이 방법은 긴 명령어를 복사할 때 뿐만 아니라, 긴 명령어를 직접 입력할 때도 편리한 방법입니다. 이 글에서는 Bash 셸과 Zsh에서 긴 명령어를 에디터로 편집하고 실행하는 방법에 대해서 소개합니다.&lt;/p&gt;
&lt;h2 id=&quot;bash에서-명령어를-에디터로-편집하고-바로-실행하기&quot;&gt;Bash에서 명령어를 에디터로 편집하고 바로 실행하기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/bash/manual/html_node/Miscellaneous-Commands.html&quot;&gt;Bash 레퍼런스 매뉴얼&lt;/a&gt;에는 &lt;code&gt;edit-and-execute-command&lt;/code&gt; 명령어가 소개되어있습니다.&lt;/p&gt;
&lt;div class=&quot;quote&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;edit-and-execute-command&lt;/strong&gt; (C-x C-e) 현재 커맨드라인에서 에디터를 실행하고, 편집한 결과를 셸 명령어로 실행한다. Bash에서는 $VISUAL, $EDITOR, emacs 순으로 에디터를 찾아서 실행한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;Bash 사용자라면 이 명령어를 사용해 곧바로 셸에서 에디터를 실행하고 편집 결과를 실행하는 것이 가능합니다. 여기서 &lt;code&gt;C-x C-e&lt;/code&gt;는 키바인딩을 표현하는 방법으로 &lt;code&gt;control + x&lt;/code&gt;와 &lt;code&gt;control + e&lt;/code&gt;를 연속해서 입력하라는 의미입니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 컨트롤 키를 누른 채로 입력해도 무방합니다. 이 때 실행하는 에디터 명령어는 환경변수 $VISUAL을 찾고, 값이 없으면 $EDITOR를 찾고, 그래도 값이 없으면 이맥스&lt;sup&gt;Emacs&lt;/sup&gt;를 사용합니다. 물론 시스템에 이맥스가 설치되어있지 않다면 에디터를 실행하지 못 합니다.&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 맥OS&lt;sup&gt;macOS&lt;/sup&gt;에서도 C는 컨트롤 키입니다. 커맨드&lt;sup&gt;command&lt;/sup&gt; 키가 아닙니다. 맥에서는 자주 사용되지 않지만, 키보드 왼쪽의 옵션&lt;sup&gt;option&lt;/sup&gt; 키 왼쪽에 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;가능하면 이맥스나 빔 같은 커맨드라인에서 바로 편집가능한 에디터를 추천합니다만, GUI 에디터를 사용하는 것도 가능합니다. 여기서는 &lt;a href=&quot;https://macromates.com/&quot;&gt;텍스트메이트&lt;/a&gt;&lt;sup&gt;TextMate&lt;/sup&gt;로 같은 기능을 사용해보겠습니다.&lt;/p&gt;
&lt;p&gt;먼저 텍스트메이트의 메뉴에서 &lt;em&gt;설정&lt;/em&gt;&lt;sup&gt;Preferences&lt;/sup&gt;을 찾아 선택합니다. &lt;em&gt;터미널&lt;/em&gt;&lt;sup&gt;Terminal&lt;/sup&gt; 탭을 선택합니다. 셸 지원 기능을 &lt;em&gt;설치&lt;/em&gt;&lt;sup&gt;Install&lt;/sup&gt;합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/f2f/f2f4f4c1b8848aa40df66d7ab9ba2c70a5125e4094d8b8c0fd04bb8265a63b53.m.png&quot; alt=&quot;텍스트 메이트의 터미널 설정 메뉴&quot;&gt;&lt;figcaption&gt;텍스트 메이트의 터미널 설정 메뉴&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이제 셸에서 &lt;code&gt;mate&lt;/code&gt; 명령어로 텍스트메이트를 실행할 수 있습니다. 이 명령어를 &lt;code&gt;export&lt;/code&gt;를 사용해 &lt;code&gt;$EDIOTR&lt;/code&gt; 환경변수의 값으로 설정합니다. &lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; &lt;code&gt;export&lt;/code&gt; 명령어는 현재 사용중인 셸에서만 적용됩니다. 이 값을 앞으로 사용하는 모든 셸에 적용하려면 &lt;code&gt;.bashrc&lt;/code&gt;나 Bash 실행 시 로드하는 설정 파일에 추가해야합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;export EDITOR=&quot;/usr/local/bin/mate -w&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 준비는 끝났습니다. &lt;code&gt;C-x C-e&lt;/code&gt;를 입력하면 Bash 셸은 대기 상태가 되고 텍스트 메이트 에디터가 실행됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/45a/45ab18fdf844e37b3c6683dd957b837fc7a83869926fd97f771782e5e5d53b03.m.png&quot; alt=&quot;명령어 입력을 위해 실행된 텍스트 메이트&quot;&gt;&lt;figcaption&gt;명령어 입력을 위해 실행된 텍스트 메이트&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;현재 파일명은 &lt;code&gt;bash-fc-1544864699&lt;/code&gt;라는 파일입니다. 이 파일은 명령어를 편집하기 위한 임시파일입니다. 이 파일을 편집하고 이 내용을 저장하고 에디터를 종료하면 곧바로 셸에서 실행이 됩니다. 앞서 예제로 보았던 도커 명령어를 입력해봅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d \
  -p 5432:5432 \
  --name my_postgres \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DATABASE=postgres \
  -e PGDATA=/var/lib/postgresql/my_data \
  -v $(PWD)/data:/var/lib/postgresql/my_data \
  postgres:11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;에디터를 사용해서 명령어를 복사하고 원하는대로 편집하면 됩니다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/195/19530723c322ce1111a236868cb7a50ecf406b79455cb57f5679707317a085d0.m.png&quot; alt=&quot;텍스트 메이트에서 셸에서 실행할 명령어를 편집합니다&quot;&gt;&lt;figcaption&gt;텍스트 메이트에서 셸에서 실행할 명령어를 편집합니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이 내용을 저장하고(&lt;code&gt;command + s&lt;/code&gt;), 에디터를 종료합니다(&lt;code&gt;command + w&lt;/code&gt;).&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; 이 방법을 사용해서 명령어를 입력할 때는 에디터를 종료하기 전에 미리 저장하는 방식을 추천드립니다. 이렇게 사용하면 에디터 종료 시에 저장하겠냐고 묻지 않으며, 명령어 편집 후 에디터에 임시 파일이 남아있지 않습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/af0/af0728f3dfaf038fad8749ace0aa3652893958efd57ecc420cb28528114d31a6.m.png&quot; alt=&quot;텍스트 메이트에서 편집한 명령어가 셸에서 곧바로 실행됩니다&quot;&gt;&lt;figcaption&gt;텍스트 메이트에서 편집한 명령어가 셸에서 곧바로 실행됩니다&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;에디터에서 편집한 내용이 곧바로 셸에서 실행되는 것을 확인할 수 있습니다. 또한 셸에서 명령어를 입력하는 중에 &lt;code&gt;edit-and-execute-command&lt;/code&gt;를 실행하면, 입력중인 명령어가 에디터로 그대로 복사됩니다. 이 기능을 사용하는데 특별히 어려운 점은 없습니다.&lt;/p&gt;
&lt;p&gt;단 &lt;code&gt;edit-and-execute-command&lt;/code&gt;를 사용할 때 몇 가지 주의해야할 점이 있습니다. 자신이 선호하는 에디터를 사용할 수 있습니다만, 여기서 사용하는 에디터는 가벼우면 가벼울 수록 좋습니다. 셸에서 바로 사용 가능한 이맥스나 빔을 추천하는 이유는 빠르고 원격 환경에서도 사용할 수 있기 때문입니다. 텍스트메이트나 서브라임 에디터는 비교적 빠르게 실행되는 편이지만, 다른 에디터들은 처음 실행 시간이 꽤 길어질 수 있으니 주의가 필요합니다.&lt;/p&gt;
&lt;h2 id=&quot;zsh의-경우&quot;&gt;Zsh의 경우&lt;/h2&gt;
&lt;p&gt;Bash와 달리 Zsh의 경우에는 &lt;code&gt;edit-and-execute-command&lt;/code&gt; 명령어가 없습니다. 대신 &lt;code&gt;edit-command-line&lt;/code&gt; 함수가 준비되어 있으며 이 함수를 &lt;code&gt;C-x C-e&lt;/code&gt;에 키바인딩해서 주로 사용합니다. 이 함수는 Bash와 다른 점이 몇 가지 있습니다.&lt;/p&gt;
&lt;p&gt;먼저 에디터 실행 순서가 조금 다릅니다. 환경변수 $VISUAL을 찾고, 값이 없으면 $EDITOR를 찾고, 그래도 값이 없으면 vi를 사용합니다. 이 함수의 소스 코드는 &lt;a href=&quot;https://github.com/zsh-users/zsh/blob/master/Functions/Zle/edit-command-line&quot;&gt;zsh 저장소&lt;/a&gt;에서 찾아볼 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local editor=( &quot;${(@Q)${(z)${VISUAL:-${EDITOR:-vi}}}}&quot; )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 이름에서 유추 가능하듯이 명령어를 편집만할 뿐 실행을 하지는 않습니다. 앞서 Bash의 경우 에디터를 종료하는 즉시 명령어가 실행되었습니다. &lt;code&gt;edit-command-line&lt;/code&gt; 함수는 편집한 내용을 복사만 하고, 직접 엔터를 입력해야 명령어가 실행됩니다.&lt;/p&gt;
&lt;p&gt;이 기능을 사용하려면 아래 내용을 &lt;code&gt;~/.zshrc&lt;/code&gt;에 추가해야합니다.&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sidenote&quot;&gt;
&lt;p&gt;&lt;span class=&quot;sidenote-symbol&quot;&gt;*&lt;/span&gt; oh-my-zsh을 사용하는 경우 기본적으로 &lt;code&gt;edit-command-line&lt;/code&gt; 이 설정되어 있습니다. 추가적인 설정 없이 &lt;code&gt;C-x C-e&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;autoload -U edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설정 파일을 수정한 후에는 &lt;code&gt;source ~/.zshrc&lt;/code&gt;로 설정 파일을 다시 불러오거나, 셸을 다시 실행합니다. 자신이 사용하고자 하는 에디터를 &lt;code&gt;$EDITOR&lt;/code&gt;에 지정합니다. 그리고 &lt;code&gt;C-x C-e&lt;/code&gt;를 입력해합니다. 기본적인 사용법은 Bash와 다르지 않습니다. 에디터에서 임시 파일을 편집하고 이를 저장하고(command + s) 종료합니다(command + w).&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://static.hubtee.com/files/9c9/9c9dbbf8ba5da9d7dccbfa42e0dbab2c2f5e50b99479a45f01743b02ebe7ca08.m.png&quot; alt=&quot;텍스트 에디터의 명령어가 셸에 입력된 모습&quot;&gt;&lt;figcaption&gt;텍스트 에디터의 명령어가 셸에 입력된 모습&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;앞서 설명했듯이 zsh에서는 명령어가 바로 실행되지 않습니다. 이 상태에서 명령어를 확인하거나 추가적으로 편집한 후 엔터를 입력하면 명령어가 실행됩니다.&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;edit-and-execute-command&lt;/code&gt;나 &lt;code&gt;edit-command-line&lt;/code&gt;는 사소하지만 유용한 기능입니다. 다른 셸에서도 찾아보면 비슷한 기능을 지원할 것입니다. 셸의 입력 환경에는 여러가지 제약이 있다보니, 여기서 긴 명령어를 입력하는 게 가장 좋은 방법은 아닙니다. 그렇다고 명령어가 길어질 때마다 간단한 스크립트를 만들어 사용하는 것도 한계가 있습니다. 따라서 이러한 기능은 잘 활용하면 아주 유용합니다. 더 이상 역슬래시로 나눠진 여러 줄로 구성된 명령어를 보더라도 겁먹지 마시기 바랍니다.&lt;/p&gt;
            &lt;footer&gt;&lt;/footer&gt;
      &lt;/div&gt;
    &lt;/article&gt;</description>
      <author>nacyot</author>
      <pubDate>Tue, 29 Jan 2019 05:37:17 +0000</pubDate>
      <dc:date>2019-01-29T05:37:17+00:00</dc:date>
    </item>
    <dc:date>2019-11-12T17:08:07.541545+09:00</dc:date>
  </channel>
</rss>